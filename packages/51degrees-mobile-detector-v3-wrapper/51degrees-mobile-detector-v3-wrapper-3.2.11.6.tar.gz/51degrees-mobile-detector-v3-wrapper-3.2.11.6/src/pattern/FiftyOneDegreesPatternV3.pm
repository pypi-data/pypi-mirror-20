# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package FiftyOneDegreesPatternV3;
use base qw(Exporter);
use base qw(DynaLoader);
package FiftyOneDegreesPatternV3c;
bootstrap FiftyOneDegreesPatternV3;
package FiftyOneDegreesPatternV3;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package FiftyOneDegreesPatternV3;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package FiftyOneDegreesPatternV3;


############# Class : FiftyOneDegreesPatternV3::MapStringString ##############

package FiftyOneDegreesPatternV3::MapStringString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( FiftyOneDegreesPatternV3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = FiftyOneDegreesPatternV3c::new_MapStringString(@_);
    bless $self, $pkg if defined($self);
}

*size = *FiftyOneDegreesPatternV3c::MapStringString_size;
*empty = *FiftyOneDegreesPatternV3c::MapStringString_empty;
*clear = *FiftyOneDegreesPatternV3c::MapStringString_clear;
*get = *FiftyOneDegreesPatternV3c::MapStringString_get;
*set = *FiftyOneDegreesPatternV3c::MapStringString_set;
*del = *FiftyOneDegreesPatternV3c::MapStringString_del;
*has_key = *FiftyOneDegreesPatternV3c::MapStringString_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        FiftyOneDegreesPatternV3c::delete_MapStringString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : FiftyOneDegreesPatternV3::VectorString ##############

package FiftyOneDegreesPatternV3::VectorString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( FiftyOneDegreesPatternV3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = FiftyOneDegreesPatternV3c::new_VectorString(@_);
    bless $self, $pkg if defined($self);
}

*size = *FiftyOneDegreesPatternV3c::VectorString_size;
*empty = *FiftyOneDegreesPatternV3c::VectorString_empty;
*clear = *FiftyOneDegreesPatternV3c::VectorString_clear;
*push = *FiftyOneDegreesPatternV3c::VectorString_push;
*pop = *FiftyOneDegreesPatternV3c::VectorString_pop;
*get = *FiftyOneDegreesPatternV3c::VectorString_get;
*set = *FiftyOneDegreesPatternV3c::VectorString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        FiftyOneDegreesPatternV3c::delete_VectorString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : FiftyOneDegreesPatternV3::Match ##############

package FiftyOneDegreesPatternV3::Match;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( FiftyOneDegreesPatternV3 );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        FiftyOneDegreesPatternV3c::delete_Match($self);
        delete $OWNER{$self};
    }
}

*getValues = *FiftyOneDegreesPatternV3c::Match_getValues;
*getValue = *FiftyOneDegreesPatternV3c::Match_getValue;
*getDeviceId = *FiftyOneDegreesPatternV3c::Match_getDeviceId;
*getRank = *FiftyOneDegreesPatternV3c::Match_getRank;
*getDifference = *FiftyOneDegreesPatternV3c::Match_getDifference;
*getMethod = *FiftyOneDegreesPatternV3c::Match_getMethod;
*getUserAgent = *FiftyOneDegreesPatternV3c::Match_getUserAgent;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : FiftyOneDegreesPatternV3::Profiles ##############

package FiftyOneDegreesPatternV3::Profiles;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( FiftyOneDegreesPatternV3 );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        FiftyOneDegreesPatternV3c::delete_Profiles($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = FiftyOneDegreesPatternV3c::new_Profiles(@_);
    bless $self, $pkg if defined($self);
}

*getCount = *FiftyOneDegreesPatternV3c::Profiles_getCount;
*getProfileIndex = *FiftyOneDegreesPatternV3c::Profiles_getProfileIndex;
*getProfileId = *FiftyOneDegreesPatternV3c::Profiles_getProfileId;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : FiftyOneDegreesPatternV3::Provider ##############

package FiftyOneDegreesPatternV3::Provider;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( FiftyOneDegreesPatternV3 );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        FiftyOneDegreesPatternV3c::delete_Provider($self);
        delete $OWNER{$self};
    }
}

*getHttpHeaders = *FiftyOneDegreesPatternV3c::Provider_getHttpHeaders;
*getAvailableProperties = *FiftyOneDegreesPatternV3c::Provider_getAvailableProperties;
*getDataSetName = *FiftyOneDegreesPatternV3c::Provider_getDataSetName;
*getDataSetFormat = *FiftyOneDegreesPatternV3c::Provider_getDataSetFormat;
*getDataSetPublishedDate = *FiftyOneDegreesPatternV3c::Provider_getDataSetPublishedDate;
*getDataSetNextUpdateDate = *FiftyOneDegreesPatternV3c::Provider_getDataSetNextUpdateDate;
*getDataSetSignatureCount = *FiftyOneDegreesPatternV3c::Provider_getDataSetSignatureCount;
*getDataSetDeviceCombinations = *FiftyOneDegreesPatternV3c::Provider_getDataSetDeviceCombinations;
*getMatch = *FiftyOneDegreesPatternV3c::Provider_getMatch;
*getMatchJson = *FiftyOneDegreesPatternV3c::Provider_getMatchJson;
*getMatchForDeviceId = *FiftyOneDegreesPatternV3c::Provider_getMatchForDeviceId;
*findProfiles = *FiftyOneDegreesPatternV3c::Provider_findProfiles;
*reloadFromFile = *FiftyOneDegreesPatternV3c::Provider_reloadFromFile;
*reloadFromMemory = *FiftyOneDegreesPatternV3c::Provider_reloadFromMemory;
*getCacheHits = *FiftyOneDegreesPatternV3c::Provider_getCacheHits;
*getCacheMisses = *FiftyOneDegreesPatternV3c::Provider_getCacheMisses;
*getCacheMaxIterations = *FiftyOneDegreesPatternV3c::Provider_getCacheMaxIterations;
sub new {
    my $pkg = shift;
    my $self = FiftyOneDegreesPatternV3c::new_Provider(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package FiftyOneDegreesPatternV3;

1;
