#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from grako.buffering import Buffer
from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS, generic_main  # noqa


__all__ = [
    'ScalaParser',
    'ScalaSemantics',
    'main'
]

KEYWORDS = {
    'case',
    'catch',
    'class',
    'def',
    'do',
    'else',
    'extends',
    'false',
    'final',
    'finally',
    'for',
    'forSome',
    'if',
    'implicit',
    'import',
    'lazy',
    'match',
    'new',
    'null',
    'object',
    'override',
    'package',
    'private',
    'protected',
    'super',
    'this',
    'throw',
    'trait',
    'true',
    'try',
    'val',
    'var',
    'while',
    'with',
}


class ScalaBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=' ',
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(ScalaBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class ScalaParser(Parser):
    def __init__(
        self,
        whitespace=' ',
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=False,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=ScalaBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(ScalaParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @graken()
    def _nl1_(self):
        with self._optional():
            self._eolComment_()
            self.name_last_node('comment')
        self._token('\n')
        self.name_last_node('nl')
        self.ast._define(
            ['comment', 'nl'],
            []
        )

    @graken()
    def _nl_(self):

        def block0():
            self._nl1_()
        self._positive_closure(block0)

    @graken()
    def _seminl_(self):
        self._token(';')
        self.name_last_node('semi')
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self.ast._define(
            ['nl', 'semi'],
            []
        )

    @graken()
    def _eol_(self):
        with self._choice():
            with self._option():
                self._nl_()
            with self._option():
                self._seminl_()
            self._error('no available options')

    @graken()
    def _UnicodeEscape_(self):
        self._token('\\u')

        def block0():
            self._token('u')
        self._closure(block0)
        self._HexDigit_()
        self._HexDigit_()
        self._HexDigit_()
        self._HexDigit_()

    @graken()
    def _HexDigit_(self):
        self._pattern(r'[0-9A-Fa-f]')

    @graken()
    def _WhiteSpace_(self):
        with self._choice():
            with self._option():
                self._token(' ')
            with self._option():
                self._token('\t')
            with self._option():
                self._token('\r')
            with self._option():
                self._token('\n')
            self._error('expecting one of: \t \n \r  ')

    @graken()
    def _UnicodeUpper_(self):
        self._pattern(r'.')

    @graken()
    def _UnicodeLower_(self):
        self._pattern(r'.')

    @graken()
    def _UnicodeLetterMisc_(self):
        self._pattern(r'.')

    @graken()
    def _UnicodeOpchar_(self):
        self._pattern(r'.')

    @graken()
    def _Upper_(self):
        self._UnicodeUpper_()

    @graken()
    def _Lower_(self):
        self._UnicodeLower_()

    @graken()
    def _Letter_(self):
        with self._choice():
            with self._option():
                self._Upper_()
            with self._option():
                self._Lower_()
            with self._option():
                self._UnicodeLetterMisc_()
            self._error('no available options')

    @graken()
    def _Digit_(self):
        self._pattern(r'\d')

    @graken()
    def _paren_(self):
        with self._choice():
            with self._option():
                self._token('(')
            with self._option():
                self._token(')')
            with self._option():
                self._token('[')
            with self._option():
                self._token(']')
            with self._option():
                self._token('{')
            with self._option():
                self._token('}')
            self._error('expecting one of: ( ) [ ] { }')

    @graken()
    def _delim_(self):
        with self._choice():
            with self._option():
                self._token('`')
            with self._option():
                self._token("'")
            with self._option():
                self._token('"')
            with self._option():
                self._token('.')
            with self._option():
                self._token(';')
            with self._option():
                self._token(',')
            self._error('expecting one of: " \' , . ; `')

    @graken()
    def _assign_(self):
        self._token('=')
        self.name_last_node('op')
        with self._ifnot():
            self._Opchar_()
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self.ast._define(
            ['nl', 'op'],
            []
        )

    @graken()
    def _wildcard_(self):
        self._token('_')

    @graken()
    def _Wildcard_(self):
        self._pattern(r'_')

    @graken()
    def _arrow_(self):
        self._token('=>')
        self.name_last_node('arrow')
        with self._ifnot():
            self._Opchar_()
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self.ast._define(
            ['arrow', 'nl'],
            []
        )

    @graken()
    def _enumeratorArrow_(self):
        self._token('<-')

    @graken()
    def _projectOp_(self):
        self._token('#')

    @graken()
    def _OpcharBlocker_(self):
        with self._choice():
            with self._option():
                self._Upper_()
            with self._option():
                self._Lower_()
            with self._option():
                self._Letter_()
            with self._option():
                self._Digit_()
            with self._option():
                self._paren_()
            with self._option():
                self._delim_()
            with self._option():
                self._blockCommentStart_()
            with self._option():
                self._eolCommentStart_()
            self._error('no available options')

    @graken()
    def _PrintableChar_(self):
        self._pattern(r'[\u0020-\u007F]')

    @graken()
    def _PrintableCharNoWs_(self):
        self._pattern(r'[\u0021-\u007F]')

    @graken()
    def _Opchar_(self):
        with self._ifnot():
            self._OpcharBlocker_()
        with self._group():
            with self._choice():
                with self._option():
                    self._PrintableCharNoWs_()
                with self._option():
                    self._UnicodeOpchar_()
                self._error('no available options')

    @graken()
    def _CharEscapeSeq_(self):
        self._token('\\')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('b')
                with self._option():
                    self._token('t')
                with self._option():
                    self._token('n')
                with self._option():
                    self._token('f')
                with self._option():
                    self._token('r')
                with self._option():
                    self._token('"')
                with self._option():
                    self._token("'")
                with self._option():
                    self._token('\\')
                self._error('expecting one of: " \' \\ b f n r t')

    @graken()
    def _lpar_(self):
        self._token('(')
        self.name_last_node('par')
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self.ast._define(
            ['nl', 'par'],
            []
        )

    @graken()
    def _rpar_(self):
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self._token(')')
        self.name_last_node('par')
        self.ast._define(
            ['nl', 'par'],
            []
        )

    @graken()
    def _lbrace_(self):
        self._token('{')
        self.name_last_node('brace')
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self.ast._define(
            ['brace', 'nl'],
            []
        )

    @graken()
    def _rbrace_(self):
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self._token('}')
        self.name_last_node('brace')
        self.ast._define(
            ['brace', 'nl'],
            []
        )

    @graken()
    def _lbrack_(self):
        self._token('[')
        self.name_last_node('brack')
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self.ast._define(
            ['brack', 'nl'],
            []
        )

    @graken()
    def _rbrack_(self):
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self._token(']')
        self.name_last_node('brack')
        self.ast._define(
            ['brack', 'nl'],
            []
        )

    @graken()
    def _prefixOperator_(self):
        with self._choice():
            with self._option():
                self._token('-')
            with self._option():
                self._token('+')
            with self._option():
                self._token('~')
            with self._option():
                self._token('!')
            self._error('expecting one of: ! + - ~')

    @graken()
    def _syntaxOperator_(self):
        with self._choice():
            with self._option():
                self._arrow_()
            with self._option():
                self._assign_()
            with self._option():
                self._enumeratorArrow_()
            self._error('no available options')

    @graken()
    def _this_(self):
        self._token('this')

    @graken()
    def _booleanLiteral_(self):
        with self._choice():
            with self._option():
                self._token('true')
            with self._option():
                self._token('false')
            self._error('expecting one of: false true')

    @graken('token')
    def _integerLiteral_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._decimalNumeral_()
                with self._option():
                    self._hexNumeral_()
                self._error('no available options')
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('L')
                with self._option():
                    self._token('l')
                self._error('expecting one of: L l')

    @graken()
    def _negativeIntegerLiteral_(self):
        self._token('-')
        self.name_last_node('minus')
        self._integerLiteral_()
        self.name_last_node('value')
        self.ast._define(
            ['minus', 'value'],
            []
        )

    @graken('token')
    def _decimalNumeral_(self):
        with self._choice():
            with self._option():
                self._token('0')
            with self._option():
                self._nonZeroDigit_()

                def block0():
                    self._Digit_()
                self._closure(block0)
            self._error('expecting one of: 0')

    @graken('token')
    def _hexNumeral_(self):
        self._token('0')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('x')
                with self._option():
                    self._token('X')
                self._error('expecting one of: X x')
        self._HexDigit_()

        def block1():
            self._HexDigit_()
        self._closure(block1)

    @graken('token')
    def _nonZeroDigit_(self):
        self._pattern(r'[1-9]')

    @graken('token')
    def _floatingPointLiteral_(self):
        with self._choice():
            with self._option():

                def block0():
                    self._Digit_()
                self._positive_closure(block0)
                self._token('.')

                def block1():
                    self._Digit_()
                self._positive_closure(block1)
                with self._optional():
                    self._exponentPart_()
                with self._optional():
                    self._floatType_()
            with self._option():
                self._token('.')

                def block2():
                    self._Digit_()
                self._positive_closure(block2)
                with self._optional():
                    self._exponentPart_()
                with self._optional():
                    self._floatType_()
            with self._option():

                def block3():
                    self._Digit_()
                self._positive_closure(block3)
                self._exponentPart_()
                with self._optional():
                    self._floatType_()
            with self._option():

                def block4():
                    self._Digit_()
                self._positive_closure(block4)
                with self._optional():
                    self._exponentPart_()
                self._floatType_()
            self._error('no available options')

    @graken()
    def _negativeFloatingPointLiteral_(self):
        self._token('-')
        self.name_last_node('minus')
        self._floatingPointLiteral_()
        self.name_last_node('value')
        self.ast._define(
            ['minus', 'value'],
            []
        )

    @graken()
    def _exponentPart_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('E')
                with self._option():
                    self._token('e')
                self._error('expecting one of: E e')
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('-')
                self._error('expecting one of: + -')

        def block2():
            self._Digit_()
        self._positive_closure(block2)

    @graken()
    def _floatType_(self):
        with self._choice():
            with self._option():
                self._token('F')
            with self._option():
                self._token('f')
            with self._option():
                self._token('D')
            with self._option():
                self._token('d')
            self._error('expecting one of: D F d f')

    @graken()
    def _CharNoQuoteOrNewline_(self):
        with self._ifnot():
            with self._group():
                with self._choice():
                    with self._option():
                        self._nl_()
                    with self._option():
                        self._token("'")
                    self._error("expecting one of: '")
        self._PrintableChar_()

    @graken()
    def _CharNoDoubleQuote_(self):
        with self._ifnot():
            self._token('"')
        self._PrintableChar_()

    @graken()
    def _CharNoDoubleQuoteOrNewline_(self):
        with self._ifnot():
            with self._group():
                with self._choice():
                    with self._option():
                        self._nl_()
                    with self._option():
                        self._token('"')
                    self._error('expecting one of: "')
        self._PrintableChar_()

    @graken()
    def _characterLiteral_(self):
        self._token("'")
        with self._group():
            with self._choice():
                with self._option():
                    self._CharNoQuoteOrNewline_()
                with self._option():
                    self._UnicodeEscape_()
                with self._option():
                    self._CharEscapeSeq_()
                self._error('no available options')
        self._token("'")

    @graken()
    def _StringElement_(self):
        with self._choice():
            with self._option():
                self._CharNoDoubleQuoteOrNewline_()
            with self._option():
                self._UnicodeEscape_()
            with self._option():
                self._CharEscapeSeq_()
            self._error('no available options')

    @graken('token')
    def _stringLiteralData_(self):

        def block0():
            self._StringElement_()
        self._closure(block0)

    @graken()
    def _SingleQuote_(self):
        self._token('"')

    @graken()
    def _openingSingleQuote_(self):
        with self._optional():
            self._plainidName_()
            self.name_last_node('context')
        self._SingleQuote_()
        self.name_last_node('quote')
        self.ast._define(
            ['context', 'quote'],
            []
        )

    @graken()
    def _TripleQuote_(self):
        self._token('"""')

    @graken()
    def _openingTripleQuote_(self):
        with self._optional():
            self._plainidName_()
            self.name_last_node('context')
        self._TripleQuote_()
        self.name_last_node('quote')
        self.ast._define(
            ['context', 'quote'],
            []
        )

    @graken()
    def _singleLineStringLiteral_(self):
        self._openingSingleQuote_()
        self.name_last_node('lquote')
        self._stringLiteralData_()
        self.name_last_node('data')
        self._token('"')
        self.name_last_node('rquote')
        self.ast._define(
            ['data', 'lquote', 'rquote'],
            []
        )

    @graken()
    def _multiLineChars_(self):

        def block0():
            with self._optional():
                self._token('"')
            with self._optional():
                self._token('"')
            with self._group():
                with self._choice():
                    with self._option():
                        self._CharNoDoubleQuote_()
                    with self._option():
                        self._token('\n')
                    self._error('expecting one of: \n')
        self._closure(block0)

    @graken()
    def _multiLineStringLiteral_(self):
        self._openingTripleQuote_()
        self.name_last_node('lquote')
        self._multiLineChars_()
        self.name_last_node('data')
        self._token('"""')
        self.name_last_node('rquote')
        self.ast._define(
            ['data', 'lquote', 'rquote'],
            []
        )

    @graken()
    def _stringLiteral_(self):
        with self._choice():
            with self._option():
                self._multiLineStringLiteral_()
            with self._option():
                self._singleLineStringLiteral_()
            self._error('no available options')

    @graken()
    def _symbolLiteral_(self):
        self._token("'")
        self._plainidName_()

    @graken()
    def _blockCommentStart_(self):
        self._token('/*')

    @graken()
    def _blockCommentEnd_(self):
        self._token('*/')

    @graken()
    def _blockCommentChar1_(self):
        with self._choice():
            with self._option():
                self._pattern(r'.')
            with self._option():
                self._nl_()
            self._error('expecting one of: .')

    @graken()
    def _blockCommentChar_(self):
        with self._ifnot():
            self._blockCommentEnd_()
        self._blockCommentChar1_()

    @graken()
    def _eolCommentStart_(self):
        self._token('//')

    @graken()
    def _eolCommentChar_(self):
        with self._ifnot():
            self._nl_()
        self._pattern(r'.')

    @graken('token')
    def _blockCommentContent_(self):

        def block0():
            self._blockCommentChar_()
        self._closure(block0)

    @graken('token')
    def _eolCommentContent_(self):

        def block0():
            self._eolCommentChar_()
        self._closure(block0)

    @graken()
    def _blockComment_(self):
        self._blockCommentStart_()
        self.name_last_node('start')
        self._blockCommentContent_()
        self.name_last_node('content')
        self._blockCommentEnd_()
        self.name_last_node('end')
        self.ast._define(
            ['content', 'end', 'start'],
            []
        )

    @graken()
    def _eolComment_(self):
        self._eolCommentStart_()
        self.name_last_node('start')
        self._eolCommentContent_()
        self.name_last_node('content')
        with self._if():
            self._nl_()
        self.ast._define(
            ['content', 'start'],
            []
        )

    @graken()
    def _comment_(self):
        with self._choice():
            with self._option():
                self._blockComment_()
            with self._option():
                self._eolComment_()
            self._error('no available options')

    @graken()
    def _OpBlocker_(self):
        self._syntaxOperator_()
        with self._ifnot():
            self._Opchar_()

    @graken('token')
    def _op_(self):
        with self._ifnot():
            self._OpBlocker_()

        def block0():
            self._Opchar_()
        self._positive_closure(block0)

    @graken()
    def _IdWildcard_(self):
        self._Wildcard_()
        with self._ifnot():
            self._Opchar_()

    @graken()
    def _IdLetter_(self):
        with self._choice():
            with self._option():
                self._Letter_()
            with self._option():
                self._IdWildcard_()
            self._error('no available options')

    @graken()
    def _plainidNoToken_(self):
        self._IdLetter_()

        def block0():
            with self._choice():
                with self._option():
                    self._IdLetter_()
                with self._option():
                    self._Digit_()
                self._error('no available options')
        self._closure(block0)

    @graken('token')
    def _plainid_(self):
        self._IdLetter_()

        def block0():
            with self._choice():
                with self._option():
                    self._IdLetter_()
                with self._option():
                    self._Digit_()
                self._error('no available options')
        self._closure(block0)

    @graken()
    def _plainidName_(self):
        self._plainid_()
        self._check_name()

    @graken('token')
    def _idOpSuffix_(self):
        self._plainidName_()
        self._Wildcard_()

        def block0():
            self._Opchar_()
        self._positive_closure(block0)

    @graken()
    def _quotedId_(self):
        self._token('`')
        self._stringLiteralData_()
        self._token('`')

    @graken()
    def _id_(self):
        with self._choice():
            with self._option():
                self._idOpSuffix_()
            with self._option():
                self._plainidName_()
            with self._option():
                self._op_()
            with self._option():
                self._quotedId_()
            self._error('no available options')

    @graken()
    def _case_(self):
        self._token('case')

    @graken()
    def _match_(self):
        self._token('match')

    @graken()
    def _typekw_(self):
        self._token('type')

    @graken()
    def _literal_(self):
        with self._choice():
            with self._option():
                self._negativeIntegerLiteral_()
            with self._option():
                self._integerLiteral_()
            with self._option():
                self._negativeFloatingPointLiteral_()
            with self._option():
                self._floatingPointLiteral_()
            with self._option():
                self._booleanLiteral_()
            with self._option():
                self._characterLiteral_()
            with self._option():
                self._token('null')
            with self._option():
                self._stringLiteral_()
            with self._option():
                self._symbolLiteral_()
            self._error('expecting one of: null')

    @graken()
    def _qualId_(self):
        self._id_()

        def block0():
            self._token('.')
            self._id_()
        self._closure(block0)

    @graken()
    def _ids_(self):
        self._id_()

        def block0():
            self._token(',')
            self._id_()
        self._closure(block0)

    @graken()
    def _classQualifier_(self):
        self._lbrack_()
        self.name_last_node('lbrack')
        self._id_()
        self.name_last_node('id')
        self._rbrack_()
        self.name_last_node('rbrack')
        self.ast._define(
            ['id', 'lbrack', 'rbrack'],
            []
        )

    @graken()
    def _superAttrPre_(self):
        self._id_()
        self.name_last_node('id')
        self._token('.')
        self.name_last_node('dot')
        self.ast._define(
            ['dot', 'id'],
            []
        )

    @graken()
    def _superAttr_(self):
        with self._optional():
            self._superAttrPre_()
            self.name_last_node('pre')
        self._token('super')
        self.name_last_node('superkw')
        with self._optional():
            self._classQualifier_()
            self.name_last_node('qual')
        self._token('.')
        self.name_last_node('dot')
        self._id_()
        self.name_last_node('attr')
        self.ast._define(
            ['attr', 'dot', 'pre', 'qual', 'superkw'],
            []
        )

    @graken()
    def _stableId_(self):
        with self._choice():
            with self._option():
                self._thisRef_()
            with self._option():
                self._superAttr_()
            with self._option():
                self._id_()
            self._error('no available options')

    @graken()
    def _thisRef_(self):
        with self._optional():
            self._id_()
            self._token('.')
        self._token('this')

    @graken()
    def _selectrest_(self):
        self._token('.')
        self.name_last_node('dot')
        self._id_()
        self.name_last_node('id')
        self.ast._define(
            ['dot', 'id'],
            []
        )

    @graken()
    def _select_(self):
        self._stableId_()
        self.name_last_node('head')

        def block1():
            self._selectrest_()
            self.name_last_node('tail')
        self._positive_closure(block1)
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _path_(self):
        with self._choice():
            with self._option():
                self._select_()
            with self._option():
                self._id_()
            self._error('no available options')

    @graken()
    def _functionArgTypes_(self):
        with self._choice():
            with self._option():
                self._infixType_()
            with self._option():
                self._token('(')
                with self._optional():
                    self._paramType_()

                    def block0():
                        self._token(',')
                        self._paramType_()
                    self._closure(block0)
                self._token(')')
            self._error('expecting one of: (')

    @graken()
    def _existentialClause_(self):
        self._token('forSome')
        self._token('{')
        self._existentialDcl_()

        def block0():
            self._eol_()
            self._existentialDcl_()
        self._closure(block0)
        self._token('}')

    @graken()
    def _existentialDcl_(self):
        with self._choice():
            with self._option():
                self._typekw_()
                self._typeDcl_()
            with self._option():
                self._token('val')
                self._valDcl_()
            self._error('no available options')

    @graken()
    def _typeProjectionPre_(self):
        with self._choice():
            with self._option():
                self._appliedType_()
            with self._option():
                self._simpleType_()
            self._error('no available options')

    @graken()
    def _typeProjection_(self):
        self._typeProjectionPre_()
        self.name_last_node('pre')
        self._projectOp_()
        self.name_last_node('hash')
        self._id_()
        self.name_last_node('id')
        self.ast._define(
            ['hash', 'id', 'pre'],
            []
        )

    @graken()
    def _dependentType_(self):
        self._path_()
        self._token('.')
        self._typekw_()

    @graken()
    def _parenthesizedTypes_(self):
        self._lpar_()
        self.name_last_node('lpar')
        self._types_()
        self.name_last_node('types')
        self._rpar_()
        self.name_last_node('rpar')
        self.ast._define(
            ['lpar', 'rpar', 'types'],
            []
        )

    @graken()
    def _simpleType_(self):
        with self._choice():
            with self._option():
                self._dependentType_()
            with self._option():
                self._parenthesizedTypes_()
            with self._option():
                self._select_()
            with self._option():
                self._stableId_()
            self._error('no available options')

    @graken()
    def _typeArgs_(self):
        self._lbrack_()
        self.name_last_node('lbrack')
        self._types_()
        self.name_last_node('types')
        self._rbrack_()
        self.name_last_node('rbrack')
        self.ast._define(
            ['lbrack', 'rbrack', 'types'],
            []
        )

    @graken()
    def _refinementTemplate_(self):
        with self._optional():
            self._nl_()
        self._token('{')
        self._refineStat_()

        def block0():
            self._eol_()
            self._refineStat_()
        self._closure(block0)
        self._token('}')

    @graken()
    def _refineStat_(self):
        with self._choice():
            with self._option():
                self._dcl_()
            with self._option():
                self._typeDef_()
            self._error('no available options')

    @graken()
    def _appliedType_(self):
        self._simpleType_()
        self.name_last_node('simple')
        self._typeArgs_()
        self.name_last_node('args')
        self.ast._define(
            ['args', 'simple'],
            []
        )

    @graken()
    def _regularType_(self):
        with self._choice():
            with self._option():
                self._typeProjection_()
            with self._option():
                self._appliedType_()
            with self._option():
                self._simpleType_()
            self._error('no available options')

    @graken()
    def _annotType_(self):
        self._regularType_()
        self.name_last_node('tpe')

        def block2():
            self._annotation_()
        self._positive_closure(block2)
        self.name_last_node('anno')
        self.ast._define(
            ['anno', 'tpe'],
            []
        )

    @graken()
    def _annotOrRegularType_(self):
        with self._choice():
            with self._option():
                self._annotType_()
            with self._option():
                self._regularType_()
            self._error('no available options')

    @graken()
    def _refinementSubtype_(self):
        self._token('with')
        self.name_last_node('withkw')
        self._annotOrRegularType_()
        self.name_last_node('type')
        self.ast._define(
            ['type', 'withkw'],
            []
        )

    @graken()
    def _refinementsOnlySubtype_(self):

        def block0():
            self._refinementSubtype_()
        self._positive_closure(block0)

    @graken()
    def _refinementsWithTemplate_(self):

        def block0():
            self._refinementSubtype_()
            self.name_last_node('subtype')
        self._closure(block0)
        self._refinementTemplate_()
        self.name_last_node('templ')
        self.ast._define(
            ['subtype', 'templ'],
            []
        )

    @graken()
    def _refinements_(self):
        with self._choice():
            with self._option():
                self._refinementsOnlySubtype_()
            with self._option():
                self._refinementsWithTemplate_()
            self._error('no available options')

    @graken()
    def _refinedType_(self):
        self._annotOrRegularType_()
        self.name_last_node('compoundpre')
        self._refinements_()
        self.name_last_node('refine')
        self.ast._define(
            ['compoundpre', 'refine'],
            []
        )

    @graken()
    def _compoundType_(self):
        with self._choice():
            with self._option():
                self._refinedType_()
            with self._option():
                self._refinementTemplate_()
            self._error('no available options')

    @graken()
    def _infixTypePart_(self):
        with self._choice():
            with self._option():
                self._compoundType_()
            with self._option():
                self._simpleType_()
            self._error('no available options')

    @graken()
    def _infixTypeRest_(self):
        self._id_()
        self.name_last_node('infix')
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self._infixTypePart_()
        self.name_last_node('rhs')
        self.ast._define(
            ['infix', 'nl', 'rhs'],
            []
        )

    @graken()
    def _infixType_(self):
        self._infixTypePart_()
        self.name_last_node('head')

        def block2():
            self._infixTypeRest_()
        self._positive_closure(block2)
        self.name_last_node('tail')
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _functionType_(self):
        self._functionArgTypes_()
        self.name_last_node('args')
        self._arrow_()
        self.name_last_node('arrow')
        self._type_()
        self.name_last_node('tpe')
        self.ast._define(
            ['args', 'arrow', 'tpe'],
            []
        )

    @graken()
    def _infixExistentialType_(self):
        self._infixType_()
        self.name_last_node('tpe')
        self._existentialClause_()
        self.name_last_node('exi')
        self.ast._define(
            ['exi', 'tpe'],
            []
        )

    @graken()
    def _type_(self):
        with self._choice():
            with self._option():
                self._functionType_()
            with self._option():
                self._infixExistentialType_()
            with self._option():
                self._infixType_()
            with self._option():
                self._compoundType_()
            with self._option():
                self._annotType_()
            with self._option():
                self._regularType_()
            self._error('no available options')

    @graken()
    def _typesTail_(self):
        self._token(',')
        self.name_last_node('comma')
        self._type_()
        self.name_last_node('tpe')
        self.ast._define(
            ['comma', 'tpe'],
            []
        )

    @graken()
    def _types_(self):
        self._type_()
        self.name_last_node('head')

        def block2():
            self._typesTail_()
        self._closure(block2)
        self.name_last_node('tail')
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _ascription_(self):
        with self._choice():
            with self._option():
                self._token(':')
                self._infixType_()
            with self._option():
                self._token(':')
                self._annotation_()

                def block0():
                    self._annotation_()
                self._closure(block0)
            with self._option():
                self._token(':')
                self._wildcard_()
                self._token('*')
            self._error('no available options')

    @graken()
    def _patMat_(self):
        self._simpleOrCompoundExpr_()
        self.name_last_node('scrutinee')
        self._match_()
        self.name_last_node('match')
        self._lbrace_()
        self.name_last_node('lbrace')
        self._caseClauses_()
        self.name_last_node('cases')
        self._rbrace_()
        self.name_last_node('rbrace')
        self.ast._define(
            ['cases', 'lbrace', 'match', 'rbrace', 'scrutinee'],
            []
        )

    @graken()
    def _bindings_(self):
        self._token('(')
        with self._optional():
            self._binding_()

            def block0():
                self._token(',')
                self._binding_()
            self._closure(block0)
        self._token(')')

    @graken()
    def _binding_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._id_()
                with self._option():
                    self._wildcard_()
                self._error('no available options')
        with self._optional():
            self._token(':')
            self._type_()

    @graken()
    def _postfixExpr_(self):
        self._infixExpr_()
        self._id_()
        with self._if():
            self._eol_()

    @graken()
    def _infixOper_(self):
        with self._choice():
            with self._option():
                self._classInstantiation_()
            with self._option():
                self._applyExpr_()
            with self._option():
                self._attrExpr_()
            with self._option():
                self._prefixExpr_()
            with self._option():
                self._infixExpr_()
            with self._option():
                self._simpleExpr_()
            self._error('no available options')

    @graken()
    def _infixExpr_(self):
        self._infixOper_()
        self.name_last_node('left')
        self._id_()
        self.name_last_node('method')
        with self._optional():
            self._nl_()
            self.name_last_node('nl')
        self._expr_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'method', 'nl', 'right'],
            []
        )

    @graken()
    def _prefixExpr_(self):
        self._prefixOperator_()
        self.name_last_node('prefix')
        self._simpleExpr_()
        self.name_last_node('expr')
        self.ast._define(
            ['expr', 'prefix'],
            []
        )

    @graken()
    def _simpleAssignExpr_(self):
        self._id_()
        self.name_last_node('id')
        self._assign_()
        self.name_last_node('assign')
        self._expr_()
        self.name_last_node('rhs')
        self.ast._define(
            ['assign', 'id', 'rhs'],
            []
        )

    @graken()
    def _attrAssignExpr_(self):
        self._attrExpr_()
        self.name_last_node('lhs')
        self._assign_()
        self.name_last_node('assign')
        self._expr_()
        self.name_last_node('rhs')
        self.ast._define(
            ['assign', 'lhs', 'rhs'],
            []
        )

    @graken()
    def _applyAssignExprPre_(self):
        with self._choice():
            with self._option():
                self._parenthesizedExprsExpr_()
            with self._option():
                self._path_()
            with self._option():
                self._wildcard_()
            self._error('no available options')

    @graken()
    def _applyAssignExpr_(self):
        self._applyAssignExprPre_()
        self.name_last_node('expr')
        self._argumentsExpr_()
        self.name_last_node('app')
        self._assign_()
        self.name_last_node('assign')
        self._expr_()
        self.name_last_node('rhs')
        self.ast._define(
            ['app', 'assign', 'expr', 'rhs'],
            []
        )

    @graken()
    def _assignExpr_(self):
        with self._choice():
            with self._option():
                self._attrAssignExpr_()
            with self._option():
                self._simpleAssignExpr_()
            with self._option():
                self._applyAssignExpr_()
            self._error('no available options')

    @graken()
    def _argumentExpr_(self):
        with self._choice():
            with self._option():
                self._simpleAssignExpr_()
            with self._option():
                self._expr_()
            self._error('no available options')

    @graken()
    def _argumentExprsTail_(self):
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        self._token(',')
        self.name_last_node('comma')
        with self._optional():
            self._nl_()
            self.name_last_node('nl2')
        self._argumentExpr_()
        self.name_last_node('arg')
        self.ast._define(
            ['arg', 'comma', 'nl1', 'nl2'],
            []
        )

    @graken()
    def _argumentExprs_(self):
        self._argumentExpr_()
        self.name_last_node('head')

        def block2():
            self._argumentExprsTail_()
        self._closure(block2)
        self.name_last_node('tail')
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _arguments_(self):
        self._lpar_()
        self.name_last_node('lpar')
        with self._optional():
            self._argumentExprs_()
            self.name_last_node('args')
        self._rpar_()
        self.name_last_node('rpar')
        self.ast._define(
            ['args', 'lpar', 'rpar'],
            []
        )

    @graken()
    def _argumentSplat_(self):
        self._simpleOrCompoundExpr_()
        self.name_last_node('expr')
        self._token(':')
        self.name_last_node('colon')
        self._wildcard_()
        self.name_last_node('wildcard')
        self._token('*')
        self.name_last_node('aster')
        self.ast._define(
            ['aster', 'colon', 'expr', 'wildcard'],
            []
        )

    @graken()
    def _argumentsWithSplat_(self):
        self._lpar_()
        self.name_last_node('lpar')
        with self._optional():
            self._argumentExprs_()
            self.name_last_node('args')
            self._token(',')
            self.name_last_node('comma')
        self.name_last_node('regular')
        self._argumentSplat_()
        self.name_last_node('splat')
        self._rpar_()
        self.name_last_node('rpar')
        self.ast._define(
            ['args', 'comma', 'lpar', 'regular', 'rpar', 'splat'],
            []
        )

    @graken()
    def _argumentsBlock_(self):
        with self._optional():
            self._nl_()
        self._block_()

    @graken()
    def _argumentsExpr_(self):
        with self._choice():
            with self._option():
                self._argumentsWithSplat_()
            with self._option():
                self._arguments_()
            with self._option():
                self._argumentsBlock_()
            self._error('no available options')

    @graken()
    def _parenthesizedInfixExpr_(self):
        self._infixOper_()
        self.name_last_node('left')
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        self._id_()
        self.name_last_node('method')
        with self._optional():
            self._nl_()
            self.name_last_node('nl2')
        self._parenthesizedExpr_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'method', 'nl1', 'nl2', 'right'],
            []
        )

    @graken()
    def _parenthesizedExpr_(self):
        with self._choice():
            with self._option():
                self._parenthesizedInfixExpr_()
            with self._option():
                self._expr_()
            self._error('no available options')

    @graken()
    def _parenthesizedExprs_(self):
        self._parenthesizedExpr_()
        self.name_last_node('head')

        def block1():
            with self._optional():
                self._nl_()
                self.name_last_node('nl1')
            self._token(',')
            self.name_last_node('comma')
            with self._optional():
                self._nl_()
                self.name_last_node('nl2')
            self._parenthesizedExpr_()
        self._closure(block1)
        self.ast._define(
            ['comma', 'head', 'nl1', 'nl2'],
            []
        )

    @graken()
    def _parenthesizedExprsExpr_(self):
        self._lpar_()
        self.name_last_node('lpar')
        with self._optional():
            self._parenthesizedExprs_()
            self.name_last_node('exprs')
        self._rpar_()
        self.name_last_node('rpar')
        self.ast._define(
            ['exprs', 'lpar', 'rpar'],
            []
        )

    @graken()
    def _simpleExprPre_(self):
        with self._choice():
            with self._option():
                self._literal_()
            with self._option():
                self._attrExpr_()
            with self._option():
                self._simpleExprTypeArgs_()
            with self._option():
                self._simpleExpr_()
            with self._option():
                self._path_()
            with self._option():
                self._parenthesizedExprsExpr_()
            with self._option():
                self._wildcard_()
            self._error('no available options')

    @graken()
    def _attrExprPre_(self):
        with self._choice():
            with self._option():
                self._literal_()
            with self._option():
                self._stableId_()
            with self._option():
                self._parenthesizedExprsExpr_()
            with self._option():
                self._wildcard_()
            with self._option():
                self._classInstantiation_()
            self._error('no available options')

    @graken()
    def _attrExpr_(self):
        self._attrExprPre_()
        self.name_last_node('head')

        def block2():
            self._selectrest_()
        self._positive_closure(block2)
        self.name_last_node('tail')
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _attrExprTypeArgs_(self):
        self._attrExpr_()
        self.name_last_node('expr')
        self._typeArgs_()
        self.name_last_node('typeargs')
        self.ast._define(
            ['expr', 'typeargs'],
            []
        )

    @graken()
    def _applyExprPre_(self):
        with self._choice():
            with self._option():
                self._attrExprTypeArgs_()
            with self._option():
                self._attrExpr_()
            with self._option():
                self._simpleExprPre_()
            self._error('no available options')

    @graken()
    def _applyExpr1_(self):
        self._applyExprPre_()
        self.name_last_node('pre')

        def block2():
            self._argumentsExpr_()
        self._positive_closure(block2)
        self.name_last_node('args')
        self.ast._define(
            ['args', 'pre'],
            []
        )

    @graken()
    def _applyExprChain_(self):

        def block0():
            self._token('.')
            self.name_last_node('dot')
            self._id_()
            self.name_last_node('id')
        self._positive_closure(block0)

        def block4():
            self._argumentsExpr_()
        self._closure(block4)
        self.name_last_node('args')
        self.ast._define(
            ['args', 'dot', 'id'],
            []
        )

    @graken()
    def _applyExpr_(self):
        self._applyExpr1_()
        self.name_last_node('head')

        def block2():
            self._applyExprChain_()
        self._closure(block2)
        self.name_last_node('tail')
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _simpleExpr1_(self):
        with self._choice():
            with self._option():
                self._literal_()
            with self._option():
                self._parenthesizedExprsExpr_()
            with self._option():
                self._applyExpr_()
            with self._option():
                self._path_()
            with self._option():
                self._wildcard_()
            with self._option():
                self._this_()
            self._error('no available options')

    @graken()
    def _classInstantiation_(self):
        self._token('new')
        self.name_last_node('new')
        with self._group():
            with self._choice():
                with self._option():
                    self._classTemplate_()
                with self._option():
                    self._template_()
                self._error('no available options')
        self.name_last_node('templ')
        self.ast._define(
            ['new', 'templ'],
            []
        )

    @graken()
    def _etaPre_(self):
        with self._choice():
            with self._option():
                self._simpleExprTypeArgs_()
            with self._option():
                self._simpleExpr1_()
            self._error('no available options')

    @graken()
    def _etaExpansion_(self):
        self._etaPre_()
        self.name_last_node('expr')
        self._wildcard_()
        self.name_last_node('wildcard')
        self.ast._define(
            ['expr', 'wildcard'],
            []
        )

    @graken()
    def _simpleExprTypeArgs_(self):
        self._simpleExpr1_()
        self.name_last_node('expr')
        self._typeArgs_()
        self.name_last_node('typeargs')
        self.ast._define(
            ['expr', 'typeargs'],
            []
        )

    @graken()
    def _simpleExpr_(self):
        with self._choice():
            with self._option():
                self._simpleExprTypeArgs_()
            with self._option():
                self._simpleExpr1_()
            self._error('no available options')

    @graken()
    def _compoundExpr_(self):
        with self._choice():
            with self._option():
                self._block_()
            with self._option():
                self._infixExpr_()
            with self._option():
                self._prefixExpr_()
            with self._option():
                self._postfixExpr_()
            with self._option():
                self._assignExpr_()
            with self._option():
                self._etaExpansion_()
            with self._option():
                self._applyExpr_()
            with self._option():
                self._attrExprTypeArgs_()
            with self._option():
                self._attrExpr_()
            with self._option():
                self._classInstantiation_()
            self._error('no available options')

    @graken()
    def _simpleOrCompoundExpr_(self):
        with self._choice():
            with self._option():
                self._compoundExpr_()
            with self._option():
                self._simpleExpr_()
            self._error('no available options')

    @graken()
    def _ifExpr_(self):
        self._token('if')
        self._token('(')
        self._expr_()
        self._token(')')

        def block0():
            self._nl_()
        self._closure(block0)
        self._expr_()
        with self._optional():
            with self._optional():
                self._eol_()
            self._token('else')
            with self._optional():
                self._nl_()
            self._expr_()

    @graken()
    def _whileExpr_(self):
        self._token('while')
        self._token('(')
        self._expr_()
        self._token(')')

        def block0():
            self._nl_()
        self._closure(block0)
        self._expr_()

    @graken()
    def _catchExpr_(self):
        self._token('catch')
        with self._optional():
            self._nl_()
        self._caseBlock_()

    @graken()
    def _finallyExpr_(self):
        self._token('finally')
        self._expr_()

    @graken()
    def _tryExpr_(self):
        self._token('try')
        with self._optional():
            self._nl_()
        with self._group():
            with self._choice():
                with self._option():
                    self._statBlock_()
                with self._option():
                    self._expr_()
                self._error('no available options')
        with self._optional():
            with self._optional():
                self._nl_()
            self._catchExpr_()
        with self._optional():
            with self._optional():
                self._nl_()
            self._finallyExpr_()

    @graken()
    def _doExpr_(self):
        self._token('do')
        self._expr_()
        with self._optional():
            self._eol_()
        self._token('while')
        self._token('(')
        self._expr_()
        self._token(')')

    @graken()
    def _forExpr_(self):
        self._token('for')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('(')
                    self._enumerators_()
                    self._token(')')
                with self._option():
                    self._token('{')
                    self._enumerators_()
                    self._token('}')
                self._error('no available options')

        def block1():
            self._nl_()
        self._closure(block1)
        with self._optional():
            self._token('yield')
        self._expr_()

    @graken()
    def _throwExpr_(self):
        self._token('throw')
        self._expr_()

    @graken()
    def _returnExpr_(self):
        self._token('return')
        with self._optional():
            self._expr_()

    @graken()
    def _controlExpr_(self):
        with self._choice():
            with self._option():
                self._ifExpr_()
            with self._option():
                self._whileExpr_()
            with self._option():
                self._tryExpr_()
            with self._option():
                self._doExpr_()
            with self._option():
                self._forExpr_()
            with self._option():
                self._throwExpr_()
            with self._option():
                self._returnExpr_()
            self._error('no available options')

    @graken()
    def _anonFuncExprParamImplicit_(self):
        self._token('implicit')
        self.name_last_node('implicitkw')
        self._id_()
        self.name_last_node('id')
        self.ast._define(
            ['id', 'implicitkw'],
            []
        )

    @graken()
    def _anonFuncExprParams_(self):
        with self._choice():
            with self._option():
                self._bindings_()
            with self._option():
                self._anonFuncExprParamImplicit_()
            with self._option():
                self._id_()
            with self._option():
                self._wildcard_()
            self._error('no available options')

    @graken()
    def _anonFuncRhs_(self):
        with self._choice():
            with self._option():
                self._blockBody_()
            with self._option():
                self._expr_()
            self._error('no available options')

    @graken()
    def _anonFuncExpr_(self):
        self._anonFuncExprParams_()
        self.name_last_node('params')
        self._arrow_()
        self.name_last_node('arrow')
        self._anonFuncRhs_()
        self.name_last_node('rhs')
        self.ast._define(
            ['arrow', 'params', 'rhs'],
            []
        )

    @graken()
    def _ascribedSimpleOrCompoundExpr_(self):
        self._simpleOrCompoundExpr_()
        self._ascription_()

    @graken()
    def _expr_(self):
        with self._choice():
            with self._option():
                self._anonFuncExpr_()
            with self._option():
                self._controlExpr_()
            with self._option():
                self._patMat_()
            with self._option():
                self._simpleOrCompoundExpr_()
            with self._option():
                self._ascribedSimpleOrCompoundExpr_()
            self._error('no available options')

    @graken()
    def _exprsTail_(self):
        self._token(',')
        self.name_last_node('comma')
        self._expr_()
        self.name_last_node('expr')
        self.ast._define(
            ['comma', 'expr'],
            []
        )

    @graken()
    def _exprs_(self):
        self._expr_()
        self.name_last_node('head')

        def block2():
            self._exprsTail_()
        self._closure(block2)
        self.name_last_node('tail')
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _enumerators_(self):
        self._generator_()

        def block0():
            self._eol_()
            self._generator_()
        self._closure(block0)

    @graken()
    def _generator_(self):
        self._pattern1_()
        self._token('<-')
        self._expr_()

        def block0():
            with self._choice():
                with self._option():
                    with self._optional():
                        self._eol_()
                    self._guard_()
                with self._option():
                    self._eol_()
                    self._pattern1_()
                    self._assign_()
                    self._expr_()
                self._error('no available options')
        self._closure(block0)

    @graken()
    def _patternApply_(self):
        self._stableId_()
        self.name_last_node('id')
        self._lpar_()
        self.name_last_node('lpar')
        with self._optional():
            self._patterns_()
            self.name_last_node('pats')
        self._rpar_()
        self.name_last_node('rpar')
        self.ast._define(
            ['id', 'lpar', 'pats', 'rpar'],
            []
        )

    @graken()
    def _patternApplyVariadic_(self):
        self._stableId_()
        self.name_last_node('id')
        self._lpar_()
        self.name_last_node('lpar')
        with self._optional():
            self._patterns_()
            self.name_last_node('pats')
            self._token(',')
            self.name_last_node('comma')
        with self._optional():
            self._plainidName_()
            self.name_last_node('alias')
            self._token('@')
            self.name_last_node('at')
        self._token('_*')
        self.name_last_node('splat')
        self._rpar_()
        self.name_last_node('rpar')
        self.ast._define(
            ['alias', 'at', 'comma', 'id', 'lpar', 'pats', 'rpar', 'splat'],
            []
        )

    @graken()
    def _parenthesizedPatterns_(self):
        self._lpar_()
        self.name_last_node('lpar')
        with self._optional():
            self._patterns_()
            self.name_last_node('pats')
        self._rpar_()
        self.name_last_node('rpar')
        self.ast._define(
            ['lpar', 'pats', 'rpar'],
            []
        )

    @graken()
    def _patternSimple_(self):
        with self._choice():
            with self._option():
                self._wildcard_()
            with self._option():
                self._literal_()
            with self._option():
                self._select_()
            with self._option():
                self._patternApply_()
            with self._option():
                self._patternApplyVariadic_()
            with self._option():
                self._parenthesizedPatterns_()
            with self._option():
                self._plainidName_()
            with self._option():
                self._stableId_()
            self._error('no available options')

    @graken()
    def _patternInfix_(self):
        self._patternSimple_()

        def block0():
            self._id_()
            with self._optional():
                self._nl_()
            self._patternSimple_()
        self._positive_closure(block0)

    @graken()
    def _patternInfixOrSimple_(self):
        with self._choice():
            with self._option():
                self._patternInfix_()
            with self._option():
                self._patternSimple_()
            self._error('no available options')

    @graken()
    def _patternAliasedName_(self):
        self._plainidName_()
        self._token('@')
        self._patternInfixOrSimple_()

    @graken()
    def _patternTyped_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._plainidName_()
                with self._option():
                    self._wildcard_()
                self._error('no available options')
        self._token(':')
        with self._group():
            with self._choice():
                with self._option():
                    self._infixExistentialType_()
                with self._option():
                    self._functionType_()
                self._error('no available options')

    @graken()
    def _pattern1_(self):
        with self._choice():
            with self._option():
                self._patternTyped_()
            with self._option():
                self._patternAliasedName_()
            with self._option():
                self._patternInfixOrSimple_()
            self._error('no available options')

    @graken()
    def _patternTail_(self):
        self._token('|')
        self.name_last_node('pipe')
        self._pattern1_()
        self.name_last_node('pat')
        self.ast._define(
            ['pat', 'pipe'],
            []
        )

    @graken()
    def _pattern_(self):
        self._pattern1_()
        self.name_last_node('head')

        def block1():
            self._patternTail_()
            self.name_last_node('tail')
        self._closure(block1)
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _patternsTail_(self):
        self._token(',')
        self.name_last_node('comma')
        self._patterns_()
        self.name_last_node('pats')
        self.ast._define(
            ['comma', 'pats'],
            []
        )

    @graken()
    def _patternsSeq_(self):
        self._pattern_()
        self.name_last_node('head')
        with self._optional():
            self._patternsTail_()
            self.name_last_node('tail')
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _patternVariadic_(self):
        self._token('_*')

    @graken()
    def _patterns_(self):
        with self._choice():
            with self._option():
                self._patternsSeq_()
            with self._option():
                self._patternVariadic_()
            self._error('no available options')

    @graken()
    def _guardExpr_(self):
        self._simpleOrCompoundExpr_()

    @graken()
    def _guard_(self):
        self._token('if')
        self.name_last_node('ifkw')
        self._guardExpr_()
        self.name_last_node('expr')
        self.ast._define(
            ['expr', 'ifkw'],
            []
        )

    @graken()
    def _caseBlockBody_(self):
        self._blockBody_()
        with self._if():
            with self._group():
                self._nl_()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('case')
                        with self._option():
                            self._token('}')
                        self._error('expecting one of: case }')

    @graken()
    def _caseClauseRhs_(self):
        with self._choice():
            with self._option():
                self._block_()
            with self._option():
                self._caseBlockBody_()
            with self._option():
                self._expr_()
            self._error('no available options')

    @graken()
    def _caseClause_(self):
        self._case_()
        self.name_last_node('casekw')
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        self._pattern_()
        self.name_last_node('pat')
        with self._optional():
            with self._optional():
                self._nl_()
                self.name_last_node('nl2')
            self._guard_()
            self.name_last_node('guard')
        with self._optional():
            self._nl_()
            self.name_last_node('nl3')
        self._arrow_()
        self.name_last_node('arr')
        with self._optional():
            self._caseClauseRhs_()
            self.name_last_node('rhs')
        self.ast._define(
            ['arr', 'casekw', 'guard', 'nl1', 'nl2', 'nl3', 'pat', 'rhs'],
            []
        )

    @graken()
    def _caseClausesRest_(self):
        with self._optional():
            self._eol_()
            self.name_last_node('eol')
        self._caseClause_()
        self.name_last_node('case')
        self.ast._define(
            ['case', 'eol'],
            []
        )

    @graken()
    def _caseClauses_(self):
        self._caseClause_()
        self.name_last_node('head')

        def block2():
            self._caseClausesRest_()
        self._closure(block2)
        self.name_last_node('tail')
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _typeParam_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._id_()
                with self._option():
                    self._wildcard_()
                self._error('no available options')
        self.name_last_node('id')
        with self._optional():
            self._typeParamClause_()
            self.name_last_node('sub')
        with self._optional():
            self._tpLowerBound_()
            self.name_last_node('b')
        with self._optional():
            self._tpUpperBound_()
            self.name_last_node('ub')

        def block6():
            self._tpViewBound_()
        self._closure(block6)
        self.name_last_node('vbs')

        def block8():
            self._tpContextBound_()
        self._closure(block8)
        self.name_last_node('cbs')
        self.ast._define(
            ['b', 'cbs', 'id', 'sub', 'ub', 'vbs'],
            []
        )

    @graken()
    def _typeParamClause_(self):
        self._lbrack_()
        self.name_last_node('lbrack')
        self._variantTypeParam_()

        def block1():
            self._token(',')
            self._variantTypeParam_()
        self._closure(block1)
        self._rbrack_()
        self.name_last_node('rbrack')
        self.ast._define(
            ['lbrack', 'rbrack'],
            []
        )

    @graken()
    def _typeParams_(self):
        self._typeParam_()

        def block0():
            self._token(',')
            self._typeParam_()
        self._closure(block0)

    @graken()
    def _funTypeParamClause_(self):
        self._lbrack_()
        self.name_last_node('lbrack')
        self._typeParams_()
        self.name_last_node('params')
        self._rbrack_()
        self.name_last_node('rbrack')
        self.ast._define(
            ['lbrack', 'params', 'rbrack'],
            []
        )

    @graken()
    def _variantTypeParam_(self):

        def block0():
            self._annotation_()
        self._closure(block0)
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('-')
                self._error('expecting one of: + -')
        self._typeParam_()

    @graken()
    def _tpLowerBound_(self):
        self._token('>:')
        self._type_()

    @graken()
    def _tpUpperBound_(self):
        self._token('<:')
        self._type_()

    @graken()
    def _tpViewBound_(self):
        self._token('<%')
        self._type_()

    @graken()
    def _tpContextBound_(self):
        self._token(':')
        self._type_()

    @graken()
    def _paramTypeLazy_(self):
        self._arrow_()
        self._type_()

    @graken()
    def _paramTypeVariant_(self):
        self._type_()
        self._token('*')

    @graken()
    def _paramType_(self):
        with self._choice():
            with self._option():
                self._type_()
            with self._option():
                self._paramTypeLazy_()
            with self._option():
                self._paramTypeVariant_()
            self._error('no available options')

    @graken()
    def _param_(self):

        def block0():
            self._annotation_()
            self.name_last_node('anno')
        self._closure(block0)
        self._id_()
        self.name_last_node('id')
        self._token(':')
        self.name_last_node('colon')
        self._paramType_()
        self.name_last_node('tpe')
        with self._optional():
            self._assign_()
            self.name_last_node('assign')
            self._expr_()
            self.name_last_node('rhs')
        self.ast._define(
            ['anno', 'assign', 'colon', 'id', 'rhs', 'tpe'],
            []
        )

    @graken()
    def _variadicParam_(self):

        def block0():
            self._annotation_()
            self.name_last_node('anno')
        self._closure(block0)
        self._id_()
        self.name_last_node('id')
        self._token(':')
        self.name_last_node('colon')
        self._paramType_()
        self.name_last_node('tpe')
        self._token('*')
        self.name_last_node('aster')
        self.ast._define(
            ['anno', 'aster', 'colon', 'id', 'tpe'],
            []
        )

    @graken()
    def _params_(self):

        def block1():
            self._param_()
            self._token(',')
        self._closure(block1)
        self.name_last_node('init')
        with self._group():
            with self._choice():
                with self._option():
                    self._variadicParam_()
                with self._option():
                    self._param_()
                self._error('no available options')
        self.name_last_node('last')
        self.ast._define(
            ['init', 'last'],
            []
        )

    @graken()
    def _paramClause_(self):
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        self._lpar_()
        self.name_last_node('lpar')
        with self._ifnot():
            self._token('implicit')
        with self._optional():
            self._params_()
            self.name_last_node('params')
        self._rpar_()
        self.name_last_node('rpar')
        self.ast._define(
            ['lpar', 'nl1', 'params', 'rpar'],
            []
        )

    @graken()
    def _implicitParamClause_(self):
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        self._lpar_()
        self.name_last_node('lpar')
        self._token('implicit')
        self.name_last_node('implicitkw')
        with self._optional():
            self._nl_()
            self.name_last_node('nl2')
        self._params_()
        self.name_last_node('params')
        self._rpar_()
        self.name_last_node('rpar')
        self.ast._define(
            ['implicitkw', 'lpar', 'nl1', 'nl2', 'params', 'rpar'],
            []
        )

    @graken()
    def _paramClauses_(self):

        def block1():
            self._paramClause_()
        self._closure(block1)
        self.name_last_node('explicit')
        with self._optional():
            self._implicitParamClause_()
            self.name_last_node('implicit')
        self.ast._define(
            ['explicit', 'implicit'],
            []
        )

    @graken()
    def _classParam_(self):

        def block0():
            self._annotation_()
        self._closure(block0)

        def block1():
            self._modifier_()
        self._closure(block1)
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('val')
                    with self._option():
                        self._token('var')
                    self._error('expecting one of: val var')
        self._id_()
        self._token(':')
        self._paramType_()
        with self._optional():
            self._assign_()
            self._expr_()

    @graken()
    def _classParams_(self):
        self._classParam_()

        def block0():
            self._token(',')
            self._classParam_()
        self._closure(block0)

    @graken()
    def _classParamClause_(self):
        with self._optional():
            self._nl_()
        self._token('(')
        with self._optional():
            self._classParams_()
        self._token(')')

    @graken()
    def _classParamClauses_(self):

        def block0():
            self._classParamClause_()
        self._closure(block0)
        with self._optional():
            with self._optional():
                self._nl_()
            self._token('(')
            self._token('implicit')
            self._classParams_()
            self._token(')')

    @graken()
    def _modifier_(self):
        with self._choice():
            with self._option():
                self._localModifier_()
            with self._option():
                self._accessModifier_()
            with self._option():
                self._token('override')
            self._error('expecting one of: override')

    @graken()
    def _localModifier_(self):
        with self._choice():
            with self._option():
                self._token('abstract')
            with self._option():
                self._token('final')
            with self._option():
                self._token('sealed')
            with self._option():
                self._token('implicit')
            with self._option():
                self._token('lazy')
            self._error('expecting one of: abstract final implicit lazy sealed')

    @graken()
    def _accessModifier_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('private')
                with self._option():
                    self._token('protected')
                self._error('expecting one of: private protected')
        with self._optional():
            self._accessQualifier_()

    @graken()
    def _accessQualifier_(self):
        self._lbrack_()
        self.name_last_node('lbrack')
        with self._group():
            with self._choice():
                with self._option():
                    self._id_()
                with self._option():
                    self._token('this')
                self._error('expecting one of: this')
        self._rbrack_()
        self.name_last_node('rbrack')
        self.ast._define(
            ['lbrack', 'rbrack'],
            []
        )

    @graken()
    def _annotation_(self):
        self._token('@')
        self._regularType_()

        def block0():
            self._argumentsExpr_()
        self._closure(block0)

    @graken()
    def _constrAnnotation_(self):
        self._token('@')
        self._regularType_()
        self._argumentsExpr_()

    @graken()
    def _templateStatDef_(self):

        def block0():
            self._annotation_()
            self.name_last_node('anno')
            with self._optional():
                self._nl_()
                self.name_last_node('nl')
        self._closure(block0)

        def block3():
            self._modifier_()
            self.name_last_node('mod')
        self._closure(block3)
        self._def_()
        self.name_last_node('def_')
        self.ast._define(
            ['anno', 'def_', 'mod', 'nl'],
            []
        )

    @graken()
    def _templateStatDcl_(self):

        def block0():
            self._annotation_()
            self.name_last_node('anno')
            with self._optional():
                self._nl_()
                self.name_last_node('nl')
        self._closure(block0)

        def block3():
            self._modifier_()
            self.name_last_node('mod')
        self._closure(block3)
        self._dcl_()
        self.name_last_node('dcl')
        self.ast._define(
            ['anno', 'dcl', 'mod', 'nl'],
            []
        )

    @graken()
    def _templateStat1_(self):
        with self._choice():
            with self._option():
                self._comment_()
            with self._option():
                self._import_()
            with self._option():
                self._templateStatDef_()
            with self._option():
                self._templateStatDcl_()
            with self._option():
                self._expr_()
            self._error('no available options')

    @graken()
    def _templateStat_(self):
        with self._choice():
            with self._option():
                self._templateStat1_()
                self._eolComment_()
            with self._option():
                self._templateStat1_()
            self._error('no available options')

    @graken()
    def _templateStatsTail_(self):
        self._eol_()
        self.name_last_node('eol')
        self._templateStat_()
        self.name_last_node('stat')
        self.ast._define(
            ['eol', 'stat'],
            []
        )

    @graken()
    def _templateStats_(self):
        self._templateStat_()
        self.name_last_node('head')

        def block2():
            self._templateStatsTail_()
        self._closure(block2)
        self.name_last_node('tail')
        self.ast._define(
            ['head', 'tail'],
            []
        )

    @graken()
    def _templateBody_(self):
        with self._optional():
            self._selfType_()
            self.name_last_node('selftype')
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        self._templateStats_()
        self.name_last_node('stats')
        self.ast._define(
            ['nl1', 'selftype', 'stats'],
            []
        )

    @graken()
    def _template_(self):
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        self._lbrace_()
        self.name_last_node('lbrace')
        with self._optional():
            self._templateBody_()
            self.name_last_node('stats')
        self._rbrace_()
        self.name_last_node('rbrace')
        self.ast._define(
            ['lbrace', 'nl1', 'rbrace', 'stats'],
            []
        )

    @graken()
    def _selfType_(self):
        with self._choice():
            with self._option():
                self._id_()
                with self._optional():
                    self._token(':')
                    self._type_()
                self._arrow_()
            with self._option():
                self._token('this')
                self._token(':')
                self._type_()
                self._arrow_()
            self._error('no available options')

    @graken()
    def _import_(self):
        self._token('import')
        self._importExpr_()

        def block0():
            self._token(',')
            self._importExpr_()
        self._closure(block0)

    @graken()
    def _importExprPre_(self):
        self._id_()
        self._token('.')

    @graken()
    def _importExpr_(self):

        def block0():
            self._importExprPre_()
        self._positive_closure(block0)
        with self._group():
            with self._choice():
                with self._option():
                    self._id_()
                with self._option():
                    self._wildcard_()
                with self._option():
                    self._importSelectors_()
                self._error('no available options')

    @graken()
    def _importSelectors_(self):
        self._token('{')

        def block0():
            self._importSelector_()
            self._token(',')
        self._closure(block0)
        with self._group():
            with self._choice():
                with self._option():
                    self._importSelector_()
                with self._option():
                    self._wildcard_()
                self._error('no available options')
        self._token('}')

    @graken()
    def _importSelector_(self):
        self._id_()
        with self._optional():
            with self._choice():
                with self._option():
                    self._arrow_()
                    self._id_()
                with self._option():
                    self._arrow_()
                    self._wildcard_()
                self._error('no available options')

    @graken()
    def _dcl_(self):
        with self._choice():
            with self._option():
                self._token('val')
                self.name_last_node('key')
                self._valDcl_()
                self.name_last_node('dcl')
            with self._option():
                self._token('var')
                self.name_last_node('key')
                self._valDcl_()
                self.name_last_node('dcl')
            with self._option():
                self._token('def')
                self.name_last_node('key')
                self._funDcl_()
                self.name_last_node('dcl')
            with self._option():
                self._typekw_()
                self.name_last_node('key')

                def block7():
                    self._nl_()
                self._closure(block7)
                self._typeDcl_()
                self.name_last_node('dcl')
            self._error('no available options')
        self.ast._define(
            ['dcl', 'key'],
            []
        )

    @graken()
    def _valDcl_(self):
        self._ids_()
        self._token(':')
        self._type_()

    @graken()
    def _funDcl_(self):
        self._funSig_()
        self.name_last_node('sig')
        with self._optional():
            self._token(':')
            self._type_()
            self.name_last_node('type')
        self.ast._define(
            ['sig', 'type'],
            []
        )

    @graken()
    def _typeDcl_(self):
        self._id_()
        with self._optional():
            self._typeParamClause_()
        with self._optional():
            self._token('>:')
            self._type_()
        with self._optional():
            self._token('<:')
            self._type_()

    @graken()
    def _patDefPats_(self):
        self._patternInfixOrSimple_()
        self.name_last_node('head')

        def block2():
            self._token(',')
            self.name_last_node('comma')
            self._patternInfixOrSimple_()
            self.name_last_node('pat')
        self._closure(block2)
        self.name_last_node('tail')
        self.ast._define(
            ['comma', 'head', 'pat', 'tail'],
            []
        )

    @graken()
    def _varDefSimple_(self):
        self._id_()
        self.name_last_node('id')
        with self._optional():
            self._token(':')
            self.name_last_node('colon')
            self._type_()
            self.name_last_node('tpe')
        self._assign_()
        self.name_last_node('assign')
        self._expr_()
        self.name_last_node('rhs')
        self.ast._define(
            ['assign', 'colon', 'id', 'rhs', 'tpe'],
            []
        )

    @graken()
    def _patDef_(self):
        self._patDefPats_()
        self.name_last_node('pats')
        with self._optional():
            self._token(':')
            self.name_last_node('colon')
            self._type_()
            self.name_last_node('tpe')
        self._assign_()
        self.name_last_node('assign')
        self._expr_()
        self.name_last_node('rhs')
        self.ast._define(
            ['assign', 'colon', 'pats', 'rhs', 'tpe'],
            []
        )

    @graken()
    def _uninitializedVarDef_(self):
        self._ids_()
        self._token(':')
        self._type_()
        self._assign_()
        self.name_last_node('assign')
        self._wildcard_()
        self.ast._define(
            ['assign'],
            []
        )

    @graken()
    def _varDef_(self):
        with self._choice():
            with self._option():
                self._varDefSimple_()
            with self._option():
                self._patDef_()
            with self._option():
                self._uninitializedVarDef_()
            self._error('no available options')

    @graken()
    def _funSig_(self):
        self._id_()
        self.name_last_node('id')
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        with self._optional():
            self._funTypeParamClause_()
            self.name_last_node('tparams')
        with self._optional():
            self._nl_()
            self.name_last_node('nl2')
        with self._optional():
            self._paramClauses_()
            self.name_last_node('paramss')
        self.ast._define(
            ['id', 'nl1', 'nl2', 'paramss', 'tparams'],
            []
        )

    @graken()
    def _funDefFull_(self):
        self._funSig_()
        self.name_last_node('sig')
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        with self._optional():
            self._token(':')
            self.name_last_node('colon')
            with self._optional():
                self._nl_()
                self.name_last_node('nl2')
            self._type_()
            self.name_last_node('type')
        with self._optional():
            self._nl_()
            self.name_last_node('nl3')
        self._assign_()
        self.name_last_node('assign')
        with self._optional():
            self._nl_()
            self.name_last_node('nl4')
        self._expr_()
        self.name_last_node('rhs')
        self.ast._define(
            ['assign', 'colon', 'nl1', 'nl2', 'nl3', 'nl4', 'rhs', 'sig', 'type'],
            []
        )

    @graken()
    def _funDefUnit_(self):
        self._funSig_()
        self.name_last_node('sig')
        with self._optional():
            self._nl_()
            self.name_last_node('nl1')
        self._lbrace_()
        self.name_last_node('lbrace')
        with self._optional():
            self._blockBody_()
            self.name_last_node('rhs')
        self._rbrace_()
        self.name_last_node('rbrace')
        self.ast._define(
            ['lbrace', 'nl1', 'rbrace', 'rhs', 'sig'],
            []
        )

    @graken()
    def _funDefCtor_(self):
        self._token('this')
        self._paramClauses_()
        with self._group():
            with self._choice():
                with self._option():
                    self._assign_()
                    self.name_last_node('assign')
                    self._constrExpr_()
                with self._option():
                    with self._optional():
                        self._nl_()
                    self._constrBlock_()
                self._error('no available options')
        self.ast._define(
            ['assign'],
            []
        )

    @graken()
    def _funDef1_(self):
        with self._choice():
            with self._option():
                self._funDefFull_()
            with self._option():
                self._funDefUnit_()
            with self._option():
                self._funDefCtor_()
            self._error('no available options')

    @graken()
    def _funDef_(self):
        self._token('def')
        self.name_last_node('defkw')
        self._funDef1_()
        self.name_last_node('def_')
        self.ast._define(
            ['def_', 'defkw'],
            []
        )

    @graken()
    def _typeDef_(self):
        self._typekw_()
        self.name_last_node('typekw')

        def block2():
            self._nl_()
        self._closure(block2)
        self.name_last_node('nls')
        self._id_()
        self.name_last_node('id')
        with self._optional():
            self._typeParamClause_()
            self.name_last_node('params')
        self._assign_()
        self.name_last_node('assign')
        self._type_()
        self.name_last_node('rhs')
        self.ast._define(
            ['assign', 'id', 'nls', 'params', 'rhs', 'typekw'],
            []
        )

    @graken()
    def _valVarDef_(self):
        self._token('val')
        self.name_last_node('valkw')
        self._patDef_()
        self.name_last_node('def_')
        self.ast._define(
            ['def_', 'valkw'],
            []
        )

    @graken()
    def _varVarDef_(self):
        self._token('var')
        self.name_last_node('varkw')
        self._varDef_()
        self.name_last_node('def_')
        self.ast._define(
            ['def_', 'varkw'],
            []
        )

    @graken()
    def _patVarDef_(self):
        with self._choice():
            with self._option():
                self._valVarDef_()
            with self._option():
                self._varVarDef_()
            self._error('no available options')

    @graken()
    def _def_(self):
        with self._choice():
            with self._option():
                self._patVarDef_()
            with self._option():
                self._funDef_()
            with self._option():
                self._typeDef_()
            with self._option():
                self._tmplDef_()
            self._error('no available options')

    @graken()
    def _resultAnonFunc_(self):
        self._anonFuncExprParams_()
        self.name_last_node('params')
        self._token(':')
        self.name_last_node('colon')
        self._compoundType_()
        self.name_last_node('type')
        self._arrow_()
        self.name_last_node('arrow')
        self._blockBody_()
        self.name_last_node('rhs')
        self.ast._define(
            ['arrow', 'colon', 'params', 'rhs', 'type'],
            []
        )

    @graken()
    def _resultExpr_(self):
        with self._choice():
            with self._option():
                self._expr_()
            with self._option():
                self._arrow_()
                self._blockBody_()
            self._error('no available options')

    @graken()
    def _blockStatMod_(self):
        with self._choice():
            with self._option():
                self._token('implicit')
            with self._option():
                self._token('lazy')
            self._error('expecting one of: implicit lazy')

    @graken()
    def _blockStatDef_(self):

        def block1():
            self._annotation_()
        self._closure(block1)
        self.name_last_node('anno')
        with self._optional():
            self._blockStatMod_()
            self.name_last_node('mod')
        self._def_()
        self.name_last_node('def_')
        self.ast._define(
            ['anno', 'def_', 'mod'],
            []
        )

    @graken()
    def _blockStatTemplDef_(self):

        def block1():
            self._annotation_()
        self._closure(block1)
        self.name_last_node('anno')

        def block3():
            self._localModifier_()
        self._closure(block3)
        self.name_last_node('mod')
        self._tmplDef_()
        self.name_last_node('def_')
        self.ast._define(
            ['anno', 'def_', 'mod'],
            []
        )

    @graken()
    def _blockStat1_(self):
        with self._choice():
            with self._option():
                self._comment_()
            with self._option():
                self._import_()
            with self._option():
                self._blockStatDef_()
            with self._option():
                self._blockStatTemplDef_()
            with self._option():
                self._expr_()
            self._error('no available options')

    @graken()
    def _blockStat_(self):
        with self._choice():
            with self._option():
                self._blockStat1_()
                self._eolComment_()
            with self._option():
                self._blockStat1_()
            self._error('no available options')

    @graken()
    def _blockRest_(self):
        self._eol_()
        self.name_last_node('eol')
        self._blockStat_()
        self.name_last_node('stat')
        self.ast._define(
            ['eol', 'stat'],
            []
        )

    @graken()
    def _blockBody_(self):
        self._blockStat_()
        self.name_last_node('head')

        def block2():
            self._blockRest_()
        self._closure(block2)
        self.name_last_node('tail')
        with self._optional():
            self._eol_()
            self._resultExpr_()
            self.name_last_node('result')
        self.ast._define(
            ['head', 'result', 'tail'],
            []
        )

    @graken()
    def _blockExprContent_(self):
        with self._choice():
            with self._option():
                self._caseClauses_()
            with self._option():
                self._blockBody_()
            self._error('no available options')

    @graken()
    def _block_(self):
        self._lbrace_()
        self.name_last_node('lbrace')
        self._blockExprContent_()
        self.name_last_node('body')
        self._rbrace_()
        self.name_last_node('rbrace')
        self.ast._define(
            ['body', 'lbrace', 'rbrace'],
            []
        )

    @graken()
    def _statBlock_(self):
        self._lbrace_()
        self.name_last_node('lbrace')
        self._blockBody_()
        self.name_last_node('body')
        self._rbrace_()
        self.name_last_node('rbrace')
        self.ast._define(
            ['body', 'lbrace', 'rbrace'],
            []
        )

    @graken()
    def _caseBlock_(self):
        self._lbrace_()
        self.name_last_node('lbrace')
        self._caseClauses_()
        self.name_last_node('body')
        self._rbrace_()
        self.name_last_node('rbrace')
        self.ast._define(
            ['body', 'lbrace', 'rbrace'],
            []
        )

    @graken()
    def _classDef_(self):
        self._id_()
        with self._optional():
            self._typeParamClause_()

        def block0():
            self._constrAnnotation_()
        self._closure(block0)
        with self._optional():
            self._accessModifier_()
        self._classParamClauses_()
        self._classTemplateOpt_()

    @graken()
    def _traitDef_(self):
        with self._optional():
            self._nl_()
        self._id_()
        with self._optional():
            self._nl_()
        with self._optional():
            self._typeParamClause_()
        with self._optional():
            self._nl_()
        self._traitTemplateOpt_()

    @graken()
    def _objectDef_(self):
        self._id_()
        self._classTemplateOpt_()

    @graken()
    def _classTemplateOpt_(self):
        with self._choice():
            with self._option():
                self._token('extends')
                self._classTemplate_()
            with self._option():
                with self._optional():
                    with self._optional():
                        self._token('extends')
                    self._template_()
            self._error('no available options')

    @graken()
    def _traitTemplateOpt_(self):
        with self._choice():
            with self._option():
                self._token('extends')
                self._traitTemplate_()
            with self._option():
                with self._optional():
                    with self._optional():
                        self._token('extends')
                    self._template_()
            self._error('no available options')

    @graken()
    def _classTemplate_(self):
        with self._optional():
            self._earlyDefs_()
        self._classParents_()
        with self._optional():
            self._template_()

    @graken()
    def _traitTemplate_(self):
        with self._optional():
            self._earlyDefs_()
        self._traitParents_()
        with self._optional():
            self._template_()

    @graken()
    def _classParents_(self):
        self._constr_()

        def block0():
            self._token('with')
            self._annotOrRegularType_()
        self._closure(block0)

    @graken()
    def _traitParents_(self):
        self._annotOrRegularType_()

        def block0():
            self._token('with')
            self._annotOrRegularType_()
        self._closure(block0)

    @graken()
    def _constr_(self):
        self._annotOrRegularType_()

        def block0():
            self._argumentsExpr_()
        self._closure(block0)

    @graken()
    def _earlyDefs_(self):
        self._lbrace_()
        self.name_last_node('lbrace')
        with self._optional():
            self._earlyDef_()

            def block1():
                self._eol_()
                self._earlyDef_()
            self._closure(block1)
        self._rbrace_()
        self.name_last_node('rbrace')
        with self._optional():
            self._nl_()
        self._token('with')
        self.ast._define(
            ['lbrace', 'rbrace'],
            []
        )

    @graken()
    def _earlyDef_(self):

        def block0():
            self._annotation_()
            with self._optional():
                self._nl_()
        self._closure(block0)

        def block1():
            self._modifier_()
        self._closure(block1)
        self._patVarDef_()

    @graken()
    def _class_(self):
        with self._optional():
            self._case_()
        self._token('class')
        self._classDef_()

    @graken()
    def _module_(self):
        with self._optional():
            self._case_()
        self._token('object')
        self._objectDef_()

    @graken()
    def _trait_(self):
        self._token('trait')
        self._traitDef_()

    @graken()
    def _tmplDef_(self):
        with self._choice():
            with self._option():
                self._class_()
            with self._option():
                self._module_()
            with self._option():
                self._trait_()
            self._error('no available options')

    @graken()
    def _constrExpr_(self):
        with self._choice():
            with self._option():
                self._selfInvocation_()
            with self._option():
                self._constrBlock_()
            self._error('no available options')

    @graken()
    def _constrBlock_(self):
        self._token('{')
        self._selfInvocation_()

        def block0():
            self._eol_()
            self._blockStat_()
        self._closure(block0)
        self._token('}')

    @graken()
    def _selfInvocation_(self):
        self._token('this')
        self._argumentsExpr_()

        def block0():
            self._argumentsExpr_()
        self._closure(block0)

    @graken()
    def _topStat_(self):
        with self._choice():
            with self._option():
                self._comment_()
            with self._option():

                def block0():
                    self._annotation_()
                    with self._optional():
                        self._nl_()
                self._closure(block0)

                def block1():
                    self._modifier_()
                self._closure(block1)
                self._tmplDef_()
            with self._option():
                self._import_()
            with self._option():
                self._packaging_()
            with self._option():
                self._packageObject_()
            with self._option():
                self._nl_()
            self._error('no available options')

    @graken()
    def _topStatSeq_(self):
        self._topStat_()

        def block0():
            self._eol_()
            self._topStat_()
        self._closure(block0)

    @graken()
    def _packaging_(self):
        self._token('package')
        self._qualId_()
        with self._optional():
            self._nl_()
        self._token('{')
        self._topStatSeq_()
        self._token('}')

    @graken()
    def _packageObject_(self):
        self._token('package')
        self._token('object')
        self._objectDef_()

    @graken()
    def _package_(self):
        self._token('package')
        self._qualId_()

    @graken()
    def _compilationUnit_(self):

        def block1():
            self._comment_()
            self._nl_()
        self._closure(block1)
        self.name_last_node('initialcomment')

        def block3():
            self._package_()
            self._eol_()
        self._closure(block3)
        self.name_last_node('package')
        self._topStatSeq_()
        self.name_last_node('stats')
        self.ast._define(
            ['initialcomment', 'package', 'stats'],
            []
        )


class ScalaSemantics(object):
    def nl1(self, ast):
        return ast

    def nl(self, ast):
        return ast

    def seminl(self, ast):
        return ast

    def eol(self, ast):
        return ast

    def UnicodeEscape(self, ast):
        return ast

    def HexDigit(self, ast):
        return ast

    def WhiteSpace(self, ast):
        return ast

    def UnicodeUpper(self, ast):
        return ast

    def UnicodeLower(self, ast):
        return ast

    def UnicodeLetterMisc(self, ast):
        return ast

    def UnicodeOpchar(self, ast):
        return ast

    def Upper(self, ast):
        return ast

    def Lower(self, ast):
        return ast

    def Letter(self, ast):
        return ast

    def Digit(self, ast):
        return ast

    def paren(self, ast):
        return ast

    def delim(self, ast):
        return ast

    def assign(self, ast):
        return ast

    def wildcard(self, ast):
        return ast

    def Wildcard(self, ast):
        return ast

    def arrow(self, ast):
        return ast

    def enumeratorArrow(self, ast):
        return ast

    def projectOp(self, ast):
        return ast

    def OpcharBlocker(self, ast):
        return ast

    def PrintableChar(self, ast):
        return ast

    def PrintableCharNoWs(self, ast):
        return ast

    def Opchar(self, ast):
        return ast

    def CharEscapeSeq(self, ast):
        return ast

    def lpar(self, ast):
        return ast

    def rpar(self, ast):
        return ast

    def lbrace(self, ast):
        return ast

    def rbrace(self, ast):
        return ast

    def lbrack(self, ast):
        return ast

    def rbrack(self, ast):
        return ast

    def prefixOperator(self, ast):
        return ast

    def syntaxOperator(self, ast):
        return ast

    def this(self, ast):
        return ast

    def booleanLiteral(self, ast):
        return ast

    def integerLiteral(self, ast):
        return ast

    def negativeIntegerLiteral(self, ast):
        return ast

    def decimalNumeral(self, ast):
        return ast

    def hexNumeral(self, ast):
        return ast

    def nonZeroDigit(self, ast):
        return ast

    def floatingPointLiteral(self, ast):
        return ast

    def negativeFloatingPointLiteral(self, ast):
        return ast

    def exponentPart(self, ast):
        return ast

    def floatType(self, ast):
        return ast

    def CharNoQuoteOrNewline(self, ast):
        return ast

    def CharNoDoubleQuote(self, ast):
        return ast

    def CharNoDoubleQuoteOrNewline(self, ast):
        return ast

    def characterLiteral(self, ast):
        return ast

    def StringElement(self, ast):
        return ast

    def stringLiteralData(self, ast):
        return ast

    def SingleQuote(self, ast):
        return ast

    def openingSingleQuote(self, ast):
        return ast

    def TripleQuote(self, ast):
        return ast

    def openingTripleQuote(self, ast):
        return ast

    def singleLineStringLiteral(self, ast):
        return ast

    def multiLineChars(self, ast):
        return ast

    def multiLineStringLiteral(self, ast):
        return ast

    def stringLiteral(self, ast):
        return ast

    def symbolLiteral(self, ast):
        return ast

    def blockCommentStart(self, ast):
        return ast

    def blockCommentEnd(self, ast):
        return ast

    def blockCommentChar1(self, ast):
        return ast

    def blockCommentChar(self, ast):
        return ast

    def eolCommentStart(self, ast):
        return ast

    def eolCommentChar(self, ast):
        return ast

    def blockCommentContent(self, ast):
        return ast

    def eolCommentContent(self, ast):
        return ast

    def blockComment(self, ast):
        return ast

    def eolComment(self, ast):
        return ast

    def comment(self, ast):
        return ast

    def OpBlocker(self, ast):
        return ast

    def op(self, ast):
        return ast

    def IdWildcard(self, ast):
        return ast

    def IdLetter(self, ast):
        return ast

    def plainidNoToken(self, ast):
        return ast

    def plainid(self, ast):
        return ast

    def plainidName(self, ast):
        return ast

    def idOpSuffix(self, ast):
        return ast

    def quotedId(self, ast):
        return ast

    def id(self, ast):
        return ast

    def case(self, ast):
        return ast

    def match(self, ast):
        return ast

    def typekw(self, ast):
        return ast

    def literal(self, ast):
        return ast

    def qualId(self, ast):
        return ast

    def ids(self, ast):
        return ast

    def classQualifier(self, ast):
        return ast

    def superAttrPre(self, ast):
        return ast

    def superAttr(self, ast):
        return ast

    def stableId(self, ast):
        return ast

    def thisRef(self, ast):
        return ast

    def selectrest(self, ast):
        return ast

    def select(self, ast):
        return ast

    def path(self, ast):
        return ast

    def functionArgTypes(self, ast):
        return ast

    def existentialClause(self, ast):
        return ast

    def existentialDcl(self, ast):
        return ast

    def typeProjectionPre(self, ast):
        return ast

    def typeProjection(self, ast):
        return ast

    def dependentType(self, ast):
        return ast

    def parenthesizedTypes(self, ast):
        return ast

    def simpleType(self, ast):
        return ast

    def typeArgs(self, ast):
        return ast

    def refinementTemplate(self, ast):
        return ast

    def refineStat(self, ast):
        return ast

    def appliedType(self, ast):
        return ast

    def regularType(self, ast):
        return ast

    def annotType(self, ast):
        return ast

    def annotOrRegularType(self, ast):
        return ast

    def refinementSubtype(self, ast):
        return ast

    def refinementsOnlySubtype(self, ast):
        return ast

    def refinementsWithTemplate(self, ast):
        return ast

    def refinements(self, ast):
        return ast

    def refinedType(self, ast):
        return ast

    def compoundType(self, ast):
        return ast

    def infixTypePart(self, ast):
        return ast

    def infixTypeRest(self, ast):
        return ast

    def infixType(self, ast):
        return ast

    def functionType(self, ast):
        return ast

    def infixExistentialType(self, ast):
        return ast

    def type(self, ast):
        return ast

    def typesTail(self, ast):
        return ast

    def types(self, ast):
        return ast

    def ascription(self, ast):
        return ast

    def patMat(self, ast):
        return ast

    def bindings(self, ast):
        return ast

    def binding(self, ast):
        return ast

    def postfixExpr(self, ast):
        return ast

    def infixOper(self, ast):
        return ast

    def infixExpr(self, ast):
        return ast

    def prefixExpr(self, ast):
        return ast

    def simpleAssignExpr(self, ast):
        return ast

    def attrAssignExpr(self, ast):
        return ast

    def applyAssignExprPre(self, ast):
        return ast

    def applyAssignExpr(self, ast):
        return ast

    def assignExpr(self, ast):
        return ast

    def argumentExpr(self, ast):
        return ast

    def argumentExprsTail(self, ast):
        return ast

    def argumentExprs(self, ast):
        return ast

    def arguments(self, ast):
        return ast

    def argumentSplat(self, ast):
        return ast

    def argumentsWithSplat(self, ast):
        return ast

    def argumentsBlock(self, ast):
        return ast

    def argumentsExpr(self, ast):
        return ast

    def parenthesizedInfixExpr(self, ast):
        return ast

    def parenthesizedExpr(self, ast):
        return ast

    def parenthesizedExprs(self, ast):
        return ast

    def parenthesizedExprsExpr(self, ast):
        return ast

    def simpleExprPre(self, ast):
        return ast

    def attrExprPre(self, ast):
        return ast

    def attrExpr(self, ast):
        return ast

    def attrExprTypeArgs(self, ast):
        return ast

    def applyExprPre(self, ast):
        return ast

    def applyExpr1(self, ast):
        return ast

    def applyExprChain(self, ast):
        return ast

    def applyExpr(self, ast):
        return ast

    def simpleExpr1(self, ast):
        return ast

    def classInstantiation(self, ast):
        return ast

    def etaPre(self, ast):
        return ast

    def etaExpansion(self, ast):
        return ast

    def simpleExprTypeArgs(self, ast):
        return ast

    def simpleExpr(self, ast):
        return ast

    def compoundExpr(self, ast):
        return ast

    def simpleOrCompoundExpr(self, ast):
        return ast

    def ifExpr(self, ast):
        return ast

    def whileExpr(self, ast):
        return ast

    def catchExpr(self, ast):
        return ast

    def finallyExpr(self, ast):
        return ast

    def tryExpr(self, ast):
        return ast

    def doExpr(self, ast):
        return ast

    def forExpr(self, ast):
        return ast

    def throwExpr(self, ast):
        return ast

    def returnExpr(self, ast):
        return ast

    def controlExpr(self, ast):
        return ast

    def anonFuncExprParamImplicit(self, ast):
        return ast

    def anonFuncExprParams(self, ast):
        return ast

    def anonFuncRhs(self, ast):
        return ast

    def anonFuncExpr(self, ast):
        return ast

    def ascribedSimpleOrCompoundExpr(self, ast):
        return ast

    def expr(self, ast):
        return ast

    def exprsTail(self, ast):
        return ast

    def exprs(self, ast):
        return ast

    def enumerators(self, ast):
        return ast

    def generator(self, ast):
        return ast

    def patternApply(self, ast):
        return ast

    def patternApplyVariadic(self, ast):
        return ast

    def parenthesizedPatterns(self, ast):
        return ast

    def patternSimple(self, ast):
        return ast

    def patternInfix(self, ast):
        return ast

    def patternInfixOrSimple(self, ast):
        return ast

    def patternAliasedName(self, ast):
        return ast

    def patternTyped(self, ast):
        return ast

    def pattern1(self, ast):
        return ast

    def patternTail(self, ast):
        return ast

    def pattern(self, ast):
        return ast

    def patternsTail(self, ast):
        return ast

    def patternsSeq(self, ast):
        return ast

    def patternVariadic(self, ast):
        return ast

    def patterns(self, ast):
        return ast

    def guardExpr(self, ast):
        return ast

    def guard(self, ast):
        return ast

    def caseBlockBody(self, ast):
        return ast

    def caseClauseRhs(self, ast):
        return ast

    def caseClause(self, ast):
        return ast

    def caseClausesRest(self, ast):
        return ast

    def caseClauses(self, ast):
        return ast

    def typeParam(self, ast):
        return ast

    def typeParamClause(self, ast):
        return ast

    def typeParams(self, ast):
        return ast

    def funTypeParamClause(self, ast):
        return ast

    def variantTypeParam(self, ast):
        return ast

    def tpLowerBound(self, ast):
        return ast

    def tpUpperBound(self, ast):
        return ast

    def tpViewBound(self, ast):
        return ast

    def tpContextBound(self, ast):
        return ast

    def paramTypeLazy(self, ast):
        return ast

    def paramTypeVariant(self, ast):
        return ast

    def paramType(self, ast):
        return ast

    def param(self, ast):
        return ast

    def variadicParam(self, ast):
        return ast

    def params(self, ast):
        return ast

    def paramClause(self, ast):
        return ast

    def implicitParamClause(self, ast):
        return ast

    def paramClauses(self, ast):
        return ast

    def classParam(self, ast):
        return ast

    def classParams(self, ast):
        return ast

    def classParamClause(self, ast):
        return ast

    def classParamClauses(self, ast):
        return ast

    def modifier(self, ast):
        return ast

    def localModifier(self, ast):
        return ast

    def accessModifier(self, ast):
        return ast

    def accessQualifier(self, ast):
        return ast

    def annotation(self, ast):
        return ast

    def constrAnnotation(self, ast):
        return ast

    def templateStatDef(self, ast):
        return ast

    def templateStatDcl(self, ast):
        return ast

    def templateStat1(self, ast):
        return ast

    def templateStat(self, ast):
        return ast

    def templateStatsTail(self, ast):
        return ast

    def templateStats(self, ast):
        return ast

    def templateBody(self, ast):
        return ast

    def template(self, ast):
        return ast

    def selfType(self, ast):
        return ast

    def import_(self, ast):
        return ast

    def importExprPre(self, ast):
        return ast

    def importExpr(self, ast):
        return ast

    def importSelectors(self, ast):
        return ast

    def importSelector(self, ast):
        return ast

    def dcl(self, ast):
        return ast

    def valDcl(self, ast):
        return ast

    def funDcl(self, ast):
        return ast

    def typeDcl(self, ast):
        return ast

    def patDefPats(self, ast):
        return ast

    def varDefSimple(self, ast):
        return ast

    def patDef(self, ast):
        return ast

    def uninitializedVarDef(self, ast):
        return ast

    def varDef(self, ast):
        return ast

    def funSig(self, ast):
        return ast

    def funDefFull(self, ast):
        return ast

    def funDefUnit(self, ast):
        return ast

    def funDefCtor(self, ast):
        return ast

    def funDef1(self, ast):
        return ast

    def funDef(self, ast):
        return ast

    def typeDef(self, ast):
        return ast

    def valVarDef(self, ast):
        return ast

    def varVarDef(self, ast):
        return ast

    def patVarDef(self, ast):
        return ast

    def def_(self, ast):
        return ast

    def resultAnonFunc(self, ast):
        return ast

    def resultExpr(self, ast):
        return ast

    def blockStatMod(self, ast):
        return ast

    def blockStatDef(self, ast):
        return ast

    def blockStatTemplDef(self, ast):
        return ast

    def blockStat1(self, ast):
        return ast

    def blockStat(self, ast):
        return ast

    def blockRest(self, ast):
        return ast

    def blockBody(self, ast):
        return ast

    def blockExprContent(self, ast):
        return ast

    def block(self, ast):
        return ast

    def statBlock(self, ast):
        return ast

    def caseBlock(self, ast):
        return ast

    def classDef(self, ast):
        return ast

    def traitDef(self, ast):
        return ast

    def objectDef(self, ast):
        return ast

    def classTemplateOpt(self, ast):
        return ast

    def traitTemplateOpt(self, ast):
        return ast

    def classTemplate(self, ast):
        return ast

    def traitTemplate(self, ast):
        return ast

    def classParents(self, ast):
        return ast

    def traitParents(self, ast):
        return ast

    def constr(self, ast):
        return ast

    def earlyDefs(self, ast):
        return ast

    def earlyDef(self, ast):
        return ast

    def class_(self, ast):
        return ast

    def module(self, ast):
        return ast

    def trait(self, ast):
        return ast

    def tmplDef(self, ast):
        return ast

    def constrExpr(self, ast):
        return ast

    def constrBlock(self, ast):
        return ast

    def selfInvocation(self, ast):
        return ast

    def topStat(self, ast):
        return ast

    def topStatSeq(self, ast):
        return ast

    def packaging(self, ast):
        return ast

    def packageObject(self, ast):
        return ast

    def package(self, ast):
        return ast

    def compilationUnit(self, ast):
        return ast


def main(filename, startrule, **kwargs):
    with open(filename) as f:
        text = f.read()
    parser = ScalaParser(parseinfo=False)
    return parser.parse(text, startrule, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    ast = generic_main(main, ScalaParser, name='Scala')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()
