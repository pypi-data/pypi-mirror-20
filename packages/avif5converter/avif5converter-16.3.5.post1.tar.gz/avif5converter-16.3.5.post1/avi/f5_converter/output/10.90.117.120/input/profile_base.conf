#
# PRE-CONFIGURED PROFILES
#
# This file defines a pre-configured profile with all attributes defined
# and a default rule for each profile type.
# The profiles and rules are named the same as their type.
# For example, the profile of type "http" has the name "http".
# Profiles and rules in this file may be modified but not deleted.
# The file is loaded before bigip.conf.


# LTP classes have been moved to config_base.conf
# as a work-around for tmm doesn't support deleting LTP class

#-------------------------------------------------------------------------------
net rate-shaping drop-policy fred {
    type fred
}
net rate-shaping drop-policy red {
    type red
}
net rate-shaping drop-policy tail {
    type tail
}
net rate-shaping queue pfifo {
    type pfifo
}
net rate-shaping queue sfq {
    type sfq
}
#-------------------------------------------------------------------------------
ltm profile certificate-authority certificateauthority {
    ca-file none
    crl-file none
    authenticate-depth 9
    update-crl false
}
ltm profile client-ssl clientssl {
    alert-timeout 10
    authenticate once
    authenticate-depth 9
    ca-file none
    cache-size 262144
    cache-timeout 3600
    cert-extension-includes { basic-constraints subject-alternative-name }
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    ciphers DEFAULT
    client-cert-ca none
    crl-file none
    handshake-timeout 10
    key /Common/default.key
    mod-ssl-methods disabled
    mode enabled
    options { dont-insert-empty-fragments }
    passphrase none
    peer-cert-mode ignore
    renegotiate-max-record-delay indefinite
    renegotiate-period indefinite
    renegotiate-size indefinite
    renegotiation enabled
    secure-renegotiation require
    strict-resume disabled
    unclean-shutdown enabled
    peer-no-renegotiate-timeout 10
}
ltm profile client-ssl clientssl-insecure-compatible {
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    ciphers !SSLv2:ALL:!DH:!ADH:!EDH:@SPEED
    defaults-from /Common/clientssl
    inherit-certkeychain true
    renegotiation enabled
    secure-renegotiation request
}
ltm profile client-ssl wom-default-clientssl {
    allow-non-ssl enabled
    defaults-from /Common/clientssl
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    inherit-certkeychain true
}
ltm profile client-ssl crypto-server-default-clientssl {
    defaults-from /Common/clientssl
    ciphers DHE-RSA-AES256-GCM-SHA384
    renegotiate-period 21600
    cache-size 0
}
ltm profile dns dns {
    enable-gtm yes
}
ltm profile diameter diameter {
    persist-avp Session-Id
}
ltm profile request-adapt requestadapt {
}
ltm profile response-adapt responseadapt {
}
ltm profile icap icap {
}
ltm profile qoe qoe {
}
ltm profile mssql mssql {
}
ltm message-routing generic protocol genericmsg {
}
ltm message-routing generic router messagerouter {
}
ltm profile gtp gtp {
}
ltm profile fix fix {
}
ltm message-routing sip profile router siprouter {
    operation-mode load-balancing
}
ltm message-routing sip profile session sipsession {
    max-msg-size 65535
    generate-response-on-failure disabled
    max-forwards-check enabled
    persistence {
        persist-type session
        persist-key Call-ID
        persist-timeout 180
    }
}
ltm profile fasthttp fasthttp {
    client-close-timeout 5
    connpool-idle-timeout-override 0
    connpool-max-reuse 0
    connpool-max-size 2048
    connpool-min-size 0
    connpool-step 4
    header-insert none
    idle-timeout 300
    insert-xforwarded-for disabled
    layer-7 enabled
    max-header-size 32768
    max-requests 0
    mss-override 0
    reset-on-timeout enabled
    server-close-timeout 5
}
ltm profile fastl4 fastL4 {
    idle-timeout 300
    mss-override 0
    pva-acceleration full
    reassemble-fragments disabled
    reset-on-timeout enabled
}
ltm profile ftp ftp {}
ltm profile html html {
    content-selection { text/html text/xhtml }
}
ltm profile http http {
    basic-auth-realm none
    lws-width 80
    oneconnect-transformations enabled
    proxy-type reverse
    enforcement {
        max-header-count 64
        max-header-size 32768
        pipeline allow
        unknown-method allow
    }
    request-chunking preserve
    response-chunking selective
}
ltm profile http http-transparent {
    basic-auth-realm none
    lws-width 80
    oneconnect-transformations enabled
    proxy-type transparent
    enforcement {
        max-header-count 32
        excess-client-headers pass-through
        excess-server-headers pass-through
        max-header-size 16384
        oversize-client-headers pass-through
        oversize-server-headers pass-through
        truncated-redirects enabled
        pipeline allow
        unknown-method allow
    }
    request-chunking preserve
    response-chunking selective
}
ltm profile http http-explicit {
    basic-auth-realm none
    lws-width 80
    oneconnect-transformations enabled
    proxy-type explicit
    enforcement {
        max-header-count 64
        max-header-size 32768
        pipeline allow
        unknown-method allow
    }
    request-chunking preserve
    response-chunking selective
    explicit-proxy {
        route-domain /Common/0
        default-connect-handling deny
        tunnel-name /Common/http-tunnel
    }
}
ltm profile http2 http2 {
    connection-idle-timeout 300
    insert-header disabled
    insert-header-name X-HTTP2
    activation-modes { alpn npn }
    concurrent-streams-per-connection 10
    receive-window 32
    frame-size 2048
    write-size 16384
    header-table-size 4096
}
ltm profile spdy spdy {
    protocol-versions { spdy3.1 spdy3 spdy2 http1.1 }
    connection-idle-timeout 300
    insert-header disabled
    insert-header-name X-SPDY
    activation-mode npn
    priority-handling strict
    concurrent-streams-per-connection 10
    receive-window 32
    frame-size 2048
    write-size 16384
}
ltm profile smtps smtps {
    activation-mode require
}
ltm profile client-ldap clientldap {
    activation-mode require
}
ltm profile server-ldap serverldap {
    activation-mode none
}
ltm profile http-compression httpcompression {
    allow-http-10 disabled
    browser-workarounds disabled
    buffer-size 4096
    content-type-exclude none
    content-type-include { text/ "application/(xml|x-javascript)" }
    cpu-saver enabled
    cpu-saver-high 90
    cpu-saver-low 75
    gzip-level 1
    gzip-memory-level 8k
    gzip-window-size 16k
    keep-accept-encoding disabled
    method-prefer gzip
    min-size 1024
    selective disabled
    uri-exclude none
    uri-include { .* }
    vary-header enabled
}
ltm profile http-compression wan-optimized-compression {
    allow-http-10 enabled
    buffer-size 131072
    defaults-from /Common/httpcompression
    gzip-level 1
    gzip-memory-level 16k
    gzip-window-size 64k
    vary-header enabled
}
ltm profile iiop iiop {
    abort-on-timeout disabled
    persist-object-key disabled
    persist-request-id enabled
    timeout 30
}
ltm profile one-connect oneconnect {
    idle-timeout-override disabled
    max-age 86400
    max-reuse 1000
    max-size 10000
    source-mask any
}
ltm profile pptp pptp {
    include-destination-ip disabled
}
ltm profile radius radiusLB {
    clients none
    persist-avp none
}
ltm profile radius radiusLB-subscriber-aware {
    defaults-from /Common/radiusLB
    subscriber-aware enabled
}
ltm profile request-log request-log {
    request-logging disabled
    response-logging disabled
}
ltm profile rewrite rewrite {
    client-caching-type cache-css-js
    bypass-list none
    rewrite-list none
    split-tunneling false
    java-ca-file /Common/ca-bundle.crt
    java-sign-key /Common/default.key
    java-signer /Common/default.crt
}
ltm profile rewrite rewrite-portal {
    rewrite-mode portal
    java-ca-file /Common/ca-bundle.crt
    java-sign-key /Common/default.key
    java-signer /Common/default.crt
}
ltm profile rewrite rewrite-uri-translation {
    rewrite-mode uri-translation
}
ltm profile rtsp rtsp {
    idle-timeout 300
}
ltm profile server-ssl serverssl {
    alert-timeout 10
    authenticate once
    authenticate-depth 9
    authenticate-name none
    ca-file none
    cache-size 262144
    cache-timeout 3600
    cert none
    chain none
    ciphers DEFAULT
    crl-file none
    handshake-timeout 10
    key none
    mod-ssl-methods disabled
    mode enabled
    options { dont-insert-empty-fragments }
    passphrase none
    peer-cert-mode ignore
    renegotiate-period indefinite
    renegotiate-size indefinite
    renegotiation enabled
    secure-renegotiation require-strict
    strict-resume disabled
    unclean-shutdown enabled
}
ltm profile server-ssl apm-default-serverssl {
    ca-file /Common/ca-bundle.crt
    defaults-from /Common/serverssl
    peer-cert-mode require
    secure-renegotiation request
}
ltm profile server-ssl serverssl-insecure-compatible {
    ciphers !SSLv2:!EXPORT:!DH:RSA+RC4:RSA+AES:RSA+DES:RSA+3DES:ECDHE+AES:ECDHE+3DES:@SPEED
    defaults-from /Common/serverssl
    secure-renegotiation request
}
ltm profile server-ssl wom-default-serverssl {
    defaults-from /Common/serverssl
    cert /Common/default.crt
    key /Common/default.key
    mode disabled
}
ltm profile server-ssl crypto-client-default-serverssl {
    defaults-from /Common/serverssl
    ciphers DHE-RSA-AES256-GCM-SHA384
    cache-size 0
}
ltm profile server-ssl pcoip-default-serverssl {
    defaults-from /Common/serverssl
    server-name pcoip-default-sni
}
ltm profile sctp sctp {
    idle-timeout 300
    init-max-retries 4
    receive-ordered enabled
    receive-window-size 65535
    reset-on-timeout enabled
    secret default
    send-buffer-size 65536
    send-max-retries 8
    send-partial enabled
    tcp-shutdown enabled
}
ltm profile analytics analytics {
    collect-server-latency enabled
    collect-page-load-time disabled
    collect-url disabled
    collect-ip disabled
    collect-geo disabled
    collect-user-agent disabled
    collect-http-throughput enabled
    collect-response-codes enabled
    collect-methods enabled
    collect-max-tps-and-throughput disabled
    publish-irule-statistics disabled
    collect-user-sessions disabled
    session-timeout 300
    collected-stats-internal-logging enabled
    captured-traffic-internal-logging disabled
    collected-stats-external-logging disabled
    captured-traffic-external-logging disabled
    notification-by-syslog disabled
    notification-by-snmp disabled
    notification-by-email disabled
}

ltm profile classification classification {
}

ltm profile sip sip {
    insert-record-route-header disabled
    insert-via-header disabled
    max-size 65535
    secure-via-header disabled
    terminate-on-bye enabled
}
ltm profile statistics stats {
    defaults-from none
    field1 none
    field2 none
    field3 none
    field4 none
    field5 none
    field6 none
    field7 none
    field8 none
    field9 none
    field10 none
    field11 none
    field12 none
    field13 none
    field14 none
    field15 none
    field16 none
    field17 none
    field18 none
    field19 none
    field20 none
    field21 none
    field22 none
    field23 none
    field24 none
    field25 none
    field26 none
    field27 none
    field28 none
    field29 none
    field30 none
    field31 none
    field32 none
}
ltm profile stream stream {
    source none
    target none
}
ltm profile pcp pcp {
    announce-after-failover disabled
    announce-multicast 10
    listening-port 5351      
    map-filter-limit 1
    map-limit-per-client 65535
    map-recycle-delay 60
    max-mapping-lifetime 86400
    min-mapping-lifetime 600
    multicast-port 5350
    peer-oper-allowed disabled
    rule none
    third-party-option disabled
}
ltm profile tcp mptcp-mobile-optimized {
    abc disabled
    congestion-control illinois
    defaults-from /Common/tcp
    delay-window-control disabled
    delayed-acks disabled
    dsack disabled
    ecn enabled
    hardware-syn-cookie disabled
    init-cwnd 16
    limited-transmit enabled
    mptcp enabled
    nagle enabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 131072
    proxy-buffer-low 131072
    rate-pace enabled
    receive-window-size 131072
    reset-on-timeout disabled
    selective-acks enabled
    send-buffer-size 262144
    slow-start enabled
    timestamps enabled
}
ltm profile tcp tcp-legacy {
    ack-on-push disabled
    close-wait-timeout 5
    congestion-control high-speed
    deferred-accept disabled
    delayed-acks enabled
    ecn disabled
    fin-wait-timeout 5
    idle-timeout 300
    keep-alive-interval 1800
    limited-transmit enabled
    max-retrans 8
    nagle disabled
    proxy-buffer-high 16384
    proxy-buffer-low 4096
    proxy-mss disabled
    proxy-options disabled
    receive-window-size 32768
    reset-on-timeout enabled
    selective-acks enabled
    send-buffer-size 32768
    slow-start enabled
    syn-max-retrans 3
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled  
}
ltm profile tcp tcp-mobile-optimized {
    abc disabled
    congestion-control high-speed
    defaults-from /Common/tcp
    delay-window-control disabled
    delayed-acks disabled
    dsack disabled
    ecn enabled
    init-cwnd 16
    limited-transmit enabled
    nagle enabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 131072
    proxy-buffer-low 131072
    receive-window-size 131072
    reset-on-timeout disabled
    selective-acks enabled
    send-buffer-size 131072
    slow-start enabled
    timestamps enabled
}
ltm profile tcp tcp {
    ack-on-push enabled
    close-wait-timeout 5
    congestion-control high-speed
    deferred-accept disabled
    delayed-acks enabled
    ecn disabled
    fin-wait-timeout 5
    idle-timeout 300
    keep-alive-interval 1800
    limited-transmit enabled
    max-retrans 8
    nagle disabled
    proxy-buffer-high 49152
    proxy-buffer-low 32768
    proxy-mss disabled
    proxy-options disabled
    receive-window-size 65535
    reset-on-timeout enabled
    selective-acks enabled
    send-buffer-size 65535
    slow-start enabled
    syn-max-retrans 3
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
}
ltm profile tcp tcp-lan-optimized {
    ack-on-push enabled
    nagle disabled
    proxy-buffer-high 131072
    proxy-buffer-low 98304
    receive-window-size 65535
    send-buffer-size 65535
    slow-start disabled
}
ltm profile tcp tcp-wan-optimized {
    defaults-from /Common/tcp
    nagle enabled
    proxy-buffer-high 131072
    proxy-buffer-low 131072
    receive-window-size 65535
    selective-acks enabled
    send-buffer-size 65535
}
ltm profile tcp wom-tcp-lan-optimized {
    cmetrics-cache disabled
    defaults-from /Common/tcp-lan-optimized
    delayed-acks disabled
    idle-timeout 600
    nagle enabled
    proxy-mss disabled
    slow-start disabled
}
ltm profile tcp wom-tcp-wan-optimized {
    defaults-from /Common/tcp-wan-optimized
    delayed-acks disabled
    idle-timeout 600
    nagle enabled
    proxy-buffer-high 196608
    proxy-buffer-low 131072
    proxy-mss disabled
    receive-window-size 458752
    selective-nack enabled
    send-buffer-size 458752
    slow-start disabled
    zero-window-timeout 300000
    pkt-loss-ignore-burst 8
    pkt-loss-ignore-rate 10000
}
ltm profile dhcpv4 dhcpv4 {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
    max-hops 4
    ttl-value 0
}
ltm profile dhcpv6 dhcpv6 {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
}
ltm profile udp udp {
    idle-timeout 60
}
ltm profile ipother ipother {
    idle-timeout 60
}
ltm profile udp udp_gtm_dns {
    datagram-load-balancing enabled
    defaults-from /Common/udp
    idle-timeout 5
}
ltm profile socks socks {
    protocol-versions { socks4 socks4a socks5 }
    default-connect-handling deny
    route-domain /Common/0
    tunnel-name /Common/socks-tunnel
}

ltm profile web-acceleration optimized-acceleration {
    cache-object-max-size 67108864
    cache-object-min-size 0
    cache-size 6144
    defaults-from /Common/webacceleration
}
ltm profile web-acceleration optimized-caching {
    cache-max-age 86400
    cache-object-max-size 2000000
    cache-object-min-size 0
    cache-size 10
    defaults-from /Common/webacceleration
}
ltm profile web-acceleration webacceleration {
    cache-aging-rate 9
    cache-client-cache-control-mode all
    cache-insert-age-header enabled
    cache-max-age 3600
    cache-max-entries 10000
    cache-object-max-size 50000
    cache-object-min-size 500
    cache-size 100
    cache-uri-include { .* }
    cache-uri-include-override none
    cache-uri-exclude none
    cache-uri-pinned none
    metadata-cache-max-size 25
}
ltm profile web-security websecurity { }
ltm profile xml xml {}
security dos profile dos { }
security http profile http_security { }
security anti-fraud profile antifraud { }

#----------- datasync local profiles -----------#

security datasync local-profile crypt-asm-dosl7 {
    buf-size 10240
    ds-area asm
    gen-pause-sec 0
    gen-timeout-sec 0
    keep-conf-files 0
    min-cpu-percent 0
    max-gen-rows infinite
    min-mem-mb 0
    offline-until-gen enabled
    rows-bulk 1
}
security datasync local-profile crypt-fpm {
    buf-size 10240
    ds-area fps
    gen-pause-sec 0
    gen-timeout-sec 0
    keep-conf-files 0
    min-cpu-percent 0
    max-gen-rows infinite
    min-mem-mb 0
    offline-until-gen enabled
    rows-bulk 1
}
security datasync local-profile cs-asm-dosl7 {
    buf-size 9437184
    ds-area asm
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 1000
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 100
    offline-until-gen enabled
    rows-bulk 10
}
security datasync local-profile cs-fpm {
    buf-size 16777216
    ds-area fps
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 1000
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 100
    offline-until-gen enabled
    rows-bulk 10
}
security datasync local-profile rsa {
    buf-size 2097152
    ds-area fps
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 0
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 50
    offline-until-gen disabled
    rows-bulk 50
}
security datasync local-profile captcha {
    buf-size 524288
    ds-area asm
    gen-pause-sec 0
    gen-timeout-sec 1800
    keep-conf-files 0
    min-cpu-percent 10
    max-gen-rows infinite
    min-mem-mb 50
    offline-until-gen enabled
    rows-bulk 4
}

#------------- profile_persistence -------------#
ltm persistence cookie cookie {
    cookie-name none
    expiration 0
    hash-length 0
    hash-offset 0
    method insert
    mirror disabled
}
ltm persistence dest-addr dest_addr {
    mask none
    mirror disabled
    timeout 180
}
ltm persistence hash hash {
    mirror disabled
    rule none
    timeout 180
}
ltm persistence msrdp msrdp {
    has-session-dir yes
    mirror disabled
    timeout 300
}
ltm persistence sip sip_info {
    mirror disabled
    timeout 180
}
ltm persistence source-addr source_addr {
    map-proxies enabled
    mask none
    mirror disabled
    timeout 180
}
ltm persistence ssl ssl {
    mirror disabled
    timeout 300
}
ltm persistence universal universal {
    mirror disabled
    rule none
    timeout 180
}
#--------- profile_auth
ltm auth profile krbdelegate {
    configuration none
    cookie-key abc123
    cookie-name f5auth
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    type krbdelegate
}
ltm auth profile ldap {
    configuration none
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ldap
    type ldap
}
ltm auth profile radius {
    configuration none
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_radius
    type radius
}
ltm auth profile ssl_cc_ldap {
    configuration none
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ssl_cc_ldap
    type ssl-cc-ldap
}
ltm auth profile ssl_crldp {
    configuration none
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ssl_crldp
    type ssl-crldp
}
ltm auth profile ssl_ocsp {
    configuration none
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ssl_ocsp
    type ssl-ocsp
}
ltm auth profile tacacs {
    configuration none
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_tacacs
    type tacacs
}
#-------------------------------------------------------------------------------
ltm data-group internal aol {
    records {
        64.12.96.0/19 { }
        195.93.16.0/20 { }
        195.93.48.0/22 { }
        195.93.64.0/19 { }
        195.93.96.0/19 { }
        198.81.0.0/22 { }
        198.81.8.0/23 { }
        198.81.16.0/20 { }
        202.67.65.128/25 { }
        205.188.112.0/20 { }
        205.188.146.144/30 { }
        205.188.192.0/20 { }
        205.188.208.0/23 { }
        207.200.112.0/21 { }
    }
    type ip
}
ltm data-group internal images {
    records {
        .bmp { }
        .gif { }
        .jpg { }
    }
    type string
}
ltm data-group internal private_net {
    records {
        10.0.0.0/8 { }
        172.16.0.0/12 { }
        192.168.0.0/16 { }
    }
    type ip
}
#-------------------------------------------------------------------------------
ltm alg-log-profile alg_log_profile {
    end-control-channel {
        action enabled
    }
    end-data-channel {
        action enabled
    }
    inbound-transaction {
        action enabled
    }
}
ltm lsn-log-profile lsn_log_profile {
    end-outbound-session {
        action enabled
    }
    end-inbound-session {
        action enabled
    }
    quota-exceeded {
        action enabled
    }
    errors {
        action enabled
    }
}
#-------------------------------------------------------------------------------
ltm rule /Common/_sys_auth_ldap {
    nowrite nodelete
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(ldap)]} {
            set tmm_auth_sid [AUTH::start pam default_ldap]
            set tmm_auth_http_sids(ldap) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(ldap)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(ldap)] or \
           ($tmm_auth_http_sids(ldap) != [AUTH::last_event_session_id]) or \
           (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "ldap") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }

        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if {[AUTH::status] == 0} {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
definition-signature d+BwFQlDUIY7Jf5jfpCFuEkwn/jJ+3ZjEQLQej71v7TxzQpxJps4rDaU2YxBNyM9CTAIWT3DRdLqYZAnIHqVpOIRIE/ALk0v0o79IxJIES4nUTE9UTHKM8GN13VBkihf1I8O9DmwOHgB1s0HV+A/dy5mDiyBFpbamyv6rJCASItyPp2Y7iKfcMHEFe+qgvZFA2B131QVAosIn6pFribwU5LSvArIul5pIgX1tcuI+BLPkaJy6xoN9AQcah/ufgUCOmAvkc/K5LteBkxG3ItldFNaxOtAPXDt5IDhrBuMxsvRs7P+vMbfNiGb+QSakipxML2EmwCRiacxQTZn/0DDrw==

}
ltm rule _sys_auth_radius {
    nowrite nodelete
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(radius)]} {
            set tmm_auth_sid [AUTH::start pam default_radius]
            set tmm_auth_http_sids(radius) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(radius)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(radius)] or \
            ($tmm_auth_http_sids(radius) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "radius") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
definition-signature m0ZhOZjHe7lvErKAbir601WnOlWEPfEh/Qc5wayIKc6B16E4IF4F+Jh8QGdYRgNOrk3Qc3Gid6zQZcCcbIzfR3NKOxfVX+tl0KfiEN1lqBQMLu3/AooE+/YTC5oCPuvV6TK/JHRLiMiexYgRx6G+AFU7xg/w/YzgvV0bjsd9OxdIUB3WO5JOUweCG6q24zhVgN+3QIIiBnuKaMeHtRSw29xVpuQqgNKVG7RaPu15loA0xp8s4fxMF0YHDYPuQuu0PLfvYTqsSP0cI3Kdbsg5JgAIAcdHlFIW3NaUJBPMGRLOAvSGibIMVhFmUfC52LNQ4iORtokInaHyYUtPQ/yHIw==

}
ltm rule _sys_auth_ssl_cc_ldap {
    nowrite nodelete
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_cc_ldap_sid 0
        set tmm_auth_ssl_cc_ldap_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        if {[SSL::cert count] == 0} {
            return
        }
        set tmm_auth_ssl_cc_ldap_done 0
        if {$tmm_auth_ssl_cc_ldap_sid == 0} {
            set tmm_auth_ssl_cc_ldap_sid [AUTH::start pam default_ssl_cc_ldap]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_cc_ldap_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_cc_ldap_sid [SSL::cert 0]
        AUTH::authenticate $tmm_auth_ssl_cc_ldap_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_cc_ldap_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_cc_ldap_sid] and \
            ($tmm_auth_ssl_cc_ldap_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_cc_ldap_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_cc_ldap_done == 0} {
                reject
            }
        }
    }
definition-signature O2ctQteahGXIbb4l9/vERvtwKeyl51hGNNGgccddtwme/6opsgPJu5gaiVGUXYYDkbcjFdfgDTU9oDPkLl5JmZ3VcExnlnvxLpVDuM/fKqxbgoRQZ6nl0mEceHmWxRY9AlhrODtJZxNRbQBu4OOCYS+yWioKgKkrBwQaEoIFBPSSUmeIPZHTXdNnLXwxxkY75O5Sc4sTkYQ3BvTrlu/frnwweed6qw9bWatN865CIzP3Spq0ELY0Q4bvxo+0JdLheFv2BfKUethrjEXcxiD9Ros0fnvQ83qaCHqt18xEyhakdKAf4gKZJt9UApkRn+1ZTPNJFzgQyPPYQGvU/y9JAQ==

}
ltm rule _sys_auth_ssl_ocsp {
    nowrite nodelete
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_ocsp_sid 0
        set tmm_auth_ssl_ocsp_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        if {[SSL::cert count] == 0} {
            return
        }
        set tmm_auth_ssl_ocsp_done 0
        if {$tmm_auth_ssl_ocsp_sid == 0} {
            set tmm_auth_ssl_ocsp_sid [AUTH::start pam default_ssl_ocsp]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_ocsp_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_ocsp_sid [SSL::cert 0]
        AUTH::cert_issuer_credential $tmm_auth_ssl_ocsp_sid [SSL::cert issuer 0]
        AUTH::authenticate $tmm_auth_ssl_ocsp_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_ocsp_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_ocsp_sid] and \
            ($tmm_auth_ssl_ocsp_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_ocsp_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_ocsp_done == 0} {
                reject
            }
        }
    }
definition-signature mHRNmZiszQh85wPdt5PxM2ASLXyW47LE3CM5tS11M1lTe9ttjlWDc6yBdy5VFjC6H2O2DJ+fyrBmeMen16RVWPhUoq8YOJC9ZiuuLc6T/rW9GsopSHFPBLRjL/EPulNkuGB/DtxYvwXfXOyBuVRw+E/TYkKVi6cIrk4+e9mOnCo9biWycrRfemWwYyDCqouEaDK2huYnQ1rKyYAvIWxfd3rXXw6+jdpuvL/6RFXJjaLTJ/f1pVMHP5kuI2K/dkeojqDDgr1d1GnjIFFX2Azh5qZpaL1urPfn/M6C/7sXzew1PU0ow10MQtKKqAno5IpEpn+cPZlCs3d2Y1khtMqUug==

}
ltm rule _sys_auth_ssl_crldp {
    nowrite nodelete
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_crldp_sid 0
        set tmm_auth_ssl_crldp_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        if {[SSL::cert count] == 0} {
            return
        }
        set tmm_auth_ssl_crldp_done 0
        if {$tmm_auth_ssl_crldp_sid == 0} {
            set tmm_auth_ssl_crldp_sid [AUTH::start pam default_ssl_crldp]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_crldp_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_crldp_sid [SSL::cert 0]
        AUTH::cert_issuer_credential $tmm_auth_ssl_crldp_sid [SSL::cert issuer 0]
        AUTH::authenticate $tmm_auth_ssl_crldp_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_crldp_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_crldp_sid] and \
            ($tmm_auth_ssl_crldp_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_crldp_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_crldp_done == 0} {
                reject
            }
        }
    }
definition-signature PhTy24ctbtx0d4kFIFO6+Fr9W3a/7OetZ7nlh18mpH6BB9t1dB2LNayATLZ3q4iT4wLLdyyxA+g4jdrNBeuZVpM2JOBlhwcyIcTBFLQN4H/mkWErH4Vz9ZMxVduUxHN6fIh8zDQuJJYoRVlz087/vIVvk6ygbPwS9KqTdYBa3Nn79YmIVn1NXKyVoCg/40EZ3iNklwIfKctwqGU5ELKbhwk8CGCvexDbJcwRqv8nAETC4B/nc61jpGcihpOJchJFb3buTiAKwfxSYkx90UG4EnwsyA4GqUNIfS02Dj5rYSMH403CNNBKG2AA+ZGy9by2O3bb9lq/VNGPDmsnMEff1g==

}
ltm rule _sys_auth_tacacs {
    nowrite nodelete
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(tacacs)]} {
            set tmm_auth_sid [AUTH::start pam default_tacacs]
            set tmm_auth_http_sids(tacacs) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(tacacs)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(tacacs)] or \
            ($tmm_auth_http_sids(tacacs) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "tacacs") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
definition-signature GHNO23blFC/AnIkRk9DSySYK2LiesD7h2DliAMIsVIjBk/RFL8XvZ+8WuKMVibuCiAhPWWvUu6nKsTnk9pX5/kc4yV6qRHcaaO+UaqT1/KQZsVXShCf0YCzqjRQIduJhUFFn0MUDhDmo/8ti0Upo6loKBxW3TODx5y8Jf3dTKmX2oRMfrkiMEyVtv38O7MDwJ1H5/xF2z1r2+nWGUJThZq/ILpfzcdnI7X5j/PxnAGuL1zciRIZ/0RIyMvYch0GaoXaKLVaONzDm0nHEJ+hZ7Vp8mQZiRitc8MGs1Ku9yLamxosUFAdRVnNQOLXGrlvEm94oU6XR3mq0oeqx9+dnOQ==

}
ltm rule _sys_auth_krbdelegate {
    nowrite nodelete
    when HTTP_REQUEST {
        set thecert ""
        set ckname F5KRBAUTH
        set ckpass abc123
        set authprofiles [PROFILE::list auth]
        # Search the auth profiles for the krbdelegate(7) and grab cookie info
        foreach profname $authprofiles {
            if { [PROFILE::auth $profname type] == 7 } {
                set tmpckname [PROFILE::auth $profname cookie_name]
                set tmpckpass [PROFILE::auth $profname cookie_key]
                if {[PROFILE::auth $profname cookie_name] != "" } {
                    set ckname $tmpckname
                    set ckpass $tmpckpass
                    break
                }
            }
        }
        set seecookie 0
        set insertcookie 0
        # check for the cookie
        if {not [info exists tmm_auth_http_sids(krbdelegate)]} {
            set tmm_auth_sid [AUTH::start pam default_krbdelegate]
            set tmm_auth_http_sids(krbdelegate) $tmm_auth_sid
            AUTH::subscribe $tmm_auth_sid
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(krbdelegate)
        }
        if { [PROFILE::exists clientssl] } {
            set certcmd "SSL::cert 0"
            set thecert [ eval $certcmd ]
        }
        if { $thecert == "" } {
            # if no cert, assume old kerb delegation
            # if there is no Authorization header and no cookie, get one.
            if { ([HTTP::header Authorization] == "") and
                  (not [HTTP::cookie exists $ckname])} {
                HTTP::respond 401 WWW-Authenticate Negotiate
                return
            }
        }
        if {[HTTP::cookie exists $ckname]} {
            set ckval [HTTP::cookie decrypt $ckname $ckpass]
            AUTH::username_credential $tmm_auth_sid "cookie"
            AUTH::password_credential $tmm_auth_sid $ckval
            set seecookie 1
        } else {
            if { $thecert == "" } {
                # Kerberos Delegation - set username
                # Strip off the Negotiate before the base64d goodness
                AUTH::username_credential $tmm_auth_sid [lindex [HTTP::header Authorization] 1]
            }
            else {
                # Protocol Transition - set ttm_auth_sid
                AUTH::username_credential $tmm_auth_sid "krpprottran"
                AUTH::cert_credential $tmm_auth_sid $thecert
            }
            AUTH::password_credential $tmm_auth_sid "xxxx"
        }
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(krbdelegate)] or \
            ($tmm_auth_http_sids(krbdelegate) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "krbdelegate") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
               }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                array set pamout [AUTH::response_data]
                HTTP::header replace Authorization "Negotiate $pamout(krbdelegate:attr:SPNEGO)"
                if {$seecookie == 0} {
                    set insertcookie $pamout(krbdelegate:attr:KRB5CCNAME)
                }
                HTTP::release
            } else {
                HTTP::respond 401 WWW-Authenticate Negotiate "Set-Cookie" "$ckname= ; expires=Wed Dec 31 16:00:00 1969"
            }
        }
    }
    # When the response goes out, if we need to insert a cookie, do it.
    when HTTP_RESPONSE {
        if {$insertcookie != 0} {
            HTTP::cookie insert name $ckname value $insertcookie
            HTTP::cookie encrypt $ckname $ckpass
        }
    }
definition-signature mILi/VF69pqpNg+XJ4nClBl8+zq4v9FsiBYnKjX3zLZOChRWKt5CwkwpsbCRzx5DnvHglp9uXDYrjqcAFvM5aRA2R5LAhKQSq6pVPwHdZUJluYv0t3n6af/vSyc7KYsx6gga1jLuiFZaEzmG8c+r4igxwEee874iQBjYaWhHyKYGhlhly/Ez2FE9DNRpRepz2sq/jaKzEmmMod3CCXurXVGlC/Pk8qnbNid1yC15DGosrAKW1d8lhYbVBaXVQ1ahrr/UPYnDdHB1BiWUzRSS4uOKuUyUmT/xPI14/Nwv8zdFvlu+AnnD543zH6KhdSHhJ3zCVy2HSZ5wPuN3YswcBA==

}
ltm rule _sys_https_redirect {
    nowrite nodelete
    when HTTP_REQUEST {
       HTTP::redirect https://[getfield [HTTP::host] ":" 1][HTTP::uri]
    }
definition-signature mwyl4XlRKRMQc0prWs7RtpgPcNfocOKb+MaFwAnQgAuUZZyG68OaGZsOCN3poUOFdHOc6fk2XAdGRmTRiP/7BCT7thsOX5zLFzA1N1wcr57KWVzEZt3ezxVXn2Z974OmbWm7P5Lclcr7N3adrLJMWfyfPPVF1tUYn0IQPD2QNMmfbcbr1oCuO93n/5dn0s6/EacHZGG53hVibW7xQuJXdMtoQ6ArSZ4U3n4vCDTb6NLYbAj6PirVzKY2pcsWFHFUSVrphSFwERc8+0XGHUE6Cb3ihzygoZc2cQ5jk3frFY70MkDluPTShFRbHd7PlMPRezrfkVZVeUHA/iBPcYcD+w==

}

ltm rule _sys_APM_activesync {
    nowrite nodelete
    when RULE_INIT {
        set static::actsync_401_http_body   "<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body   "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX       "01490000:7:"
    }
    when HTTP_REQUEST {
        set http_path                       [string tolower [HTTP::path]]
        set f_clientless_mode               0

        if { $http_path == "/microsoft-server-activesync" } {
        }
        elseif { $http_path == "/autodiscover/autodiscover.xml" } {
            set f_auto_discover 1
        }
        else return

        if { ! [ info exists src_ip ] } {
            set src_ip                            [IP::remote_addr]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP  	  1
        }
        # Only allow HTTP Basic Authentication.
        set auth_info_b64enc                ""
        set http_hdr_auth                   [HTTP::header Authorization]
        regexp -nocase {Basic (.*)} $http_hdr_auth match auth_info_b64enc
        if { $auth_info_b64enc == "" } {
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Empty/invalid HTTP Basic Authorization header"
            HTTP::respond 401 content $static::actsync_401_http_body Connection close
            return
        }

        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        # Do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                # Default profile access setting is false
                if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                    return
                }
                elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched"
                    return
                }
                else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                }
            }
            else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
            }
            set MRHSession_cookie ""
            HTTP::cookie remove MRHSession
        }

        set apm_username                    [ string tolower [HTTP::username] ]
        set apm_password                    [HTTP::password]

        if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
            binary scan [md5 "$apm_password$"] H* user_hash
        } else {
            binary scan [md5 "$apm_password$src_ip"] H* user_hash
        }
        set user_key {}
        append user_key $apm_username "." $user_hash
        unset user_hash

        set f_insert_clientless_mode    0
        set apm_cookie_list             [ ACCESS::user getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
            if { $apm_cookie != "" } {
                HTTP::cookie insert name MRHSession value $apm_cookie
            } else {
                set f_insert_clientless_mode 1
            }
        } else {
            set f_insert_clientless_mode 1
        }

        if { $f_insert_clientless_mode == 1 } {
            HTTP::header insert "clientless-mode" 1
            HTTP::header insert "username" $apm_username
            HTTP::header insert "password" $apm_password
        }
        unset f_insert_clientless_mode
    }
    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1
            ACCESS::session data set "session.user.activesync" 1
            if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                set f_auto_discover 0
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
        }
    }
    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set policy_result [ACCESS::policy result]
        switch $policy_result {
        "allow" {
        }
        "deny" {
            ACCESS::respond 401 content $static::actsync_401_http_body Connection close
            ACCESS::session remove
        }
        default {
            ACCESS::respond 503 content $static::actsync_503_http_body Connection close
            ACCESS::session remove
        }
        }

        unset user_key
    }
definition-signature s9Un4H1gVmKPFbVadbNZM+hFnWssJtXmoD/SMt4LSXbWwoc2FRHmPsf4xil4pgFnm4V4hqH9dvIdlceyE0t0GIhouPPz4j9e+PcDQZZVV2K8gjT4+xRg38Rc+R0a633kMr88N5yksAujOQwv2gVdpSoeeQXwVnCnHcTBcu1qn0SwSFTkKaqHDGnDDcUmFl0yo+xtqtDKG5FR43nyAA3dHwu+QY21NAQaEBgN5zfVe4prr+AdVZK359E7ZyW6gGNPr+rhYQ5J5v2Q2NofSBgY7OGIO609GzAHWd7cvNesm34SzMNxrOfgSAdg9DieJi905cHxFn02nyPD54wn0YX2Bg==

}

ltm rule _sys_APM_ExchangeSupport_helper {
    nowrite nodelete
    # The purpose of this iRule is for help the main virtual for the timing of the HTTP request retry
    # during the SSO process for OutlookAnywhere protocol request which has a Content-Length value of 1GB.

    when HTTP_REQUEST {
        #  Waiting for the first chunk of data.
        HTTP::collect 1
    }

    when HTTP_REQUEST_DATA {
        # Respond 401 and close the connection once we received the data.
        HTTP::respond 401 WWW-Authenticate NTLM Connection close
    }
definition-signature fnJWcC75FIDV4savxGjyZ5sTdRTen+3mItejhseH06qn+qBXjOl/j7wYRSLDv1IcFezF8BunbDftMHXrW7QRuPuxhjMIc4vaALE2CCGkO0xcs258F+nkPeeJKoR5mTHY/E5BWpOAISinUBUSA3/nUm8blXkMwVg/Q95360jcCOoi6csgJa97OSKIF9h9OQCylh1qGBsDRHEXCR3ycw5Eb4T2QQSdBn09vr8Hgdpi/9fUER97nzJe8T/RuoG+nQ7bc8F9yzG6nFa/CQtRYDybDrcNgllCfVloXZAHZS3dCpq6FnS/FaEWfSIujmV+lXkxY23Xz9Wf6i1h/feW9fEUiQ==

}

ltm rule _sys_APM_ExchangeSupport_main {
    nowrite nodelete
    # Global variables
    # static::POLICY_RESULT_CACHE_AUTHFAILED
    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.
    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.
    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.
    # Responses
    # On denied result
    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.
    #     In those cases, please use ACCESS::respond command.
    #     The following is the syntax of ACCESS::respond
    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]
    #     e.g. ACCESS::respond 401 content "Error: Denied" WWW-Authenticate "basic realm=\"f5.com\"" Connection close
    when RULE_INIT {
        # Please set the following global variables for customized responses.
        set static::actsync_401_http_body "<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        # Second Virtual Server name for 401 NTLM responder
        set static::ACCESS_SECOND_VIRTUAL_NAME        "_ACCESS_401_NTLM_responder_HTTPS"

        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_AUTHFAILED                 "policy_authfailed"
        # The request with huge content length can not be used for starting ACCESS session.
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session. The following value is used for Outlook Anywhere.
        set static::OA_MAGIC_CONTENT_LEN              1073741824

        # Similar with OutlookAnywhere case, ACCESS can not use the request which is
        # larger then following size. This becomes an issue with application that using
        # Exchange Web Service as its main protocol such as Mac OS X applications
        # (e.g. Mail app, Microsoft Entourage, etc)
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session.
        set static::FIRST_BIG_POST_CONTENT_LEN        640000

        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.
        set static::EWS_BKEND_BASIC_AUTH              0
        # Set it into 1 if the backend RPC-over-HTTP handler accepts HTTP Basic Authentication.
        set static::RPC_OVER_HTTP_BKEND_BASIC_AUTH    0
        # The following variable controls the polling mechanism.
        set static::POLICY_RESULT_POLL_INTERVAL       250
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600

        # Set this global variable to 1 for caching authentication failure
        # Useful for avoiding account locked out.
        set static::POLICY_RESULT_CACHE_AUTHFAILED    0

        # set this global variable to set alternative timeout for particular session
        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120

        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"


        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/"

        log -noname accesscontrol.local1.debug "01490000:7: RPC_OVER_HTTP_BKEND_BASIC_AUTH = $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH"
        log -noname accesscontrol.local1.debug "01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH"
    }
    when ACCESS_ACL_ALLOWED {
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]"

        if { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 }  {
            if { $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH == 0 } {
                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Use this virtual $static::ACCESS_SECOND_VIRTUAL_NAME just once. Will be reset back after disconnection."
                    use virtual $static::ACCESS_SECOND_VIRTUAL_NAME
                }
               log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Remove HTTP Auth header"
               HTTP::header remove Authorization
            }
        }
        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been
        # already authenticated if there is a HTTP Basic Auth in the request.
        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {
            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header"
                HTTP::header remove Authorization
            }
        }
    }

    when HTTP_REQUEST {
        set http_path                       [ string tolower [HTTP::path] ]
        set f_clientless_mode               0
        set f_alt_inactivity_timeout        0
        set f_rpc_over_http                 0
        set f_exchange_web_service          0
        set f_auto_discover                 0
        set f_activesync                    0
        set f_offline_address_book          0
        set f_availability_service          0

        #  Here put appropriate pool when necessary.
        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            # Supports for RPC over HTTP. (Outlook Anywhere)
            set f_rpc_over_http 1
        }
        "/autodiscover/autodiscover.xml" {
            # Supports for Auto Discover protocol.
            set f_auto_discover 1
            # This request does not require long inactivity timeout.
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/microsoft-server-activesync" {
            # Supports for ActiveSync
            set f_activesync 1
        }
        "/oab/*" {
            # Supports for Offline Address Book
            set f_offline_address_book 1
        }
        "/ews/*" {
            # Support for Exchange Web Service
            # Outlook's Availability Service borrows this protocol.
            set f_exchange_web_service 1
        }
        "/as/*" {
            # Support for Availability Service.
            # do nothing for now. (Untested)
            set f_availability_service 1
        }
        default {
            return
        }
        }

        set f_reqside_set_sess_id           0
        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set src_ip                          [IP::remote_addr]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        set auth_info_b64enc                ""

        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } {
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP        1
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method: $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP: $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Restrict-to-single-client-ip: $PROFILE_RESTRICT_SINGLE_IP"

        # First, do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        set http_hdr_auth [HTTP::header Authorization]
        if { [ string match -nocase {basic *} $http_hdr_auth ] != 1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header"
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX No/Empty Auth header"
            # clean up the cookie
            if { $MRHSession_cookie == "" } {
                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection close
                return
            }
            # Do nothing if we have a valid MRHSession cookie.
        }

        set f_release_request           0
        # Optimization for clients which support cookie
        if { $MRHSession_cookie != "" } {
            # Default profile access setting is false
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                set f_release_request 1
            }
            elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched"
                set f_release_request 1
            }
            else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        if { $f_release_request == 0 } {
            set apm_username [ string tolower [HTTP::username]]
            set apm_password [HTTP::password]
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                binary scan [md5 "$apm_password"] H* user_hash
            } else {
                binary scan [md5 "$apm_password$src_ip"] H* user_hash
            }

            set user_key    {}
            append user_key $apm_username "." $user_hash
            unset user_hash

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX apm_username: $apm_username"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key = $user_key"
            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $apm_cookie != "" } {
                    HTTP::cookie insert name MRHSession value $apm_cookie
                    set f_release_request 1
                }
            }
        }

        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {
            set f_oa_magic_content_len 1
        }

        set f_sleep_here 0
        set retry 1

        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len"

            # This is also going to touch the table entry timer.
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME"

            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME -notouch $user_key]
            if { $apm_cookie != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie"

                # Accessing SessionDB is not that cheap. Here we are trying to check known value.
                if { $apm_cookie == "policy_authfailed" || $apm_cookie == "policy_inprogress"} {
                    # Do nothing
                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync"
                    # Table value is out of sync. Ignores it.
                    set apm_cookie ""
                }
            }

            switch $apm_cookie {
            "" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"

                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable
                    # for creating new session since 1G content-length is intended for client to upload
                    # the data when needed.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len"
                    set f_sleep_here 1
                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                    # Here we are getting large EWS request, which can't be used for starting new session
                    # in clientless-mode. Have it here waiting for next smaller one.
                    # We are holding the request here in HTTP filter, and HTTP filter automatically
                    # clamping down the TCP window when necessary.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request"
                    set f_sleep_here 1
                } else {
                   set apm_cookie               "policy_inprogress"
                   set f_reqside_set_sess_id    1
                   set f_release_request        1
                }
            }
            "policy_authfailed" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED"
                HTTP::respond 401 content  $static::actsync_401_http_body
                set f_release_request 1
            }
            "policy_inprogress" {
                if { [ info exists f_activesync ] && ($f_activesync == 1) } {
                    # For ActiveSync requests, aggressively starts new session.
                    set f_reqside_set_sess_id    1
                    set f_release_request        1
                } else {
                    set f_sleep_here 1
                }
            }
            default {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie"
                HTTP::header insert Cookie "MRHSession=$apm_cookie"
                set f_release_request 1
            }
            }

            if { $f_reqside_set_sess_id == 1 } {
                set f_reqside_set_sess_id 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                set f_clientless_mode 1
                HTTP::cookie remove MRHSession
                HTTP::header insert "clientless-mode" 1
                HTTP::header insert "username" $apm_username
                HTTP::header insert "password" $apm_password
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT
            }

            if { $f_sleep_here == 1 } {
                set f_sleep_here 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
                after  $static::POLICY_RESULT_POLL_INTERVAL
            }

            incr retry
        }

        if { $f_release_request == 0 && $retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri"

            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1

            if { [ info exists f_activesync ] && $f_activesync == 1 } {
                ACCESS::session data set "session.user.microsoft-activesync" 1
            }
            elseif { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
            elseif { [ info exists f_availability_service ] && $f_availability_service == 1 } {
                ACCESS::session data set "session.user.microsoft-availabilityservice" 1
            }
            elseif { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {
                ACCESS::session data set "session.user.microsoft-rpcoverhttp" 1
            }
            elseif { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {
                ACCESS::session data set "session.user.microsoft-offlineaddressbook" 1
            }
            elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
                ACCESS::session data set "session.user.microsoft-exchangewebservice" 1
            }
        }
        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {
            ACCESS::session data set "session.inactivity_timeout"  $static::POLICY_ALT_INACTIVITY_TIMEOUT
        }
    }

    when HTTP_RESPONSE {
        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
            set content_len [ HTTP::header Content-Length ]
            if {  $content_len > 0 } {
                HTTP::collect $content_len
            }
        }
    }
    when HTTP_RESPONSE_DATA {
        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
            if { [ regsub -line {<AuthPackage>Ntlm</AuthPackage>} [ HTTP::payload ] {<AuthPackage>Basic</AuthPackage>} payload ] != 0 } {
                HTTP::payload replace 0 $content_len $payload
            }
        }
    }
    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session sid ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        set inactivity_timeout [ACCESS::session data get "session.inactivity_timeout"]
        set max_sess_timeout [ACCESS::session data get "session.max_session_timeout"]
        if { $max_sess_timeout == "" } {
             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT
        }

        switch $policy_result {
        "allow" {
            # We depends on this table record self-cleanup capability in order to
            # indirectly sync with session DB.
            set user_key_value $sid

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"
        }
        "deny" {
            # When necessary the admin here can check appropriate session variable
            # and decide what response more appropriate then this default response.
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection close
            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {
                set user_key_value  $static::POLICY_AUTHFAILED
            } else {
                set f_delete_session  1
            }
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }
        if { $user_key_value != "" } {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME"

           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout
        } else {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME"

           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
        }

        if { $f_delete_session == 1 } {
           ACCESS::session remove
           set f_delete_session 0
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
definition-signature feX9LM+vB6YOEdVF+EA1JtNyVkPaB7gwdW0JzaB083MXl4yPP2nZnjm+WAx3YQhsmLttq5UkPl1zHpr5H9cwJX1bu9BNMi/+n0bIqWOipDHhhSYQ+TH+a5jQUSeftISr52BSQxh0cQKZkzM3rFU/qRZn9D9Dbf0kDGiDC1KWwVosrdjp5tVHOiQXWx8zybbGPFfgBcIBE6IvOvGbh5ohebVL2ADZm0URRj2NM4ZvZ2T3C14k2rHGXnDdRsvhmf5USZ+FH1hoKtWRxqtFjkWIaqw8leenXeot1j2bdKy92/AVTC9oZj1HJN1ePuQo5v414zlUhMEtkVy/gaxvj1+vPQ==

}

ltm rule _sys_APM_ExchangeSupport_OA_BasicAuth {
    nowrite nodelete
    # Global variables
    # static::POLICY_RESULT_CACHE_AUTHFAILED
    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.
    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.
    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.
    # Responses
    # On denied result
    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.
    #     In those cases, please use ACCESS::respond command.
    #     The following is the syntax of ACCESS::respond
    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]
    #     e.g. ACCESS::respond 401 content "Error: Denied" WWW-Authenticate "basic realm=\"f5.com\"" Connection close
    when RULE_INIT {
        # Please set the following global variables for customized responses.
        set static::actsync_401_http_body "<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        # Second Virtual Server name for 401 NTLM responder
        set static::ACCESS_SECOND_VIRTUAL_NAME        "_ACCESS_401_NTLM_responder_HTTPS"

        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_AUTHFAILED                 "policy_authfailed"
        # The request with huge content length can not be used for starting ACCESS session.
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session. The following value is used for Outlook Anywhere.
        set static::OA_MAGIC_CONTENT_LEN              1073741824

        # Similar with OutlookAnywhere case, ACCESS can not use the request which is
        # larger then following size. This becomes an issue with application that using
        # Exchange Web Service as its main protocol such as Mac OS X applications
        # (e.g. Mail app, Microsoft Entourage, etc)
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session.
        set static::FIRST_BIG_POST_CONTENT_LEN        640000

        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.
        set static::EWS_BKEND_BASIC_AUTH              0
        # The following variable controls the polling mechanism.
        set static::POLICY_RESULT_POLL_INTERVAL       250
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600

        # Set this global variable to 1 for caching authentication failure
        # Useful for avoiding account locked out.
        set static::POLICY_RESULT_CACHE_AUTHFAILED    0

        # set this global variable to set alternative timeout for particular session
        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120

        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"


        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/"

        log -noname accesscontrol.local1.debug "01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH"
    }
    when ACCESS_ACL_ALLOWED {
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]"

        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been
        # already authenticated if there is a HTTP Basic Auth in the request.
        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {
            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header"
                HTTP::header remove Authorization
            }
        }
    }

    when HTTP_REQUEST {
        set http_path                       [ string tolower [HTTP::path] ]
        set f_clientless_mode               0
        set f_alt_inactivity_timeout        0
        set f_rpc_over_http                 0
        set f_exchange_web_service          0
        set f_auto_discover                 0
        set f_activesync                    0
        set f_offline_address_book          0
        set f_availability_service          0

        #  Here put appropriate pool when necessary.
        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            # Supports for RPC over HTTP. (Outlook Anywhere)
            set f_rpc_over_http 1
        }
        "/autodiscover/autodiscover.xml" {
            # Supports for Auto Discover protocol.
            set f_auto_discover 1
            # This request does not require long inactivity timeout.
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/microsoft-server-activesync" {
            # Supports for ActiveSync
            set f_activesync 1
        }
        "/oab/*" {
            # Supports for Offline Address Book
            set f_offline_address_book 1
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/ews/*" {
            # Support for Exchange Web Service
            # Outlook's Availability Service borrows this protocol.
            set f_exchange_web_service 1
        }
        "/as/*" {
            # Support for Availability Service.
            # do nothing for now. (Untested)
            set f_availability_service 1
        }
        default {
            return
        }
        }

        set f_reqside_set_sess_id           0
        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        set auth_info_b64enc                ""

        if { ! [ info exists src_ip ] } {
            set src_ip                            [IP::remote_addr]
        }
        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } {
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP        1
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method: $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP: $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Restrict-to-single-client-ip: $PROFILE_RESTRICT_SINGLE_IP"

        # First, do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        set http_hdr_auth [HTTP::header Authorization]
        if { [ string match -nocase {basic *} $http_hdr_auth ] != 1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header"
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX No/Empty Auth header"
            # clean up the cookie
            if { $MRHSession_cookie == "" } {
                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                return
            }
            # Do nothing if we have a valid MRHSession cookie.
        }

        set f_release_request           0
        # Optimization for clients which support cookie
        if { $MRHSession_cookie != "" } {
            # Default profile access setting is false
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                set f_release_request 1
            }
            elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched"
                set f_release_request 1
            }
            else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        if { $f_release_request == 0 } {
            set apm_username [string tolower [HTTP::username]]
            set apm_password [HTTP::password]
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                binary scan [md5 "$apm_password"] H* user_hash
            }
            else {
                binary scan [md5 "$apm_password$src_ip"] H* user_hash
            }
            set user_key    "$apm_username.$user_hash"
            unset user_hash

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX apm_username: $apm_username"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key = $user_key"
            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $apm_cookie != "" } {
                    HTTP::cookie insert name MRHSession value $apm_cookie
                    set f_release_request 1
                }
            }
        }

        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {
            set f_oa_magic_content_len 1
        }

        set f_sleep_here 0
        set retry 1

        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len"

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME"

            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME -notouch $user_key]
            if { $apm_cookie != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie"

                # Accessing SessionDB is not that cheap. Here we are trying to check known value.
                if { $apm_cookie == "policy_authfailed" || $apm_cookie == "policy_inprogress"} {
                    # Do nothing
                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync"
                    # Table value is out of sync. Ignores it.
                    set apm_cookie ""
                }
            }

            switch $apm_cookie {
            "" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"

                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable
                    # for creating new session since 1G content-length is intended for client to upload
                    # the data when needed.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len"
                    set f_sleep_here 1
                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                    # Here we are getting large EWS request, which can't be used for starting new session
                    # in clientless-mode. Have it here waiting for next smaller one.
                    # We are holding the request here in HTTP filter, and HTTP filter automatically
                    # clamping down the TCP window when necessary.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request"
                    set f_sleep_here 1
                } else {
                   set apm_cookie               "policy_inprogress"
                   set f_reqside_set_sess_id    1
                   set f_release_request        1
                }
            }
            "policy_authfailed" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED"
                HTTP::respond 401 content  $static::actsync_401_http_body
                set f_release_request 1
            }
            "policy_inprogress" {
                if { [ info exists f_activesync ] && ($f_activesync == 1) } {
                    # For ActiveSync requests, aggressively starts new session.
                    set f_reqside_set_sess_id    1
                    set f_release_request        1
                } else {
                    set f_sleep_here 1
                }
            }
            default {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie"
                HTTP::header insert Cookie "MRHSession=$apm_cookie"
                set f_release_request 1
            }
            }

            if { $f_reqside_set_sess_id == 1 } {
                set f_reqside_set_sess_id 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_POLICY_TIMEOUT"
                set f_clientless_mode 1
                HTTP::cookie remove MRHSession
                HTTP::header insert "clientless-mode" 1
                HTTP::header insert "username" $apm_username
                HTTP::header insert "password" $apm_password
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_POLICY_TIMEOUT
            }

            if { $f_sleep_here == 1 } {
                set f_sleep_here 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
                after  $static::POLICY_RESULT_POLL_INTERVAL
            }

            incr retry
        }

        if { ($f_release_request == 0) && ($retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE) } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri"

            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {

            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1

            if { [ info exists f_activesync ] && $f_activesync == 1 } {
                ACCESS::session data set "session.user.microsoft-activesync" 1
            }
            elseif { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
            elseif { [ info exists f_availability_service ] && $f_availability_service == 1 } {
                ACCESS::session data set "session.user.microsoft-availabilityservice" 1
            }
            elseif { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {
                ACCESS::session data set "session.user.microsoft-rpcoverhttp" 1
            }
            elseif { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {
                ACCESS::session data set "session.user.microsoft-offlineaddressbook" 1
            }
            elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
                ACCESS::session data set "session.user.microsoft-exchangewebservice" 1
            }
        }
        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {
            ACCESS::session data set "session.inactivity_timeout"  $static::POLICY_ALT_INACTIVITY_TIMEOUT
        }
    }

    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session sid ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        set inactivity_timeout [ACCESS::session data get "session.inactivity_timeout"]
        set max_sess_timeout [ACCESS::session data get "session.max_session_timeout"]
        if { $max_sess_timeout == "" } {
             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT
        }

        switch $policy_result {
        "allow" {
            # We depends on this table record self-cleanup capability in order to
            # indirectly sync with session DB.
            set user_key_value $sid

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"
        }
        "deny" {
            # When necessary the admin here can check appropriate session variable
            # and decide what response more appropriate then this default response.
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {
                set user_key_value  $static::POLICY_AUTHFAILED
            } else {
                set f_delete_session  1
            }
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }
        if { $user_key_value != "" } {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME"

           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout
        } else {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME"

           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
        }

        if { $f_delete_session == 1 } {
           ACCESS::session remove
           set f_delete_session 0
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
definition-signature CZnUb3niz9wZPWvOmjDB0Dy4ixqjBEhIZrAVGt8VYe7+wZkhcBUFTADz3S1y5uomVwhRkGL20PLH7tfanDlpr3+IppgAGQlp98sPUl5ndEoWA4Rr90QiRGNRl/V7jWK58SOdJCQOirnutVMoeYjBWLwuprXGts08PO0WML5s0xJNOY7WPuGNeG+7Ht2pIB0vu80CgnCNGZJGZH0QR3kMVOx3yUN0ro5bAOmQ/XWel4qkj0F5DN9ufvsmKtTvb+Lc3y+5PHGbbFAQIrZ7lntZUJl/F8e/d26HE3spmZzQpPzi16qYWaMOxbvT6oedxpyhwbmJLiRNGyZmnT6kHj93FA==

}

ltm rule _sys_APM_ExchangeSupport_OA_NtlmAuth {
    nowrite nodelete
    when RULE_INIT {
        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_FAILED                     "policy_failed"
        set static::POLICY_SUCCEED                    "policy_succeed"
        set static::POLICY_DONE_WAIT_SEC              5

        set static::FIRST_BIG_POST_CONTENT_LEN        640000
        set static::POLICY_RESULT_POLL_INTERVAL       100
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  100
        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        set static::USE_NTLM_AUTH                     0
        set static::USE_BASIC_AUTH                    1
        set static::USE_NTLM_BASIC_AUTH               2

        set static::URL_DEFAULT                       0
        set static::URL_RPC_OVER_HTTP                 1
        set static::URL_AUTODISCOVER                  2
        set static::URL_ACTIVE_SYNC                   3
        set static::URL_OFFLINEADDRESSBOOK            4
        set static::URL_EXCHANGEWEBSERVICE            5

        set static::RECVD_AUTH_NONE                   0
        set static::RECVD_AUTH_NTLM                   1
        set static::RECVD_AUTH_BASIC                  2

        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; \
                                                       expires=Thu, 01-Jan-1970 00:00:01 GMT;\
                                                       path=/"

    }

    when HTTP_REQUEST {
        set http_path                       [string tolower [HTTP::path]]
        set url_path                        $static::URL_DEFAULT
        set use_auth                        $static::USE_NTLM_AUTH
        set f_disable_sso                   0

        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            set url_path                    $static::URL_RPC_OVER_HTTP
        }
        "/autodiscover/autodiscover.xml" {
            set url_path                    $static::URL_ACTIVE_SYNC
            # Need to support both NTLM and Basic authentication for this URL
            set use_auth                    $static::USE_NTLM_BASIC_AUTH
        }
        "/microsoft-server-activesync*" {
            set url_path                    $static::URL_ACTIVE_SYNC
            # Use only Basic authentication for this URL
            set use_auth                    $static::USE_BASIC_AUTH
            set f_disable_sso               1
        }
        "/oab*" {
            set url_path                    $static::URL_OFFLINEADDRESSBOOK
        }
        "/ews*" {
            set url_path                    $static::URL_EXCHANGEWEBSERVICE
        }
        default {
            ECA::disable
            return
        }
        }

        if { ! [ info exists f_ntlm_auth_succeed ] } {
            set f_ntlm_auth_succeed         0
        }
        if { ! [ info exists sid_cache ] } {
            set sid_cache                         ""
        }
        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } { 
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }
        if { ! [ info exists src_ip ] } {
            set src_ip                            [IP::remote_addr]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP        1
        }

        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method:      $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP:      $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent:  $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri:    $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len:    $http_content_len"

        if { ! [ info exists ECA_METADATA_ARG ] } {
            # Generating argument for ECA::metadata
            # The NTLM configuration name is derived from assigned virtual name with the algorithm as follows:
            # <virtual-fullpath> ::= <folder-path>"/"<virtual-basename> as "/" is the last "/" char.
            # <config-fullpath>  ::= <folder-path>"/" "exch_ntlm" "_" <virtual-basename>
            # e.g.  Let us say the virtual name is "/prod/exch/vs1", The folder path is "/prod/exch/",
            #       then object name will be "/prod/exch/exch_ntlm_vs1".
            set vs_name [virtual name]
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX virtual:     $vs_name"
            set slash_index [ string last / $vs_name ]
            if { $slash_index == -1 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Error: the virtual name does not contain folder information"
                ACCESS::disable
                TCP::close
                return
            }
            set ECA_METADATA_ARG    "select_ntlm:"
            append ECA_METADATA_ARG [ string range $vs_name 0 $slash_index ]
            append ECA_METADATA_ARG "exch_ntlm_"
            append ECA_METADATA_ARG [ string range $vs_name [ expr { $slash_index + 1 } ] end ]
            unset slash_index
            unset vs_name
        }

        if { $use_auth == $static::USE_NTLM_AUTH } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Enable ECA: $ECA_METADATA_ARG"
            ECA::enable
            ECA::select $ECA_METADATA_ARG
            return
        } else {
            set recvd_auth                      $static::RECVD_AUTH_NONE
            set http_hdr_auth                   [HTTP::header Authorization]
            set auth_data                       [split $http_hdr_auth " "]
            if { $http_hdr_auth != "" } {
                if { [ llength $auth_data ] == 2 } {
                    set auth_scheme [ lindex $auth_data 0]
                    if { [string equal -nocase $auth_scheme "ntlm" ] == 1 } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Recv'd HTTP NTLM Authentication"
                        set recvd_auth          $static::RECVD_AUTH_NTLM
                    } elseif { [ string equal -nocase [ lindex $auth_data 0] "basic" ] == 1 } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Recv'd HTTP Basic Authentication"
                        set recvd_auth          $static::RECVD_AUTH_BASIC
                        set user                [string tolower [HTTP::username]]
                        set password            [HTTP::password]
                    }
                }
            }
            if { $use_auth == $static::USE_BASIC_AUTH } {
                if { $recvd_auth == $static::RECVD_AUTH_BASIC } {
                    # Defer the process until later
                } else {
                    HTTP::respond 401 -version 1.1 noserver WWW-Authenticate "Basic realm=\"$http_hdr_host\"" \
                                Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                    return
                }
            } elseif { $use_auth == $static::USE_NTLM_BASIC_AUTH } {
                if { ($recvd_auth == $static::RECVD_AUTH_NTLM) || ($f_ntlm_auth_succeed == 1) } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Enable ECA: $ECA_METADATA_ARG"
                    ECA::enable
                    ECA::select $ECA_METADATA_ARG
                    return
                } elseif { $recvd_auth == $static::RECVD_AUTH_BASIC } {
                    # Defer the process until later
                } else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Request Authorization: NTLM + Basic"
                    HTTP::respond 401 -version 1.1 noserver WWW-Authenticate "Basic realm=\"$http_hdr_host\"" \
                                WWW-Authenticate "NTLM" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                    return
                }
            }

            # Disable NTLM auth
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Disable ECA"
            ECA::disable
            # Disable KCD sso
            set f_disable_sso               1

            if { $MRHSession_cookie != "" } {
                if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                    # Default profile access setting is false
                    if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Release the request"
                        return
                    }
                    elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched. Release the request"
                        return
                    }
                    else {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                    }
                }
                else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                }

                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }

            set user_key                {}
            if { $PROFILE_RESTRICT_SINGLE_IP == 1 } {
                append user_key                    $src_ip
            }
            append user_key                 $password
            binary scan [md5 $user_key ] H* user_key
            set user_key                    "$user.$user_key"

            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $MRHSession_cookie != "" } {
                    HTTP::cookie remove MRHSession 
                    HTTP::cookie insert name MRHSession value $MRHSession_cookie
                    return
                }
            }

            HTTP::cookie remove MRHSession
            HTTP::header insert "clientless-mode"       1
            HTTP::header insert "username"              $user
            HTTP::header insert "password"              $password
            return
        }
    }

    when ECA_REQUEST_ALLOWED {
        set f_ntlm_auth_succeed                 1

        if { $MRHSession_cookie == "" } {
            # Retrieve from SID cache
            set MRHSession_cookie   $sid_cache
            HTTP::cookie insert name MRHSession value $sid_cache
        }

        if { $MRHSession_cookie != "" } {
            # Destroy session ID cache. This client should not need session ID cache 
            if { ($sid_cache != "") && ($sid_cache != $MRHSession_cookie) } {
                set sid_cache   ""
            }
            if { [ ACCESS::session exists -state_allow $MRHSession_cookie ] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                # Default profile access setting is false
                if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Release the request"
                    return
                }
                elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched. Release the request"
                    return
                }
                else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                }
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
            }
        }

        set MRHSession  ""
        set sid_cache   ""
        HTTP::cookie remove MRHSession

        # Build user_key
        set    user_key                 {}
        append user_key                 [string tolower [ECA::username]] "@" [ string tolower [ECA::domainname] ]
        if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
            append user_key             ":" $src_ip
        }
        append user_key                 ":" [ECA::client_machine_name]

        set apm_cookie_list             [ ACCESS::user getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
            if { $MRHSession_cookie != "" } {
                set sid_cache           $MRHSession_cookie
                HTTP::cookie insert name MRHSession value $MRHSession_cookie
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX APM Cookie found: $sid_cache"
                return
            }
        }
        unset apm_cookie_list

        set try                         1
        set start_policy_str            $src_ip
        append start_policy_str         [TCP::client_port]

        while { $try <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$try for $http_method $http_uri $http_content_len"

            if { $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                # Wait at below
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX EXEC: table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                set policy_status [table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT]
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX DONE: table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                if { $policy_status == $start_policy_str } {
                    # ACCESS Policy has not started. Start one
                    HTTP::header insert "clientless-mode"    1
                    break
                } elseif { $policy_status == $static::POLICY_SUCCEED } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table is out-of-sync retry"
                    table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
                    continue
                } elseif { $policy_status == $static::POLICY_FAILED } {
                    ACCESS::disable
                    TCP::close
                    return
                }
                # Wait at below
            }

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
            # Touch the entry table
            table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            after  $static::POLICY_RESULT_POLL_INTERVAL

            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $MRHSession_cookie != "" } {
                    set sid_cache           $MRHSession_cookie
                    HTTP::cookie insert name MRHSession value $MRHSession_cookie
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX APM Cookie found: $sid_cache"
                    return
                }
            }

            incr try
        }

        if { $try >  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [ expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri"
            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"

        unset try
        unset start_policy_str
    }

    when ECA_REQUEST_DENIED {
        set f_ntlm_auth_succeed                 0
    }

    when HTTP_RESPONSE_RELEASE {
        if { ! [info exists user_key] } {
            return
        }
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: status:           [HTTP::status]"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: Server:           [HTTP::header Server]"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: Content-Length:   [HTTP::header Content-Length]"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: WWW-Authenticate: [HTTP::header WWW-Authenticate]"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1
        }
    }

    when ACCESS_ACL_ALLOWED {
        if { [ info exists f_disable_sso ] && $f_disable_sso == 1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Disable WEBSSO"
            WEBSSO::disable
        }
    }

    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session sid ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        switch $policy_result {
        "allow" {
            set user_key_value          $sid
            set sid_cache               $user_key_value
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"

        }
        "deny" {
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
            set f_delete_session  1
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }

        if { $f_ntlm_auth_succeed == 1 } {
            if { $user_key_value != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $static::POLICY_SUCCEED"
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $static::POLICY_SUCCEED
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $static::POLICY_FAILED  $static::POLICY_DONE_WAIT_SEC $static::POLICY_DONE_WAIT_SEC_in table $static::ACCESS_USERKEY_TBLNAME"
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $static::POLICY_FAILED  $static::POLICY_DONE_WAIT_SEC $static::POLICY_DONE_WAIT_SEC
            }
        }

        if { $f_delete_session == 1 } {
            ACCESS::session remove
            set f_delete_session 0
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
definition-signature d/SlmwsO4YeDlh3eJpLqam9ytq0/EkWnAce1XTQ5bxOyla0x/VHjkr9dvoo3awaxp7lEjAenIgwGpS2jL5R1hq48WGZN2nu9LDKVjTosrq7j1MHbeKiIW8yXc3IEUtbbkhkAGNnMmfDYMD8Vg7l+iBx6B/WvRTZLr+tmppFf0BIr2Z7FWWU6c9OVl8YH1VuqqFX/lKICn2EXDhebRDRVvuXobLvbjZQxj+tqdUU2vuLzXYot/RUgClXHrg6Z2ZC6/WuAq4pp/XA2kvzWotQiY9gEceQdMC7/BxPSR8xo4VPNqkFkEPjh5hehZP0tFONTZaMaH1klVg4QbvHH5MRiBQ==

}

ltm rule _sys_APM_Office365_SAML_BasicAuth {
    nowrite nodelete
    when HTTP_REQUEST {
        if { [string tolower [HTTP::path]] == "/saml/idp/profile/redirectorpost/sso" } {
            set http_hdr_client_app [HTTP::header X-MS-Client-Application]
            if { $http_hdr_client_app != "" && ($http_hdr_client_app contains "Microsoft.Exchange") } {
                set http_hdr_auth [HTTP::header Authorization]
                if { ($http_hdr_auth == "") || ([ string match -nocase {basic *} $http_hdr_auth ] != 1 ) } {
                    unset http_hdr_auth
                    unset http_hdr_client_app
                    return
                }
                HTTP::header insert "clientless-mode" 1
                HTTP::header insert "username" [HTTP::username]
                HTTP::header insert "password" [HTTP::password]
                unset http_hdr_auth
            }
            unset http_hdr_client_app
        }
    }
definition-signature X3dd2mwvsY19opLav5FPu81K061a4utSwTjNKaxM+4gATCHIpjxt32J5sSQypUR3bafYFJuHy54e+D1Lo3LFy+LbvjCtk5+OGTkcyG+HmfHI6sLnrG2ZupkxAQUknNtn8uxa6qnWXlqCfkZonjXSlrqUSQwUUd4E/V82I1ZfogMCMdh4AlRIRJpQhb1PGR/reD2G6cXWlStb4ZQuLQarv0c8BBGC1U7C4dF3qpUH2x+j1hNm8E/QjUFYaKbym6QbbkqmCbR8rvrT13gXh7WPZ6kkUVHdV1U+dJY36N3xxByKPE0bOg6dq3+MGueBctNxmE/qp1B3VKc2vqi2fk/LJQ==

}

sys file external-monitor arg_example {
    system-path "/config/monitors/arg_example"
}

sys file external-monitor sample_monitor {
    system-path "/config/monitors/sample_monitor"
}

sys file ssl-cert f5-irule.crt {
    system-path "/config/ssl/ssl.crt/f5-irule.crt"
}

sys file ssl-cert /Common/default.crt {
    system-path "/config/ssl/ssl.crt/default.crt"
}

sys file ssl-cert /Common/ca-bundle.crt {
    system-path "/config/ssl/ssl.crt/ca-bundle.crt"
}

sys file ssl-key default.key {
    system-path "/config/ssl/ssl.key/default.key"
}

# URL DB Related settings
sys url-db download-schedule urldb {
    start-time 01:00
    end-time 03:00
}
#-------------------------------------------------------------------------------
# APM (SAM)
#-------------------------------------------------------------------------------
apm profile access access {
    default-language "en"
    accept-languages {"en"}
}
apm resource remote-desktop citrix-client-bundle default-citrix-client-bundle {
}
apm client-packaging client-packaging {
}

apm profile connectivity connectivity {
    compression-codecs { deflate lzo bzip2 }
    compression enabled
    client-policy {
        connectivity_clientPolicy { }
    }
    citrix-client-bundle /Common/default-citrix-client-bundle
}
apm profile remote-desktop remotedesktop {}
apm profile exchange exchange {
    active-sync-auth-type basic
    active-sync-sso-config none
    active-sync-url "/microsoft-server-activesync*"
    auto-discover-auth-type basic
    auto-discover-sso-config none
    auto-discover-url "/autodiscover/*"
    ntlm-auth-name none
    offline-address-book-auth-type basic
    offline-address-book-sso-config none
    offline-address-book-url "/oab/*"
    rpc-over-http-auth-type basic
    rpc-over-http-sso-config none
    rpc-over-http-url "/rpc/rpcproxy.dll"
    user-agent-pattern-for-utf8 "Android*"
    web-service-auth-type basic
    web-service-sso-config none
    web-service-url "/ews/*"
}
apm profile eca eca {}
apm profile vdi vdi {}

apm apm-avr-config apm-avr-config {
    avr-collect-data true
    avr-sampling true
}
#-------------------------------------------------------------------------------
# WOM
#-------------------------------------------------------------------------------
wom profile cifs cifs { }
wom profile isession isession {
    compression-codecs { deflate lzo bzip2 }
    compression enabled
}
wom profile isession isession-encrypt {
    data-encryption enabled
}
wom profile isession isession-mapi {
    defaults-from /Common/isession
}
wom profile isession isession-softwoc {
    defaults-from /Common/isession
    deduplication disabled
}
wom profile mapi mapi {
    native-compression disabled
}
wom profile passthru-woc-plugin passthruwocplugin { }

#-------------------------------------------------------------------------------
# IPsec
#-------------------------------------------------------------------------------
net ipsec ike-peer anonymous {
    my-cert-file /Common/default.crt
    my-cert-key-file /Common/default.key
    my-id-type asn1dn
    peers-id-type asn1dn
    verify-cert false
}
net ipsec ipsec-policy default-ipsec-policy {
    mode transport
}
net ipsec ipsec-policy default-ipsec-policy-isession {
    mode isession
}

#-------------------------------------------------------------------------------
# PEM
#-------------------------------------------------------------------------------
pem profile spm spm { }
pem profile diameter-endpoint diameter-endpoint {
    product-name "BIG-IP"
    msg-retransmit-delay 1500
    msg-max-retransmits 2
    fatal-grace-time {
	time 500
	enabled yes
    }
}
pem profile radius-aaa radiusaaa { }
