#
# PRE-CONFIGURED PROFILES
#
# This file defines a pre-configured profile with all attributes defined
# and a default rule for each profile type.
# The profiles and rules are named the same as their type.
# For example, the profile of type "http" has the name "http".
# Profiles and rules in this file may be modified but not deleted.
# The file is loaded before bigip.conf.


# LTP classes have been moved to config_base.conf 
# as a work-around for tmm doesn't support deleting LTP class

profile fastL4 fastL4 {
    reset on timeout enable
    reassemble fragments disable
    idle timeout 300
    max segment override 0
    pva acceleration full
}

profile tcp tcp {
    reset on timeout enable
    time wait recycle enable
    delayed acks enable
    selective acks enable
    proxy max segment disable
    proxy options disable
    deferred accept disable
    ecn disable
    limited transmit enable
    nagle enable
    rfc1323 enable
    slow start enable
    bandwidth delay enable
    ack on push disable
    idle timeout 300
    time wait 2000
    fin wait 5
    close wait 5
    send buffer 32768
    recv window 32768
    keep alive interval 1800
    max retrans syn 3
    max retrans 8
    congestion control highspeed
    zero window timeout 20000
}

profile sctp sctp {
    idle timeout 300
    init max retries 4
    send max retries 8
    recv ordered enable
    send partial enable
    tcp shutdown enable
    reset on timeout enable
    recv window 65535
    send buffer 65536
    secret "default"
}

profile udp udp {
    idle timeout 60
}

profile http http {
    basic auth realm ""
    max header size 32768
    pipelining enable
    oneconnect transformations enable
    response selective chunk
    compress disable
    compress uri include none
    compress uri exclude none
    compress content type include "text/" "application/(xml|x-javascript)"
    compress content type exclude none
    compress prefer gzip
    compress min size 1024
    compress buffer size 4096
    compress vary header enable
    compress http 1.0 disable
    compress gzip memory level 8K
    compress gzip window size 16K
    compress gzip level 1
    compress cpu saver enable
    compress keep accept encoding disable
    compress browser workarounds disable
    lws width 80
    adaptive parsing enable
    ramcache disable
    ramcache size 100mb
    ramcache max entries 10000
    ramcache max age 3600
    ramcache max object size 50000
    ramcache min object size 500
    ramcache ignore client cache control all
    ramcache uri include none
    ramcache uri exclude none
    ramcache uri pinned none
    ramcache aging rate 9
    ramcache insert age header enable
}

profile httpclass httpclass {
    ts disable
}

profile xml xml {
}

profile ftp ftp {
}

profile radius radiusLB {
    persist avp ""
    clients {}
}

profile diameter diameter {
    persist avp "Session-Id"
}

profile iiop iiop {
    persist request id enable
    persist object key disable
    abort on timeout disable
    timeout 30
}

profile rtsp rtsp {
    idle timeout 300
}

profile dns dns {
    gtm enable
}

profile clientssl clientssl {
    mode enable
    key "default.key"
    cert "default.crt"
    chain ""
    ca file ""
    crl file ""
    client cert ca ""
    ciphers DEFAULT
    options dont insert empty fragments
    modssl methods disable
    cache size 262144
    cache timeout 3600
    renegotiate enable
    renegotiate period indefinite
    renegotiate size indefinite
    renegotiate max record delay 10
    secure renegotiation require
    alert timeout 60
    handshake timeout 60
    peer cert mode ignore
    authenticate once
    authenticate depth 9
    unclean shutdown enable
    strict resume disable
    passphrase none
}

profile certificateauthority certificateauthority {
    ca file ""
    crl file ""
    authenticate depth 9
    update crl disable
}

profile serverssl serverssl {
    mode enable
    key none
    cert none
    chain ""
    ca file ""
    crl file ""
    ciphers DEFAULT
    options dont insert empty fragments
    modssl methods disable
    cache size 262144
    cache timeout 3600
    renegotiate enable
    renegotiate period indefinite
    renegotiate size indefinite
    secure renegotiation request
    alert timeout 60
    handshake timeout 60
    peer cert mode ignore
    authenticate once
    authenticate depth 9
    authenticate name ""
    unclean shutdown enable
    strict resume disable
    passphrase none
}

profile oneconnect oneconnect {
    idle timeout override 0
    max size 10000
    max age 86400
    max reuse 1000
    source mask 0.0.0.0
}

profile stream stream {
    source ""
    target ""
}

profile fasthttp fasthttp {
    idle timeout 300
    server close timeout 5
    client close timeout 5
    conn pool idle timeout override 0
    conn pool max reuse 0
    conn pool max size 2048
    conn pool min size 0
    conn pool step 4
    header insert ""
    insert xforwarded for disable
    max header size 32768
    max requests 0
    max segment override 0
    reset on timeout enable
    layer7 enable
}

profile sip sip {
    insert record route disable
    insert via disable
    secure via disable
    terminate bye enable
    max size 65535
}

profile persist source_addr {
    mode source addr
    timeout 180
    mask none
    rule none
    mirror disable
    map proxies enable
}

profile persist dest_addr {
    mode dest addr
    timeout 180
    mask none
    rule none
    mirror disable
}

profile persist cookie {
    mode cookie
    cookie mode insert
    cookie expiration 0d
    cookie hash offset 0
    cookie hash length 0
    cookie name none
    rule none
    mirror disable
}

profile persist hash {
    mode hash
    timeout 180
    rule none
    mirror disable
}

profile persist msrdp {
    mode msrdp
    timeout 300
    msrdp session directory enable
    rule none
    mirror disable
}

profile persist sip_info {
    mode sip
    timeout 180
    rule none
    mirror disable
}

profile persist ssl {
    mode ssl
    timeout 300
    rule none
    mirror disable
}

profile persist universal {
    mode universal
    timeout 180
    rule none
    mirror disable
}

profile auth ldap {
    type ldap
    mode enable
    credential source http basic auth
    rule _sys_auth_ldap
}

profile auth radius {
    type radius
    mode enable
    credential source http basic auth
    rule _sys_auth_radius
}

profile auth ssl_cc_ldap {
    type ssl cc ldap
    mode enable
    rule _sys_auth_ssl_cc_ldap
}

profile auth ssl_ocsp {
    type ssl ocsp
    mode enable
    rule _sys_auth_ssl_ocsp
}

profile auth ssl_crldp {
    type ssl crldp
    mode enable
    rule _sys_auth_ssl_crldp
}

profile auth tacacs {
    type tacacs
    mode enable
    credential source http basic auth
    rule _sys_auth_tacacs
}

profile auth krbdelegate {
    type krbdelegate
    mode enable
    credential source http basic auth
    rule _sys_auth_krbdelegate
    cookie name f5auth
    cookie key abc123
}

profile rewrite rewrite {
    client caching type cache css js
}

profile connectivity connectivity {
    server list none
    location dns list none
    save password enable
    save servers on exit enable
    component update yes
    save password method disk
    save password timeout 240
    enforce session settings disable
    wm server none
    wm work url exceptions list none
    customization group none
    compress buffer size 4096
    compress cpusaver enable
    compress cpusaver high 90
    compress cpusaver low 75
    compress ingress disable
    compress gzip level 6
    compress gzip memlevel 8192
    compress gzip windowsize 16384
    compress preferred method zlib
}

profile stats stats {
    field1 none
    field2 none
    field3 none
    field4 none
    field5 none
    field6 none
    field7 none
    field8 none
    field9 none
    field10 none
    field11 none
    field12 none
    field13 none
    field14 none
    field15 none
    field16 none
    field17 none
    field18 none
    field19 none
    field20 none
    field21 none
    field22 none
    field23 none
    field24 none
    field25 none
    field26 none
    field27 none
    field28 none
    field29 none
    field30 none
    field31 none
    field32 none
}


# This is a pre-defined class that identifies the proxies for AOL.
# This list should be updated periodically, as the proxy networks are subject
# to change.
#
# See http://webmaster.info.aol.com/proxyinfo.html
#
# Last Updated: 2009-01-06
class aol {
    network 64.12.96.0 mask 255.255.224.0 
    network 195.93.48.0 mask 255.255.252.0
    network 195.93.64.0 mask 255.255.224.0
    network 195.93.96.0 mask 255.255.224.0
    network 195.93.16.0 mask 255.255.240.0
    network 198.81.0.0 mask 255.255.252.0
    network 198.81.16.0 mask 255.255.240.0
    network 198.81.8.0 mask 255.255.254.0
    network 202.67.65.128 mask 255.255.255.128
    network 205.188.192.0 mask 255.255.240.0
    network 205.188.208.0 mask 255.255.254.0
    network 205.188.112.0 mask 255.255.240.0
    network 205.188.146.144 mask 255.255.255.252
    network 207.200.112.0 mask 255.255.248.0
}

# This is a pre-defined class identifying common image file extensions
class images {
    ".jpg"
    ".gif"
    ".bmp"
}

# This is a pre-defined class identifying private network addresses.
class private_net {
   network 10.0.0.0 mask 255.0.0.0
   network 172.16.0.0 mask 255.240.0.0
   network 192.168.0.0 mask 255.255.0.0
}

# Notes on auth profile default rules:
#
# "default_ldap", "default_radius", "default_ssl_cc_ldap", "default_ssl_ocsp",
# "default_tacacs" are five reserved pam service names. When one of these is
# given as second argument of AUTH::start, the last AUTH profile of specified
# type is applied.
#
# The HTTP::* commands below should really be referenced only when the
# credential source is HTTP basic auth, but this is currently the
# only credential source.  Likewise, the entire "when HTTP_REQUEST" rule
# event declaration should only be applied when appropriate.

# When multiple auth http profiles (ldap, radius, tacacs) are simultaneously
# configured on a single virtual server, AND-based logic is used by default,
# i.e., all authentication methods must succeed for the request to be allowed.
# It is also possible to configure OR-based logic, e.g., if either ldap or
# radius are successful, allow the request.  PAM service configurations could
# be manually edited to accomplish this, but a simple iRule can also be used:
# Add a custom CLIENT_ACCEPTED rule to the same virtual server and have the
# rule set the variable tmm_auth_http_sufficient_successes to 1.  Generically,
# this variable may be set to the minimum number of successful auth results
# that are necessary to permit the request.  For example, setting the value
# to 2 while ldap, radius, and tacacs profiles are each configured on a
# virtual will cause requests to be permitted when at least 2 of these 3
# auth methods are successful.

# These auth profile default rules can be optionally configured to subscribe
# to out-of-band auth response data (obtained via AUTH::response_data).
# Subscriptions are enabled by setting the variable tmm_auth_subscription
# prior to system auth rule invoking AUTH::start call, e.g.,
# 
# when CLIENT_ACCEPTED {
#     set tmm_auth_subscription "*"
# }
#
# It is recommended to set this variable to "*".  Although the value of
# tmm_auth_subscription is not used at this time, it is anticipated that
# it will eventually be passed as a parameter to AUTH::subscribe once
# that function supports subscription-matching based on regular expressions.

rule _sys_auth_ldap {
    nowrite nodelete
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(ldap)]} {
            set tmm_auth_sid [AUTH::start pam default_ldap]
            set tmm_auth_http_sids(ldap) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(ldap)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(ldap)] or \
           ($tmm_auth_http_sids(ldap) != [AUTH::last_event_session_id]) or \
           (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "ldap") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }

        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if {[AUTH::status] == 0} {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
}

rule _sys_auth_radius {
    nowrite nodelete
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(radius)]} {
            set tmm_auth_sid [AUTH::start pam default_radius]
            set tmm_auth_http_sids(radius) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(radius)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(radius)] or \
            ($tmm_auth_http_sids(radius) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "radius") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
}

rule _sys_auth_ssl_cc_ldap {
    nowrite nodelete
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_cc_ldap_sid 0
        set tmm_auth_ssl_cc_ldap_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        set tmm_auth_ssl_cc_ldap_done 0
        if {$tmm_auth_ssl_cc_ldap_sid == 0} {
            set tmm_auth_ssl_cc_ldap_sid [AUTH::start pam default_ssl_cc_ldap]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_cc_ldap_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_cc_ldap_sid [SSL::cert 0]
        AUTH::authenticate $tmm_auth_ssl_cc_ldap_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_cc_ldap_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_cc_ldap_sid] and \
            ($tmm_auth_ssl_cc_ldap_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_cc_ldap_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_cc_ldap_done == 0} {
                reject
            }
        }
    }
}

rule _sys_auth_ssl_ocsp {
    nowrite nodelete
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_ocsp_sid 0
        set tmm_auth_ssl_ocsp_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        set tmm_auth_ssl_ocsp_done 0
        if {$tmm_auth_ssl_ocsp_sid == 0} {
            set tmm_auth_ssl_ocsp_sid [AUTH::start pam default_ssl_ocsp]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_ocsp_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_ocsp_sid [SSL::cert 0]
        AUTH::cert_issuer_credential $tmm_auth_ssl_ocsp_sid [SSL::cert issuer 0]
        AUTH::authenticate $tmm_auth_ssl_ocsp_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_ocsp_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_ocsp_sid] and \
            ($tmm_auth_ssl_ocsp_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_ocsp_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_ocsp_done == 0} {
                reject
            }
        }
    }
}

rule _sys_auth_ssl_crldp {
    nowrite nodelete
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_crldp_sid 0
        set tmm_auth_ssl_crldp_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        set tmm_auth_ssl_crldp_done 0
        if {$tmm_auth_ssl_crldp_sid == 0} {
            set tmm_auth_ssl_crldp_sid [AUTH::start pam default_ssl_crldp]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_crldp_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_crldp_sid [SSL::cert 0]
        AUTH::cert_issuer_credential $tmm_auth_ssl_crldp_sid [SSL::cert issuer 0]
        AUTH::authenticate $tmm_auth_ssl_crldp_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_crldp_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_crldp_sid] and \
            ($tmm_auth_ssl_crldp_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_crldp_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_crldp_done == 0} {
                reject
            }
        }
    }
}

rule _sys_auth_tacacs {
    nowrite nodelete
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(tacacs)]} {
            set tmm_auth_sid [AUTH::start pam default_tacacs]
            set tmm_auth_http_sids(tacacs) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(tacacs)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(tacacs)] or \
            ($tmm_auth_http_sids(tacacs) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "tacacs") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
}

rule _sys_auth_krbdelegate {
    nowrite nodelete
    when HTTP_REQUEST {
        set thecert ""
        set ckname F5KRBAUTH
        set ckpass abc123
        set authprofiles [PROFILE::list auth]
        # Search the auth profiles for the krbdelegate(7) and grab cookie info
        foreach profname $authprofiles {
            if { [PROFILE::auth $profname type] == 7 } {
                set tmpckname [PROFILE::auth $profname cookie_name]
                set tmpckpass [PROFILE::auth $profname cookie_key]
                if {[PROFILE::auth $profname cookie_name] != "" } {
                    set ckname $tmpckname
                    set ckpass $tmpckpass
                    break
                }
            }
        }
        set seecookie 0
        set insertcookie 0
        # check for the cookie
        if {not [info exists tmm_auth_http_sids(krbdelegate)]} {
            set tmm_auth_sid [AUTH::start pam default_krbdelegate]
            set tmm_auth_http_sids(krbdelegate) $tmm_auth_sid
            AUTH::subscribe $tmm_auth_sid
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(krbdelegate)
        }
        if { [PROFILE::exists clientssl] } {
            set certcmd "SSL::cert 0"
            set thecert [ eval $certcmd ]
        }
        if { $thecert == "" } {
            # if no cert, assume old kerb delegation
            # if there is no Authorization header and no cookie, get one.
            if { ([HTTP::header Authorization] == "") and 
                  (not [HTTP::cookie exists $ckname])} {
                HTTP::respond 401 WWW-Authenticate Negotiate
                return
            }
        }
        if {[HTTP::cookie exists $ckname]} {
            set ckval [HTTP::cookie decrypt $ckname $ckpass]
            AUTH::username_credential $tmm_auth_sid "cookie"
            AUTH::password_credential $tmm_auth_sid $ckval
            set seecookie 1
        } else {
            if { $thecert == "" } {
                # Kerberos Delegation - set username
                # Strip off the Negotiate before the base64d goodness
                AUTH::username_credential $tmm_auth_sid [lindex [HTTP::header Authorization] 1]
            }
            else {
                # Protocol Transition - set ttm_auth_sid
                AUTH::username_credential $tmm_auth_sid "krpprottran"
                AUTH::cert_credential $tmm_auth_sid $thecert
            }
            AUTH::password_credential $tmm_auth_sid "xxxx"
        }
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(krbdelegate)] or \
            ($tmm_auth_http_sids(krbdelegate) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "krbdelegate") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
               }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                array set pamout [AUTH::response_data]
                HTTP::header replace Authorization "Negotiate $pamout(krbdelegate:attr:SPNEGO)"
                if {$seecookie == 0} {
                    set insertcookie $pamout(krbdelegate:attr:KRB5CCNAME)
                }
                HTTP::release
            } else {
                HTTP::respond 401 WWW-Authenticate Negotiate "Set-Cookie" "$ckname= ; expires=Wed Dec 31 16:00:00 1969" 
            }
        }
    }
    # When the response goes out, if we need to insert a cookie, do it.
    when HTTP_RESPONSE {
        if {$insertcookie != 0} {
            HTTP::cookie insert name $ckname value $insertcookie
            HTTP::cookie encrypt $ckname $ckpass
        }
    }    
}

rule _sys_APM_activesync {
    nowrite nodelete
    when HTTP_REQUEST {
        # Quickly return for internal retry on clientless mode.
        if { [ info exists f_clientless_mode ] && $f_clientless_mode == 1 } {
            set f_clientless_mode 0
            return
        }

        set http_path                       [HTTP::path]
        set f_clientless_mode               0

        if { $http_path == "/Microsoft-Server-ActiveSync" } {
        }
        elseif { $http_path == "/autodiscover/autodiscover.xml" } {
            set f_auto_discover 1
        }
        else return

        set _actsync_401_http_body                    "<html><title>Authentication Failure</title><body>Error: Authentication Failure</body></html>"
        set actsync_401_http_body                     $_actsync_401_http_body
        # Only allow HTTP Basic Authentication.
        set auth_info_b64enc                ""
        set http_hdr_auth                   [HTTP::header Authorization]
        regexp {Basic (.*)} $http_hdr_auth match auth_info_b64enc
        if { $auth_info_b64enc == "" } {
            set http_hdr_auth ""
        }
    
        if { $http_hdr_auth == "" } {
            HTTP::respond 401 content $actsync_401_http_body
            return
        }
 
        set _actsync_503_http_body                    "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set policy_denied_resp_status_code            401 
        set policy_denied_resp_body                   $_actsync_401_http_body
        set policy_fallback_resp_status_code          503
        set policy_fallback_resp_body                 $_actsync_503_http_body
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set src_ip                          [IP::remote_addr]
        set apm_username                    [HTTP::username]
        set apm_password                    [HTTP::password]
        binary scan [md5 "$apm_password$http_hdr_uagent$src_ip"] H* user_hash
        set user_key "$apm_username$user_hash"
        unset user_hash
   
        set apm_cookie_list [ ACCESS::uuid getsid $user_key ]
        if { [ llength $apm_cookie_list ] == 0 } {
            set f_clientless_mode                 1
            HTTP::header insert "clientless-mode" 1
            HTTP::header insert "username" $apm_username
            HTTP::header insert "password" $apm_password
        } else {
            if { [ HTTP::cookie exists MRHSession ] } {
                HTTP::cookie remove MRHSession
            }
            HTTP::cookie insert name MRHSession value [ lindex $apm_cookie_list 0 ]
        }
    }
    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.activesync" 1
            if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                set f_auto_discover 0
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
        }
    }
    when ACCESS_POLICY_COMPLETED {
         if { ! [ info exists user_key ] } {
             return
         }
     
         set policy_result [ACCESS::policy result]
         switch $policy_result {
         "allow" {
         }
         "deny" {
             ACCESS::respond $policy_denied_resp_status_code content $policy_denied_resp_body Connection Close
             ACCESS::session remove
         }
         default {
             ACCESS::respond $policy_fallback_resp_status_code content $policy_fallback_resp_body Connection Close
             ACCESS::session remove
         }
         }
         
         unset user_key
     }
}

rule _sys_APM_Citrix {
    nowrite nodelete
    when RULE_INIT {
        set static::tmm_apm_pnagent_url "/Citrix/PNAgent/config.xml"
        set static::tmm_apm_ICA_key "TMM_APM_ICAKEY"
    }
    when CLIENT_ACCEPTED {
        TCP::collect 7
    }
    when CLIENT_DATA {
        # Disable SSL if it's HTTP CONNECT request
        if { [TCP::payload 7] equals "CONNECT" } {
            SSL::disable
        }
        TCP::release
    }
    when CLIENTSSL_DATA {
        binary scan [SSL::payload] c socksver
        if { $socksver != 5 } {
            SSL::release
            return
        }
        SSL::payload replace 0 [SSL::payload length] {}
        if { [info exists socks_connect] } {
            SSL::respond [binary format H2H2H2H2H2H2H2H2H2H2 05 00 00 01 00 00 00 00 00 00]
            SSL::release
        } else {
            set socks_connect {}
            SSL::respond [binary format H2H2 05 00]
            SSL::collect
        }
    }
    when HTTP_REQUEST {
        set tmm_apm_host [HTTP::host]
        set tmm_apm_vip  "$tmm_apm_host:[TCP::local_port clientside]"
        set tmm_apm_uri_path [HTTP::path]
        set tmm_apm_user_agent [HTTP::header "User-Agent"]
        set tmm_apm_http_method [HTTP::method]
        set tmm_apm_session_id ""
        set tmm_apm_citrix_receiver_auth 0
        set tmm_apm_citrix_pnagent_auth  0
        set tmm_apm_citrix_ica_patching  0

        log -noname accesscontrol.local1.debug "01490000:7: Request [HTTP::request]"

        if { [HTTP::cookie exists "MRHSession"] && [ACCESS::session exists [HTTP::cookie "MRHSession"]] } {
            set tmm_apm_session_id [HTTP::cookie "MRHSession"]
        }

        if { $tmm_apm_uri_path equals "/ipad" } {
            set AD_only "citrixreceiver://createprofile/?s=$tmm_apm_host&pname=Profile-$tmm_apm_host&gw=1&gwt=2&gwa=1"
            set RSA_only "citrixreceiver://createprofile/?s=$tmm_apm_host&pname=Profile-$tmm_apm_host&gw=1&gwt=2&gwa=2"
            set AD_RSA "citrixreceiver://createprofile/?s=$tmm_apm_host&pname=Profile-$tmm_apm_host&gw=1&gwt=2&gwa=3"
            HTTP::respond 200 content "<html><h2><a href=\"$AD_only\">Click here for domain only auth</a><br><a href=\"$RSA_only\">Click here for RSA only</a><br><a href=\"$AD_RSA\">Click here for Two-factor auth</a></h2></html>"
            return
        }

        if { ($tmm_apm_user_agent contains "CitrixReceiver") and ($tmm_apm_uri_path equals "/cgi/login") } {
            set tmm_apm_citrix_receiver_auth 1
            HTTP::cookie remove MRHSession
        } elseif {
            ($tmm_apm_user_agent contains "PNAMAIN") or
            ($tmm_apm_user_agent contains "PNAMain") or
            ($tmm_apm_user_agent contains "pnamain") or
            ($tmm_apm_user_agent contains "Dazzle") or
            ($tmm_apm_user_agent contains "Darwin") } {
                set tmm_apm_citrix_pnagent_auth 1
        }

        if { $tmm_apm_http_method equals "CONNECT" } {
            if { ![HTTP::header exists "Proxy-Authorization"] } {
                HTTP::respond 407 Proxy-Authenticate "Basic realm=\"123\""
                return
            }
            scan [HTTP::header "Proxy-Authorization"] "%s%s" tmp authstr
            scan [expr { [string length $authstr] } / 4.0 ] "%d.%d" quotient remainder
            if { $remainder != "0" } {
                if { [regsub -all {(A=)} $authstr = newstring] > 0 } {
                    set authstr $newstring
                }
            }
            set ticket [string map {: ""} [b64decode $authstr]]
            set encKey [table lookup $static::tmm_apm_ICA_key]
            if { $encKey == "" } {
                log -noname accesscontrol.local1.error "01490000:3: No ICA encryption key found!"
                return
            }
            scan [AES::decrypt $encKey [b64decode $ticket]] "%32s-%d.%d.%d.%d-%d" apm_session ip1 ip2 ip3 ip4 port
            set ip "$ip1.$ip2.$ip3.$ip4"
            if { ![ACCESS::session exists $apm_session] } {
                HTTP::respond 407 Proxy-Authenticate "Basic realm=\"123\""
                return
            }
            log -noname accesscontrol.local1.debug "01490000:7: Request for citrix resource received from session: $apm_session"
            SSL::disable serverside
            node $ip $port
            TCP::respond "HTTP/1.0 200 Connection established\r\n\r\n"
            HTTP::disable discard
            SSL::enable
            SSL::collect
        }

        if { $tmm_apm_user_agent contains "CitrixReceiver" } {
            # store detection
            if { $tmm_apm_uri_path equals "/vpn" } {
                HTTP::respond 302 Location "/vpn/index.html"
                return
            }
            elseif { $tmm_apm_uri_path equals "/vpn/index.html" }
            {
                HTTP::respond 200 content "/vpn/"
                return
            }                
        }

        if { (($tmm_apm_session_id == "") && ($tmm_apm_citrix_pnagent_auth == 1)) or ($tmm_apm_citrix_receiver_auth == 1) } {
            HTTP::header insert "clientless-mode" 1
            HTTP::header insert "username" ""
            HTTP::header insert "password" ""
            if { [string equal $tmm_apm_uri_path $static::tmm_apm_pnagent_url] } {
                ACCESS::disable
                return
            }
            if { ![info exists tmm_apm_citrix_username] && [HTTP::header exists "Content-Length"] } {
                HTTP::collect [HTTP::header Content-Length]
            }
        }
    }

    when HTTP_REQUEST_DATA {
        if { ($tmm_apm_citrix_pnagent_auth != 1) && ($tmm_apm_citrix_receiver_auth != 1) } {
            return
        }
        set payload [HTTP::payload]
        if { $tmm_apm_citrix_receiver_auth == 1 } {
            log -noname accesscontrol.local1.debug "01490000:7: Parsing credentials for Citrix receiver"

            set tmm_apm_citrix_username [URI::decode [URI::query "?$payload" "login"] ]
            set tmm_apm_citrix_password [URI::decode [URI::query "?$payload" "passwd"] ]
            set tmm_apm_citrix_password1 [URI::decode [URI::query "?$payload" "passwd1"] ]

            HTTP::header replace "username" $tmm_apm_citrix_username
            HTTP::header replace "password" $tmm_apm_citrix_password
            HTTP::payload replace 0 [HTTP::payload length] {}
            HTTP::release
        } elseif { ($tmm_apm_citrix_pnagent_auth == 1) } {
            log -noname accesscontrol.local1.debug "01490000:7: Parsing credentials for Citrix PNAgent"
            set tmm_apm_citrix_username  ""
            set tmm_apm_citrix_password  ""
            set tmm_apm_disp_sess_id [string range $tmm_apm_session_id 24 32]

            if { [regexp {<UserName>([^<]+)</UserName>} $payload dummy tmm_apm_citrix_username] == 0 || $tmm_apm_citrix_username == "" } {
                log -noname accesscontrol.local1.error "01490000:3: $tmm_apm_disp_sess_id: Username not found in the PNAgent POST body"
                unset tmm_apm_citrix_username 
                HTTP::respond 500
                return
            }

            # convert UTF-8 username into internal string representation (Unicode)
            # better use fconfigure here, but it is disabled...
            binary scan $tmm_apm_citrix_username c* input
            set input_len [llength $input]
            set username ""
            for { set j 0 } { $j < $input_len } { incr j }
            {
                set byte1 [expr [lindex $input $j] & 0xFF]
                if { $byte1 < 128 } {
                    append username [format %c $byte1]
                }
                elseif { ($byte1 > 191) && ($byte1 < 224) } {
                    set byte2 [expr [lindex $input [expr $j+1]] & 0xFF]
                    append username [format %c [expr (($byte1 & 31) << 6) | ($byte2 & 63) ]]
                    incr j 1
                }
                elseif { ($byte1 > 223) && ($byte1 < 240) } {
                    set byte2 [expr [lindex $input [expr $j+1]] & 0xFF]
                    set byte3 [expr [lindex $input [expr $j+2]] & 0xFF]
                    append username [format %c [expr (($byte1 & 15) << 12) | (($byte2 & 63) << 6) | ($byte3 & 63) ]]
                    incr j 2
                }
                else {
                    log -noname accesscontrol.local1.error "01490000:3: $tmm_apm_disp_sess_id: Bad UTF-8 encoding of username"
                    return
                }
            }
            set tmm_apm_citrix_username $username

            if { [regexp {<Password[^>]+>([^<]+)</Password>} $payload dummy tmm_apm_citrix_password] == 0 || $tmm_apm_citrix_password == "" } {
                log -noname accesscontrol.local1.error "01490000:3: $tmm_apm_disp_sess_id: Password not found in the PNAgent POST body"
                unset tmm_apm_citrix_username
                HTTP::respond 500
                return
            }
            
            binary scan $tmm_apm_citrix_password c* input
            set input_len [llength $input]
            set password ""
            set ctx2 0
            for { set j 0 } { $j < $input_len } { incr j 2 }
            {
                set ctx1 [expr (([lindex $input $j] - 0x41) << 4) + ([lindex $input [expr $j+1]] - 0x41)]
                set lo_byte [expr $ctx1 ^ $ctx2 ^ 0xA5]
                set ctx2 $ctx1
                incr j 2

                set ctx1 [expr (([lindex $input $j] - 0x41) << 4) + ([lindex $input [expr $j+1]] - 0x41)]
                set hi_byte [expr $ctx1 ^ $ctx2 ^ 0xA5]
                set ctx2 $ctx1
                
                append password [format %c [expr ($hi_byte << 8) + $lo_byte]]
            }
            set tmm_apm_citrix_password $password

            HTTP::header replace "username" $tmm_apm_citrix_username
            HTTP::header replace "password" $tmm_apm_citrix_password
            HTTP::release
        }
    }

    when HTTP_RESPONSE {
        if { [HTTP::header Content-Type] contains "application/x-ica" } {
            set tmm_apm_citrix_ica_patching 1
            HTTP::collect [HTTP::header Content-Length]
        }
    }

    when HTTP_RESPONSE_DATA {
        if { $tmm_apm_citrix_ica_patching == 1 } {
            log -noname accesscontrol.local1.debug "01490000:7: ICA file patching"
            set payload [HTTP::payload]
            if { ($tmm_apm_user_agent contains "CitrixReceiver") } {
                set payload [ regsub {CGPAddress[^\n]+\n} $payload {} ]
            }
            regexp -line {Address=([^\r\n]+)} $payload dummy CtxAddrPort
            set CtxAddr [lindex [split $CtxAddrPort ":"] 0]
            set CtxPort [lindex [split $CtxAddrPort ":"] 1]
            regexp -line {CGPAddress=([^\r\n]+)} $payload dummy CGPAddrPort
            if { [info exists CGPAddrPort] } {
                set CtxPort [lindex [split $CGPAddrPort ":"] 1]
            }

            set payload [ regsub -all -nocase -line {^(Proxy[^=]+|SSLEnable|SSLProxyHost|DoNotUseDefaultCSL|BrowserProtocol|HTTPBrowserAddress|LocHTTPBrowserAddress)=.*\n} $payload {} ]

            set encKey [table lookup $static::tmm_apm_ICA_key]
            if { $encKey equals "" } {
                set encKey [table add $static::tmm_apm_ICA_key [AES::key 128] indefinite]
            }
            set ticket [b64encode [AES::encrypt $encKey "$tmm_apm_session_id-$CtxAddr-$CtxPort"]]
            set tlen [string length $ticket]
            set ticket1 [string range $ticket 0 [expr { $tlen / 2 }]]
            set ticket2 [string range $ticket [expr { $tlen / 2 + 1}] $tlen]

            set payload [ regsub {\[WFClient\]} $payload "&\r\nProxyType=Secure\r\nProxyHost=$tmm_apm_vip\r\nProxyUsername=$ticket1\r\nProxyPassword=$ticket2" ]
            
            set payload [ regsub -line {^Address=.*\n} $payload "Address=$tmm_apm_host\r\nSSLEnable=On\r\nBrowserProtocol=HTTPonTCP\r\nHTTPBrowserAddress=!\r\nLocHttpBrowserAddress=!\r\n" ]

            HTTP::payload replace 0 [HTTP::payload length] $payload
        }
    }

    when ACCESS_SESSION_STARTED {
        if { ($tmm_apm_citrix_receiver_auth == 0) or ![info exists tmm_apm_citrix_password1] } {
            return
        }
        ACCESS::session data set "session.logon.last.password1" $tmm_apm_citrix_password1
    }

    when ACCESS_POLICY_COMPLETED {
        if { $tmm_apm_citrix_receiver_auth == 0 } {
            return
        }
        if { [info exists tmm_apm_citrix_username] } {
            unset tmm_apm_citrix_username
        }
        if { [info exists tmm_apm_citrix_password] } {
            unset tmm_apm_citrix_password
        }
        if { [info exists tmm_apm_citrix_password1] } {
            unset tmm_apm_citrix_password1
        }
        ACCESS::session data set "session.logon.last.password1" ""

        set sid [ACCESS::session data get session.keydb]
        set result [ACCESS::policy result]
        if { $result equals "allow" } {
            set resp "<html><head><META HTTP-EQUIV=\"REFRESH\" CONTENT=\"0; URL=$static::tmm_apm_pnagent_url\"></head><body></body></html>"
            ACCESS::respond 200 content $resp Set-Cookie "MRHSession=$sid;path=/;secure" Set-Cookie "NSC_AAAC=123;path=/;secure"
        }
    }
}

rule _sys_APM_ExchangeSupport_helper {
    nowrite nodelete
    # The purpose of this iRule is for help the main virtual for the timing of the HTTP request retry
    # during the SSO process for OutlookAnywhere protocol request which has a Content-Length value of 1GB.

    when HTTP_REQUEST {
        #  Waiting for the first chunk of data.
        HTTP::collect 1
    }

    when HTTP_REQUEST_DATA {
        # Respond 401 and close the connection once we received the data.
        HTTP::respond 401 WWW-Authenticate NTLM Connection Close
    }
}

rule _sys_APM_ExchangeSupport_main {
    nowrite nodelete
    # Global variables
    # static::POLICY_RESULT_CACHE_AUTHFAILED
    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.
    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.
    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.
    # Responses
    # On denied result
    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.
    #     In those cases, please use ACCESS::respond command.
    #     The following is the syntax of ACCESS::respond
    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]
    #     e.g. ACCESS::respond 401 content "Error: Denied" WWW-Authenticate "basic realm=\"f5.com\"" Connection Close
    when RULE_INIT {
        # Please set the following global variables for customized responses.
        set static::actsync_401_http_body "<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        # Second Virtual Server name for 401 NTLM responder
        set static::ACCESS_SECOND_VIRTUAL_NAME        "_ACCESS_401_NTLM_responder_HTTPS"

        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_AUTHFAILED                 "policy_authfailed"
        # The request with huge content length can not be used for starting ACCESS session.
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session. The following value is used for Outlook Anywhere.
        set static::OA_MAGIC_CONTENT_LEN              1073741824

        # Similar with OutlookAnywhere case, ACCESS can not use the request which is
        # larger then following size. This becomes an issue with application that using
        # Exchange Web Service as its main protocol such as Mac OS X applications
        # (e.g. Mail app, Microsoft Entourage, etc)
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session.
        set static::FIRST_BIG_POST_CONTENT_LEN        640000

        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.
        set static::EWS_BKEND_BASIC_AUTH              0
        # Set it into 1 if the backend RPC-over-HTTP handler accepts HTTP Basic Authentication.
        set static::RPC_OVER_HTTP_BKEND_BASIC_AUTH    0
        # The following variable controls the polling mechanism.
        set static::POLICY_RESULT_POLL_INTERVAL       250
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600

        # Set this global variable to 1 for caching authentication failure
        # Useful for avoiding account locked out.
        set static::POLICY_RESULT_CACHE_AUTHFAILED    0

        # set this global variable to set alternative timeout for particular session
        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120

        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"


        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/"

        log -noname accesscontrol.local1.debug "01490000:7: RPC_OVER_HTTP_BKEND_BASIC_AUTH = $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH"
        log -noname accesscontrol.local1.debug "01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH"
    }
    when ACCESS_ACL_ALLOWED {
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]"

        if { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 }  {
            if { $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH == 0 } {
                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Use this virtual $static::ACCESS_SECOND_VIRTUAL_NAME just once. Will be reset back after disconnection."
                    use virtual $static::ACCESS_SECOND_VIRTUAL_NAME
                }
               log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Remove HTTP Auth header"
               HTTP::header remove Authorization
            }
        }
        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been
        # already authenticated if there is a HTTP Basic Auth in the request.
        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {
            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header"
                HTTP::header remove Authorization
            }
         }
    }

    when HTTP_REQUEST {
        # Quickly return for internal retry on clientless mode.
        if { [ info exists f_clientless_mode ] && $f_clientless_mode == 1 } {
            set f_clientless_mode 0
            return
        }

        set http_path                       [ string tolower [HTTP::path] ]
        set f_clientless_mode               0
        set f_alt_inactivity_timeout        0
        set f_rpc_over_http                 0
        set f_exchange_web_service          0
        set f_auto_discover                 0
        set f_activesync                    0
        set f_offline_address_book          0
        set f_availability_service          0

        #  Here put appropriate pool when necessary.
        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            # Supports for RPC over HTTP. (Outlook Anywhere)
            set f_rpc_over_http 1
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
        }
        "/autodiscover/autodiscover.xml" {
            # Supports for Auto Discover protocol.
            set f_auto_discover 1
            # This request does not require long inactivity timeout.
            # Don't use this for now
            set f_alt_inactivity_timeout 0
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
        }
        "/microsoft-server-activesync" {
            # Supports for ActiveSync
            set f_activesync 1
        }
        "/oab/*" {
            # Supports for Offline Address Book
            set f_offline_address_book 1
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/ews/*" {
            # Support for Exchange Web Service
            # Outlook's Availability Service borrows this protocol.
            set f_exchange_web_service 1
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
        }
        "/as/*" {
            # Support for Availability Service.
            # do nothing for now. (Untested)
            set f_availability_service 1
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
        }
        default {
            return
        }
        }

        set f_reqside_set_sess_id           0
        set f_has_cookie                    0
        set f_valid_cookie                  0
        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set src_ip                          [IP::remote_addr]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        set auth_info_b64enc                ""

        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } { 
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method: $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP: $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len"

        # First, do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            set f_has_cookie 1
            if { [ACCESS::session exists -state_allow $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                set f_valid_cookie 1
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        set http_hdr_auth [HTTP::header Authorization]
        if { [ string first Basic $http_hdr_auth ] == -1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header"
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX No/Empty Auth header"
            if { $f_has_cookie == 1 } {
                # clean up the cookie
                if { $f_valid_cookie == 0 } {
                    HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                }
                # Do nothing if we have a valid MRHSession cookie.
            } else {
                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Connection Close
            }
            return
        }

        set apm_username [HTTP::username]
        set apm_password [HTTP::password]
        if { [ info exists f_no_include_uagent ] && $f_no_include_uagent == 1 } {
            binary scan [md5 "$apm_password$src_ip"] H* user_hash
        } else {
            binary scan [md5 "$apm_password$http_hdr_uagent$src_ip"] H* user_hash
        }
        set user_key    "$apm_username.$user_hash"
        unset user_hash

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX apm_username: $apm_username"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key = $user_key"

        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
            # Optimization for EWS client since many of them supported cookie.
            if { $f_has_cookie == 1 && $f_valid_cookie == 1 } {
                return
            }
        }

        set f_release_request 0
        set apm_cookie_list [ ACCESS::uuid getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            HTTP::cookie insert name MRHSession value [ lindex $apm_cookie_list 0 ]
            set f_release_request 1
        }

        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {
            set f_oa_magic_content_len 1
        }

        set f_sleep_here 0
        set retry 1

        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len"

            # This is also going to touch the table entry timer.
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME"

            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key]
            if { $apm_cookie != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie"

                # Accessing SessionDB is not that cheap. Here we are trying to check known value.
                if { $apm_cookie == "policy_authfailed" || $apm_cookie == "policy_inprogress"} {
                    # Do nothing
                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync"
                    # Table value is out of sync. Ignores it.
                    set apm_cookie ""
                }
            }

            switch $apm_cookie {
            "" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"

                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable
                    # for creating new session since 1G content-length is intended for client to upload
                    # the data when needed.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len"
                    set f_sleep_here 1
                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                    # Here we are getting large EWS request, which can't be used for starting new session
                    # in clientless-mode. Have it here waiting for next smaller one.
                    # We are holding the request here in HTTP filter, and HTTP filter automatically
                    # clamping down the TCP window when necessary.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request"
                    set f_sleep_here 1
                } else {
                   set apm_cookie               "policy_inprogress"
                   set f_reqside_set_sess_id    1
                   set f_release_request        1
                }
            }
            "policy_authfailed" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED"
                HTTP::respond 401 content  $static::actsync_401_http_body
                set f_release_request 1
            }
            "policy_inprogress" {
                set f_sleep_here 1
            }
            default {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie"
                HTTP::header insert Cookie "MRHSession=$apm_cookie"
                set f_release_request 1
            }
            }

            if { $f_reqside_set_sess_id == 1 } {
                set f_reqside_set_sess_id 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                set f_clientless_mode 1
                HTTP::header insert "clientless-mode" 1
                HTTP::header insert "username" $apm_username
                HTTP::header insert "password" $apm_password
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT
            }

            if { $f_sleep_here == 1 } {
                set f_sleep_here 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
                after  $static::POLICY_RESULT_POLL_INTERVAL
            }

            incr retry
        }

        if { $f_release_request == 0 && $retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [expr $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL] ms. Close connection for $http_method $http_uri"

            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1

            if { [ info exists f_activesync ] && $f_activesync == 1 } {
                ACCESS::session data set "session.user.microsoft-activesync" 1
            }
            if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
            if { [ info exists f_availability_service ] && $f_availability_service == 1 } {
                ACCESS::session data set "session.user.microsoft-availabilityservice" 1
            }
            if { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {
                ACCESS::session data set "session.user.microsoft-rpcoverhttp" 1
            }
            if { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {
                ACCESS::session data set "session.user.microsoft-offlineaddressbook" 1
            }
            if { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
                ACCESS::session data set "session.user.microsoft-exchangewebservice" 1
            }
        }
        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {
            ACCESS::session data set "session.inactivity_timeout"  $static::POLICY_ALT_INACTIVITY_TIMEOUT
        }
    }

    when HTTP_RESPONSE {
        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 && [ info exists f_clientless_mode ] && $f_clientless_mode == 0 } {
            set content_len [ HTTP::header Content-Length ]
            if {  $content_len > 0 } {
                HTTP::collect $content_len
            }
        }
    }
    when HTTP_RESPONSE_DATA {
        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 && [ info exists f_clientless_mode ] && $f_clientless_mode == 0 } {
            if { [ regsub -line {<AuthPackage>Ntlm</AuthPackage>} [ HTTP::payload ] {<AuthPackage>Basic</AuthPackage>} payload ] != 0 } {
                HTTP::payload replace 0 $content_len $payload
            }
        }
    }
    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session data get session.keydb ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        set inactivity_timeout [ACCESS::session data get "session.inactivity_timeout"]
        set max_sess_timeout [ACCESS::session data get "session.max_session_timeout"]
        if { $max_sess_timeout == "" } {
             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT
        }

        switch $policy_result {
        "allow" {
            # We depends on this table record self-cleanup capability in order to
            # indirectly sync with session DB.
            set user_key_value $sid

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"
        }
        "deny" {
            # When necessary the admin here can check appropriate session variable
            # and decide what response more appropriate then this default response.
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {
                set user_key_value  $static::POLICY_AUTHFAILED
            } else {
                set f_delete_session  1
            }
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }
        if { $user_key_value != "" } {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME"

           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout
        } else {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME"

           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
        }

        if { $f_delete_session == 1 } {
           ACCESS::session remove
           set f_delete_session 0
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
}

rule _sys_APM_ExchangeSupport_OA_BasicAuth {
    nowrite nodelete
    # Global variables
    # static::POLICY_RESULT_CACHE_AUTHFAILED
    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.
    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.
    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.
    # Responses
    # On denied result
    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.
    #     In those cases, please use ACCESS::respond command.
    #     The following is the syntax of ACCESS::respond
    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]
    #     e.g. ACCESS::respond 401 content "Error: Denied" WWW-Authenticate "basic realm=\"f5.com\"" Connection Close
    when RULE_INIT {
        # Please set the following global variables for customized responses.
        set static::actsync_401_http_body "<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        # Second Virtual Server name for 401 NTLM responder
        set static::ACCESS_SECOND_VIRTUAL_NAME        "_ACCESS_401_NTLM_responder_HTTPS"

        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_AUTHFAILED                 "policy_authfailed"
        # The request with huge content length can not be used for starting ACCESS session.
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session. The following value is used for Outlook Anywhere.
        set static::OA_MAGIC_CONTENT_LEN              1073741824

        # Similar with OutlookAnywhere case, ACCESS can not use the request which is
        # larger then following size. This becomes an issue with application that using
        # Exchange Web Service as its main protocol such as Mac OS X applications
        # (e.g. Mail app, Microsoft Entourage, etc)
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session.
        set static::FIRST_BIG_POST_CONTENT_LEN        640000

        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.
        set static::EWS_BKEND_BASIC_AUTH              0
        # The following variable controls the polling mechanism.
        set static::POLICY_RESULT_POLL_INTERVAL       250
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600

        # Set this global variable to 1 for caching authentication failure
        # Useful for avoiding account locked out.
        set static::POLICY_RESULT_CACHE_AUTHFAILED    0

        # set this global variable to set alternative timeout for particular session
        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120

        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"


        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/"

        log -noname accesscontrol.local1.debug "01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH"
    }
    when ACCESS_ACL_ALLOWED {
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]"

        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been
        # already authenticated if there is a HTTP Basic Auth in the request.
        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {
            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header"
                HTTP::header remove Authorization
            }
         }
    }

    when HTTP_REQUEST {
        # Quickly return for internal retry on clientless mode.
        if { [ info exists f_clientless_mode ] && $f_clientless_mode == 1 } {
            set f_clientless_mode 0
            return
        }

        set http_path                       [ string tolower [HTTP::path] ]
        set f_clientless_mode               0
        set f_alt_inactivity_timeout        0
        set f_rpc_over_http                 0
        set f_exchange_web_service          0
        set f_auto_discover                 0
        set f_activesync                    0
        set f_offline_address_book          0
        set f_availability_service          0

        #  Here put appropriate pool when necessary.
        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            # Supports for RPC over HTTP. (Outlook Anywhere)
            set f_rpc_over_http 1
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
        }
        "/autodiscover/autodiscover.xml" {
            # Supports for Auto Discover protocol.
            set f_auto_discover 1
            # This request does not require long inactivity timeout.
            # Don't use this for now
            set f_alt_inactivity_timeout 0
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
        }
        "/microsoft-server-activesync" {
            # Supports for ActiveSync
            set f_activesync 1
        }
        "/oab/*" {
            # Supports for Offline Address Book
            set f_offline_address_book 1
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/ews/*" {
            # Support for Exchange Web Service
            # Outlook's Availability Service borrows this protocol.
            set f_exchange_web_service 1
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
        }
        "/as/*" {
            # Support for Availability Service.
            # do nothing for now. (Untested)
            set f_availability_service 1
            # Does not include User-Agent into hash generation
            set f_no_include_uagent  1
        }
        default {
            return
        }
        }

        set f_reqside_set_sess_id           0
        set f_has_cookie                    0
        set f_valid_cookie                  0
        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set src_ip                          [IP::remote_addr]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        set auth_info_b64enc                ""

        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } { 
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method: $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP: $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len"

        # First, do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            set f_has_cookie 1
            if { [ACCESS::session exists -state_allow $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                set f_valid_cookie 1
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        set http_hdr_auth [HTTP::header Authorization]
        if { [ string first Basic $http_hdr_auth ] == -1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header"
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX No/Empty Auth header"
            if { $f_has_cookie == 1 } {
                # clean up the cookie
                if { $f_valid_cookie == 0 } {
                    HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                }
                # Do nothing if we have a valid MRHSession cookie.
            } else {
                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Connection Close
            }
            return
        }

        set apm_username [HTTP::username]
        set apm_password [HTTP::password]
        if { [ info exists f_no_include_uagent ] && $f_no_include_uagent == 1 } {
            binary scan [md5 "$apm_password$src_ip"] H* user_hash
        } else {
            binary scan [md5 "$apm_password$http_hdr_uagent$src_ip"] H* user_hash
        }
        set user_key    "$apm_username.$user_hash"
        unset user_hash

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX apm_username: $apm_username"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key = $user_key"

        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
            # Optimization for EWS client since many of them supported cookie.
            if { $f_has_cookie == 1 && $f_valid_cookie == 1 } {
                return
            }
        }

        set f_release_request 0
        set apm_cookie_list [ ACCESS::uuid getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            HTTP::cookie insert name MRHSession value [ lindex $apm_cookie_list 0 ]
            set f_release_request 1
        }

        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {
            set f_oa_magic_content_len 1
        }

        set f_sleep_here 0
        set retry 1

        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len"

            # This is also going to touch the table entry timer.
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME"

            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key]
            if { $apm_cookie != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie"

                # Accessing SessionDB is not that cheap. Here we are trying to check known value.
                if { $apm_cookie == "policy_authfailed" || $apm_cookie == "policy_inprogress"} {
                    # Do nothing
                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync"
                    # Table value is out of sync. Ignores it.
                    set apm_cookie ""
                }
            }

            switch $apm_cookie {
            "" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"

                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable
                    # for creating new session since 1G content-length is intended for client to upload
                    # the data when needed.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len"
                    set f_sleep_here 1
                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                    # Here we are getting large EWS request, which can't be used for starting new session
                    # in clientless-mode. Have it here waiting for next smaller one.
                    # We are holding the request here in HTTP filter, and HTTP filter automatically
                    # clamping down the TCP window when necessary.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request"
                    set f_sleep_here 1
                } else {
                   set apm_cookie               "policy_inprogress"
                   set f_reqside_set_sess_id    1
                   set f_release_request        1
                }
            }
            "policy_authfailed" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED"
                HTTP::respond 401 content  $static::actsync_401_http_body
                set f_release_request 1
            }
            "policy_inprogress" {
                set f_sleep_here 1
            }
            default {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie"
                HTTP::header insert Cookie "MRHSession=$apm_cookie"
                set f_release_request 1
            }
            }

            if { $f_reqside_set_sess_id == 1 } {
                set f_reqside_set_sess_id 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                set f_clientless_mode 1
                HTTP::header insert "clientless-mode" 1
                HTTP::header insert "username" $apm_username
                HTTP::header insert "password" $apm_password
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT
            }

            if { $f_sleep_here == 1 } {
                set f_sleep_here 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
                after  $static::POLICY_RESULT_POLL_INTERVAL
            }

            incr retry
        }

        if { $f_release_request == 0 && $retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [expr $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL] ms. Close connection for $http_method $http_uri"

            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1

            if { [ info exists f_activesync ] && $f_activesync == 1 } {
                ACCESS::session data set "session.user.microsoft-activesync" 1
            }
            if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
            if { [ info exists f_availability_service ] && $f_availability_service == 1 } {
                ACCESS::session data set "session.user.microsoft-availabilityservice" 1
            }
            if { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {
                ACCESS::session data set "session.user.microsoft-rpcoverhttp" 1
            }
            if { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {
                ACCESS::session data set "session.user.microsoft-offlineaddressbook" 1
            }
            if { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
                ACCESS::session data set "session.user.microsoft-exchangewebservice" 1
            }
        }
        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {
            ACCESS::session data set "session.inactivity_timeout"  $static::POLICY_ALT_INACTIVITY_TIMEOUT
        }
    }

    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session data get session.keydb ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        set inactivity_timeout [ACCESS::session data get "session.inactivity_timeout"]
        set max_sess_timeout [ACCESS::session data get "session.max_session_timeout"]
        if { $max_sess_timeout == "" } {
             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT
        }

        switch $policy_result {
        "allow" {
            # We depends on this table record self-cleanup capability in order to
            # indirectly sync with session DB.
            set user_key_value $sid

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"
        }
        "deny" {
            # When necessary the admin here can check appropriate session variable
            # and decide what response more appropriate then this default response.
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {
                set user_key_value  $static::POLICY_AUTHFAILED
            } else {
                set f_delete_session  1
            }
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }
        if { $user_key_value != "" } {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME"

           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout
        } else {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME"

           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
        }

        if { $f_delete_session == 1 } {
           ACCESS::session remove
           set f_delete_session 0
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
}

profile tcp tcp-wan-optimized {
    defaults from tcp
    selective acks enable
    nagle enable
    proxy buffer low 131072
    proxy buffer high 131072
    send buffer 65535
    recv window 65535
}

profile tcp tcp-lan-optimized {
    bandwidth delay disable
    nagle disable
    slow start disable
    ack on push enable
    proxy buffer low 98304
    proxy buffer high 131072
    send buffer 65535
    recv window 65535
}

profile tcp tcp-cell-optimized {
    defaults from tcp
    ecn enable
    limited transmit enable
    rfc1323 enable
    selective acks enable
    proxy buffer low 131072
    proxy buffer high 131072
    send buffer 131072
    recv window 131072
}

profile tcp wom-tcp-lan-optimized {
   defaults from tcp-lan-optimized
   delayed acks disable
   proxy mss disable
   slow start disable
   bandwidth delay disable
   nagle enable
   idle timeout 600
   cmetrics cache disable
}

profile tcp wom-tcp-wan-optimized {
   defaults from tcp-wan-optimized
   selective nack enable
   delayed acks disable
   proxy mss disable
   slow start disable
   bandwidth delay disable
   nagle enable
   proxy buffer low 131072
   proxy buffer high 196608
   idle timeout 600
   send buffer 458752
   recv window 458752
   pkt loss ignore burst 8
   pkt loss ignore rate 10000
   zero window timeout 300000
}

profile udp udp_gtm_dns {
    defaults from udp
    idle timeout 5
    datagram lb enable
}

profile http http-wan-optimized-compression-caching {
    defaults from http
    oneconnect transformations enable
    compress enable 
    compress buffer size 131072
    compress vary header enable
    compress http 1.0 enable
    compress gzip memory level 16k
    compress gzip window size 64k
    compress gzip level 1
    response selective chunk
    ramcache enable
    ramcache size 10mb
    ramcache max age 86400
    ramcache min object size 0
    ramcache max object size 2000000
}

profile http http-wan-optimized-compression {
    defaults from http
    oneconnect transformations enable
    compress enable
    compress buffer size 131072
    compress vary header enable
    compress http 1.0 enable
    compress gzip memory level 16k
    compress gzip window size 64k
    compress gzip level 1
    response selective chunk
}

profile http http-lan-optimized-caching {
    defaults from http
    oneconnect transformations enable
    ramcache enable
    ramcache size 10mb
    ramcache max age 86400
    ramcache min object size 0
    ramcache max object size 2000000
}

profile http http-acceleration {
    defaults from http
    ramcache enable
    ramcache size 100mb
    ramcache min object size 0
    ramcache max object size 4194304
    ramcache ignore client cache control all
}

profile serverssl wom-default-serverssl {
    defaults from serverssl
    key "default.key"
    cert "default.crt"
    mode disable
}

profile serverssl serverssl-insecure-compatible {
    defaults from serverssl
    ciphers "!SSLv2:!EXPORT:!DH:RSA+RC4:RSA+AES:RSA+DES:RSA+3DES:@SPEED"
    secure renegotiation request
}

profile clientssl wom-default-clientssl {
    defaults from clientssl
    nonssl enable
}

profile clientssl clientssl-insecure-compatible {
    defaults from clientssl
    ciphers "!SSLv2:ALL:!DH:!ADH:!EDH:@SPEED"
    renegotiate enable
    secure renegotiation request
}

drop policy red { 
    type red 
}

drop policy fred {
    type fred
}
drop policy tail {
    type tail
}

shaping queue sfq {
    type sfq
}

shaping queue pfifo {
    type pfifo
}

class default_accept_language {
    "en"
    "zh-cn"
    "zh-tw"
    "ja"
}

profile isession isession {
}

profile isession isession-encrypt {
    encrypt enable
}

profile isession isession-mapi {
    defaults from isession
}

profile access access {
    default language "en"
    class accepted languages default_accept_language
}

profile cifs cifs {
}
# Log priority values:
# local1.debug    = 7
# local1.info     = 6
# local1.notice   = 5
# local1.warn     = 4
# local1.err      = 3
# local1.crit     = 2
# local1.alert    = 1
# local1.emerg    = 0

rule _sys_https_redirect {
    nowrite nodelete
    when HTTP_REQUEST {
       set host [HTTP::host]
       HTTP::respond 302 Location "https://$host/"
    }
}

profile mapi mapi {
    native compression disable
}
windows group policy _EC_Domain_XPSP2_Desktops_Template {
    description "Microsoft Enterprise Client Policy, for desktops and laptops."
}

profile passthruwocplugin passthruwocplugin {
}
windows group policy _SSLF_Domain_Template {
    description "Microsoft Specialized Security - Limited Functionality, for desktops and laptops."
}

drop policy red { 
    type red 
}

drop policy fred {
    type fred
}
windows group policy _Lightly_Managed_Template {
    description "Microsoft Common Usage (Light), for desktops and laptops."
}


windows group policy _Terminal_Services_Taskstation_Template {
    description "Terminal Services, for client terminal services."
}

windows group policy _Firewall_Settings_Template {
    description "Firewall Settings, for enabling the end user's firewall."
}

windows group policy _GLBA_Template {
    description "Based on the Gramm-Leach-Bliley Act (GLBA) standard."
}

windows group policy _HIPAA_Template {
    description "Based on the Health Insurance Portability and Accounting Act (HIPAA) standard."
}

windows group policy _PCI_Template {
    description "Based on the Payment Card Industry (PCI) Data Security Standards."
}
