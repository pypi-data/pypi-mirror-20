# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""Larch can be used to estimate discrete choice models."""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_core')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_core')
    _core = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_core', [dirname(__file__)])
        except ImportError:
            import _core
            return _core
        if fp is not None:
            try:
                _mod = imp.load_module('_core', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _core = swig_import_helper()
    del swig_import_helper
else:
    import _core
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x




def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)



from ._core import LarchError
from ._core import SQLiteError
from ._core import FacetError
from ._core import LarchCacheError
from ._core import ProvisioningError
from ._core import MatrixInverseError

class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _core.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _core.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _core.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _core.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _core.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _core.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _core.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _core.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _core.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _core.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _core.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _core.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _core.SHARED_PTR_DISOWN

import numpy
__default_array_type__ = numpy.ndarray



class IntVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _core.IntVector___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _core.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.IntVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _core.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _core.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _core.IntVector_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _core.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _core.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _core.IntVector_size(self)

    def swap(self, v: 'IntVector') -> "void":
        return _core.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _core.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _core.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _core.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _core.IntVector_rend(self)

    def clear(self) -> "void":
        return _core.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _core.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _core.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _core.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _core.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _core.IntVector_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _core.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.IntVector_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _core.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _core.IntVector_capacity(self)
    __swig_destroy__ = _core.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _core.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _core.DoubleVector___len__(self)

    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        return _core.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        return _core.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _core.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _core.DoubleVector_pop(self)

    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _core.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _core.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _core.DoubleVector_size(self)

    def swap(self, v: 'DoubleVector') -> "void":
        return _core.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _core.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _core.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _core.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _core.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _core.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _core.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _core.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _core.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _core.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _core.DoubleVector_back(self)

    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        return _core.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.DoubleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        return _core.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _core.DoubleVector_capacity(self)
    __swig_destroy__ = _core.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _core.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class ULongLongVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.ULongLongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.ULongLongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.ULongLongVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        return _core.ULongLongVector___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned long long >::difference_type', j: 'std::vector< unsigned long long >::difference_type') -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        return _core.ULongLongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.ULongLongVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned long long >::difference_type', j: 'std::vector< unsigned long long >::difference_type') -> "void":
        return _core.ULongLongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.ULongLongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        return _core.ULongLongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.ULongLongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        return _core.ULongLongVector_pop(self)

    def append(self, x: 'std::vector< unsigned long long >::value_type const &') -> "void":
        return _core.ULongLongVector_append(self, x)

    def empty(self) -> "bool":
        return _core.ULongLongVector_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        return _core.ULongLongVector_size(self)

    def swap(self, v: 'ULongLongVector') -> "void":
        return _core.ULongLongVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        return _core.ULongLongVector_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        return _core.ULongLongVector_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _core.ULongLongVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _core.ULongLongVector_rend(self)

    def clear(self) -> "void":
        return _core.ULongLongVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        return _core.ULongLongVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.ULongLongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        return _core.ULongLongVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_ULongLongVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned long long >::value_type const &') -> "void":
        return _core.ULongLongVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        return _core.ULongLongVector_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        return _core.ULongLongVector_back(self)

    def assign(self, n: 'std::vector< unsigned long long >::size_type', x: 'std::vector< unsigned long long >::value_type const &') -> "void":
        return _core.ULongLongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.ULongLongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.ULongLongVector_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned long long >::size_type') -> "void":
        return _core.ULongLongVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        return _core.ULongLongVector_capacity(self)
    __swig_destroy__ = _core.delete_ULongLongVector
    __del__ = lambda self: None
ULongLongVector_swigregister = _core.ULongLongVector_swigregister
ULongLongVector_swigregister(ULongLongVector)

class LongLongVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.LongLongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.LongLongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.LongLongVector___bool__(self)

    def __len__(self) -> "std::vector< long long >::size_type":
        return _core.LongLongVector___len__(self)

    def __getslice__(self, i: 'std::vector< long long >::difference_type', j: 'std::vector< long long >::difference_type') -> "std::vector< long long,std::allocator< long long > > *":
        return _core.LongLongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.LongLongVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< long long >::difference_type', j: 'std::vector< long long >::difference_type') -> "void":
        return _core.LongLongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.LongLongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long long >::value_type const &":
        return _core.LongLongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.LongLongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< long long >::value_type":
        return _core.LongLongVector_pop(self)

    def append(self, x: 'std::vector< long long >::value_type const &') -> "void":
        return _core.LongLongVector_append(self, x)

    def empty(self) -> "bool":
        return _core.LongLongVector_empty(self)

    def size(self) -> "std::vector< long long >::size_type":
        return _core.LongLongVector_size(self)

    def swap(self, v: 'LongLongVector') -> "void":
        return _core.LongLongVector_swap(self, v)

    def begin(self) -> "std::vector< long long >::iterator":
        return _core.LongLongVector_begin(self)

    def end(self) -> "std::vector< long long >::iterator":
        return _core.LongLongVector_end(self)

    def rbegin(self) -> "std::vector< long long >::reverse_iterator":
        return _core.LongLongVector_rbegin(self)

    def rend(self) -> "std::vector< long long >::reverse_iterator":
        return _core.LongLongVector_rend(self)

    def clear(self) -> "void":
        return _core.LongLongVector_clear(self)

    def get_allocator(self) -> "std::vector< long long >::allocator_type":
        return _core.LongLongVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.LongLongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< long long >::iterator":
        return _core.LongLongVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_LongLongVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< long long >::value_type const &') -> "void":
        return _core.LongLongVector_push_back(self, x)

    def front(self) -> "std::vector< long long >::value_type const &":
        return _core.LongLongVector_front(self)

    def back(self) -> "std::vector< long long >::value_type const &":
        return _core.LongLongVector_back(self)

    def assign(self, n: 'std::vector< long long >::size_type', x: 'std::vector< long long >::value_type const &') -> "void":
        return _core.LongLongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.LongLongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.LongLongVector_insert(self, *args)

    def reserve(self, n: 'std::vector< long long >::size_type') -> "void":
        return _core.LongLongVector_reserve(self, n)

    def capacity(self) -> "std::vector< long long >::size_type":
        return _core.LongLongVector_capacity(self)
    __swig_destroy__ = _core.delete_LongLongVector
    __del__ = lambda self: None
LongLongVector_swigregister = _core.LongLongVector_swigregister
LongLongVector_swigregister(LongLongVector)

class StrVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.StrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.StrVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.StrVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _core.StrVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        return _core.StrVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.StrVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        return _core.StrVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.StrVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _core.StrVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.StrVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _core.StrVector_pop(self)

    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _core.StrVector_append(self, x)

    def empty(self) -> "bool":
        return _core.StrVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _core.StrVector_size(self)

    def swap(self, v: 'StrVector') -> "void":
        return _core.StrVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _core.StrVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _core.StrVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _core.StrVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _core.StrVector_rend(self)

    def clear(self) -> "void":
        return _core.StrVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _core.StrVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.StrVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _core.StrVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_StrVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _core.StrVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _core.StrVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _core.StrVector_back(self)

    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        return _core.StrVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.StrVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.StrVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        return _core.StrVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _core.StrVector_capacity(self)
    __swig_destroy__ = _core.delete_StrVector
    __del__ = lambda self: None
StrVector_swigregister = _core.StrVector_swigregister
StrVector_swigregister(StrVector)

class IntStringDict(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.IntStringDict_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.IntStringDict___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.IntStringDict___bool__(self)

    def __len__(self) -> "std::map< long long,std::string >::size_type":
        return _core.IntStringDict___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::mapped_type const &":
        return _core.IntStringDict___getitem__(self, key)

    def __delitem__(self, key: 'std::map< long long,std::string >::key_type const &') -> "void":
        return _core.IntStringDict___delitem__(self, key)

    def has_key(self, key: 'std::map< long long,std::string >::key_type const &') -> "bool":
        return _core.IntStringDict_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _core.IntStringDict_keys(self)

    def values(self) -> "PyObject *":
        return _core.IntStringDict_values(self)

    def items(self) -> "PyObject *":
        return _core.IntStringDict_items(self)

    def __contains__(self, key: 'std::map< long long,std::string >::key_type const &') -> "bool":
        return _core.IntStringDict___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _core.IntStringDict_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _core.IntStringDict_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _core.IntStringDict___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _core.IntStringDict_asdict(self)

    def __init__(self, *args):
        this = _core.new_IntStringDict(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _core.IntStringDict_empty(self)

    def size(self) -> "std::map< long long,std::string >::size_type":
        return _core.IntStringDict_size(self)

    def swap(self, v: 'IntStringDict') -> "void":
        return _core.IntStringDict_swap(self, v)

    def begin(self) -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_begin(self)

    def end(self) -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_end(self)

    def rbegin(self) -> "std::map< long long,std::string >::reverse_iterator":
        return _core.IntStringDict_rbegin(self)

    def rend(self) -> "std::map< long long,std::string >::reverse_iterator":
        return _core.IntStringDict_rend(self)

    def clear(self) -> "void":
        return _core.IntStringDict_clear(self)

    def get_allocator(self) -> "std::map< long long,std::string >::allocator_type":
        return _core.IntStringDict_get_allocator(self)

    def count(self, x: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::size_type":
        return _core.IntStringDict_count(self, x)

    def erase(self, *args) -> "void":
        return _core.IntStringDict_erase(self, *args)

    def find(self, x: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_find(self, x)

    def lower_bound(self, x: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< long long,std::string >::key_type const &') -> "std::map< long long,std::string >::iterator":
        return _core.IntStringDict_upper_bound(self, x)

    def __reduce__(self):
    	args = (dict(self), )
    	return self.__class__, args
    def __repr__(self):
    	return "<larch.core.IntStringDict>\n"+repr(self.asdict())

    __swig_destroy__ = _core.delete_IntStringDict
    __del__ = lambda self: None
IntStringDict_swigregister = _core.IntStringDict_swigregister
IntStringDict_swigregister(IntStringDict)


def set_linalg(mod: 'PyObject *') -> "void":
    return _core.set_linalg(mod)
set_linalg = _core.set_linalg

def _swigtest_empty_dict() -> "PyObject *":
    return _core._swigtest_empty_dict()
_swigtest_empty_dict = _core._swigtest_empty_dict

def _swigtest_alpha_dict() -> "PyObject *":
    return _core._swigtest_alpha_dict()
_swigtest_alpha_dict = _core._swigtest_alpha_dict
class ostream_c(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        this = _core.new_ostream_c(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_ostream_c
    __del__ = lambda self: None

    def flush(self) -> "void":
        return _core.ostream_c_flush(self)

    def write(self, x: 'std::string') -> "int":
        return _core.ostream_c_write(self, x)

    def mode(self) -> "std::string":
        return _core.ostream_c_mode(self)

    def __repr__(self) -> "std::string":
        return _core.ostream_c___repr__(self)
ostream_c_swigregister = _core.ostream_c_swigregister
ostream_c_swigregister(ostream_c)

class string_sender(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def write(self, x: 'std::string') -> "void":
        return _core.string_sender_write(self, x)
    __swig_destroy__ = _core.delete_string_sender
    __del__ = lambda self: None
string_sender_swigregister = _core.string_sender_swigregister
string_sender_swigregister(string_sender)

class refcounted(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        this = _core.new_refcounted()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_refcounted
    __del__ = lambda self: None

    def incref(self) -> "int":
        return _core.refcounted_incref(self)

    def decref(self) -> "int":
        return _core.refcounted_decref(self)

    def ref_count(self) -> "int":
        return _core.refcounted_ref_count(self)

    def lifeboat(self) -> "void":
        return _core.refcounted_lifeboat(self)
refcounted_swigregister = _core.refcounted_swigregister
refcounted_swigregister(refcounted)


def larch_initialize(*args) -> "void":
    return _core.larch_initialize(*args)
larch_initialize = _core.larch_initialize

def larch_openblas_get_config() -> "char *":
    return _core.larch_openblas_get_config()
larch_openblas_get_config = _core.larch_openblas_get_config

def load_scipy_blas_functions() -> "void":
    return _core.load_scipy_blas_functions()
load_scipy_blas_functions = _core.load_scipy_blas_functions
class OptimizationMethodList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.OptimizationMethodList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.OptimizationMethodList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.OptimizationMethodList___bool__(self)

    def __len__(self) -> "std::vector< sherpa_pack >::size_type":
        return _core.OptimizationMethodList___len__(self)

    def __getslice__(self, i: 'std::vector< sherpa_pack >::difference_type', j: 'std::vector< sherpa_pack >::difference_type') -> "std::vector< sherpa_pack,std::allocator< sherpa_pack > > *":
        return _core.OptimizationMethodList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.OptimizationMethodList___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< sherpa_pack >::difference_type', j: 'std::vector< sherpa_pack >::difference_type') -> "void":
        return _core.OptimizationMethodList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.OptimizationMethodList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sherpa_pack >::value_type const &":
        return _core.OptimizationMethodList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.OptimizationMethodList___setitem__(self, *args)

    def pop(self) -> "std::vector< sherpa_pack >::value_type":
        return _core.OptimizationMethodList_pop(self)

    def append(self, x: 'OptimizationMethod') -> "void":
        return _core.OptimizationMethodList_append(self, x)

    def empty(self) -> "bool":
        return _core.OptimizationMethodList_empty(self)

    def size(self) -> "std::vector< sherpa_pack >::size_type":
        return _core.OptimizationMethodList_size(self)

    def swap(self, v: 'OptimizationMethodList') -> "void":
        return _core.OptimizationMethodList_swap(self, v)

    def begin(self) -> "std::vector< sherpa_pack >::iterator":
        return _core.OptimizationMethodList_begin(self)

    def end(self) -> "std::vector< sherpa_pack >::iterator":
        return _core.OptimizationMethodList_end(self)

    def rbegin(self) -> "std::vector< sherpa_pack >::reverse_iterator":
        return _core.OptimizationMethodList_rbegin(self)

    def rend(self) -> "std::vector< sherpa_pack >::reverse_iterator":
        return _core.OptimizationMethodList_rend(self)

    def clear(self) -> "void":
        return _core.OptimizationMethodList_clear(self)

    def get_allocator(self) -> "std::vector< sherpa_pack >::allocator_type":
        return _core.OptimizationMethodList_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.OptimizationMethodList_pop_back(self)

    def erase(self, *args) -> "std::vector< sherpa_pack >::iterator":
        return _core.OptimizationMethodList_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_OptimizationMethodList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'OptimizationMethod') -> "void":
        return _core.OptimizationMethodList_push_back(self, x)

    def front(self) -> "std::vector< sherpa_pack >::value_type const &":
        return _core.OptimizationMethodList_front(self)

    def back(self) -> "std::vector< sherpa_pack >::value_type const &":
        return _core.OptimizationMethodList_back(self)

    def assign(self, n: 'std::vector< sherpa_pack >::size_type', x: 'OptimizationMethod') -> "void":
        return _core.OptimizationMethodList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.OptimizationMethodList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.OptimizationMethodList_insert(self, *args)

    def reserve(self, n: 'std::vector< sherpa_pack >::size_type') -> "void":
        return _core.OptimizationMethodList_reserve(self, n)

    def capacity(self) -> "std::vector< sherpa_pack >::size_type":
        return _core.OptimizationMethodList_capacity(self)
    __swig_destroy__ = _core.delete_OptimizationMethodList
    __del__ = lambda self: None
OptimizationMethodList_swigregister = _core.OptimizationMethodList_swigregister
OptimizationMethodList_swigregister(OptimizationMethodList)

class OptimizationMethod(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        this = _core.new_OptimizationMethod(*args, **kwargs)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_OptimizationMethod
    __del__ = lambda self: None
    Min_Step = _swig_property(_core.OptimizationMethod_Min_Step_get, _core.OptimizationMethod_Min_Step_set)
    Max_Step = _swig_property(_core.OptimizationMethod_Max_Step_get, _core.OptimizationMethod_Max_Step_set)
    Step_Extend_Factor = _swig_property(_core.OptimizationMethod_Step_Extend_Factor_get, _core.OptimizationMethod_Step_Extend_Factor_set)
    Step_Retract_Factor = _swig_property(_core.OptimizationMethod_Step_Retract_Factor_get, _core.OptimizationMethod_Step_Retract_Factor_set)
    Initial_Step = _swig_property(_core.OptimizationMethod_Initial_Step_get, _core.OptimizationMethod_Initial_Step_set)
    Honeymoon = _swig_property(_core.OptimizationMethod_Honeymoon_get, _core.OptimizationMethod_Honeymoon_set)
    Patience = _swig_property(_core.OptimizationMethod_Patience_get, _core.OptimizationMethod_Patience_set)
    Max_NumIter = _swig_property(_core.OptimizationMethod_Max_NumIter_get, _core.OptimizationMethod_Max_NumIter_set)
    Min_NumIter = _swig_property(_core.OptimizationMethod_Min_NumIter_get, _core.OptimizationMethod_Min_NumIter_set)
    Algorithm = _swig_property(_core.OptimizationMethod_Algorithm_get, _core.OptimizationMethod_Algorithm_set)
    Fail = _swig_property(_core.OptimizationMethod_Fail_get, _core.OptimizationMethod_Fail_set)
    Slowness = _swig_property(_core.OptimizationMethod_Slowness_get, _core.OptimizationMethod_Slowness_set)

    def get_step(self) -> "double":
        return _core.OptimizationMethod_get_step(self)

    def tell_step(self, step: 'double const &') -> "void":
        return _core.OptimizationMethod_tell_step(self, step)

    def tell_turn(self, val: 'double const &', tol: 'double const &', explain_stop: 'std::string &', iterationNumber: 'unsigned int const &') -> "bool":
        return _core.OptimizationMethod_tell_turn(self, val, tol, explain_stop, iterationNumber)

    def print_pack(self) -> "std::string":
        return _core.OptimizationMethod_print_pack(self)

    def AlgorithmName(self) -> "std::string":
        return _core.OptimizationMethod_AlgorithmName(self)

    def __repr__(self) -> "std::string":
        return _core.OptimizationMethod___repr__(self)
OptimizationMethod_swigregister = _core.OptimizationMethod_swigregister
OptimizationMethod_swigregister(OptimizationMethod)


def default_optimization_recipe() -> "std::vector< sherpa_pack,std::allocator< sherpa_pack > >":
    return _core.default_optimization_recipe()
default_optimization_recipe = _core.default_optimization_recipe

def bfgs_optimization_recipe() -> "std::vector< sherpa_pack,std::allocator< sherpa_pack > >":
    return _core.bfgs_optimization_recipe()
bfgs_optimization_recipe = _core.bfgs_optimization_recipe

def _set_array_module(mod: 'PyObject *') -> "void":
    return _core._set_array_module(mod)
_set_array_module = _core._set_array_module
class three_dim(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def size1(self) -> "unsigned int const &":
        return _core.three_dim_size1(self)

    def size2(self) -> "unsigned int const &":
        return _core.three_dim_size2(self)

    def size3(self) -> "unsigned int const &":
        return _core.three_dim_size3(self)

    def __init__(self, r: 'unsigned int const &', c: 'unsigned int const &', d: 'unsigned int const &'):
        this = _core.new_three_dim(r, c, d)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_three_dim
    __del__ = lambda self: None
three_dim_swigregister = _core.three_dim_swigregister
three_dim_swigregister(three_dim)


def ndarray_make() -> "etk::ndarray *":
    return _core.ndarray_make()
ndarray_make = _core.ndarray_make

def ndarray_exp(arg1: 'etk::ndarray *') -> "void":
    return _core.ndarray_exp(arg1)
ndarray_exp = _core.ndarray_exp

def ndarray_log(arg1: 'etk::ndarray *') -> "void":
    return _core.ndarray_log(arg1)
ndarray_log = _core.ndarray_log

def ndarray_init(arg1: 'etk::ndarray *') -> "void":
    return _core.ndarray_init(arg1)
ndarray_init = _core.ndarray_init

def SymmetricArray_use_upper_triangle(arg1: 'etk::symmetric_matrix *') -> "void":
    return _core.SymmetricArray_use_upper_triangle(arg1)
SymmetricArray_use_upper_triangle = _core.SymmetricArray_use_upper_triangle


from .array import Array
from .array import SymmetricArray


class Fountain(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ask_dna(self, *args) -> "elm::VAS_dna const":
        return _core.Fountain_ask_dna(self, *args)

    def nCases(self) -> "unsigned int":
        """The number of cases currently active in this Fountain."""
        return _core.Fountain_nCases(self)


    def nAlts(self) -> "unsigned int":
        """The number of alternatives currently active in this Fountain."""
        return _core.Fountain_nAlts(self)


    def alternative_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        """A vector of the alternative names used by this Fountain."""
        return _core.Fountain_alternative_names(self)


    def alternative_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        """A vector of the alternative codes (64 bit integers) used by this Fountain."""
        return _core.Fountain_alternative_codes(self)


    def alternative_name(self, arg0: 'long long') -> "std::string":
        """Given an alternative code, return the name."""
        return _core.Fountain_alternative_name(self, arg0)


    def alternative_code(self, arg0: 'std::string') -> "long long":
        """Given an alternative name, return the code."""
        return _core.Fountain_alternative_code(self, arg0)


    def uncache_alternatives(self) -> "void":
        return _core.Fountain_uncache_alternatives(self)

    def cache_alternatives(self) -> "void":
        return _core.Fountain_cache_alternatives(self)

    def check_ca(self, column: 'std::string const &') -> "bool":
        return _core.Fountain_check_ca(self, column)

    def check_co(self, column: 'std::string const &') -> "bool":
        return _core.Fountain_check_co(self, column)

    def variables_ca(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Fountain_variables_ca(self)

    def variables_co(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Fountain_variables_co(self)

    def __init__(self):
        if self.__class__ == Fountain:
            _self = None
        else:
            _self = self
        this = _core.new_Fountain(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_Fountain
    __del__ = lambda self: None
    source_filename = _swig_property(_core.Fountain_source_filename_get, _core.Fountain_source_filename_set)

    def DataDNA(self, c: 'long long const &'=0) -> "elm::VAS_System *":
        return _core.Fountain_DataDNA(self, c)

    def alternatives_dna(self) -> "elm::VAS_dna":
        return _core.Fountain_alternatives_dna(self)

    def _refresh_dna(self, a_names: 'StrVector', a_codes: 'LongLongVector') -> "void":
        return _core.Fountain__refresh_dna(self, a_names, a_codes)


    def dataframe_idco(self, *vars, **kwargs):
    	"""
    	Load a selection of :ref:`idco` data into a :class:`pandas.DataFrame`.

    	This function passes all parameters through to :meth:`Fountain.array_idco`.
    	"""
    	data = self.array_idco(*vars, **kwargs)
    	import pandas
    	df = pandas.DataFrame(data=data, index=self.caseids(), columns=vars, dtype=None, copy=False)
    	return df

    def dataframe_idca(self, *vars, wide=False, **kwargs):
    	"""
    	Load a selection of :ref:`idca` data into a :class:`pandas.DataFrame`.

    	:param wide: If True (defaults False), the resulting data array will be pivoted to be :ref:`idco`,
    				with one row per case and a hierarchical columns definition.
    	:type wide:  bool

    	This function passes all other parameters through to :meth:`Fountain.array_idca`.

    	"""
    	import pandas
    	data = self.array_idca(*vars, **kwargs)
    	data = data.reshape(-1,data.shape[-1])
    	mi = pandas.MultiIndex.from_product([self.caseids(), self.alternative_codes()], names=['caseid', 'altid'])
    	df = pandas.DataFrame(data=data, index=mi, columns=vars, dtype=None, copy=False)
    	if wide:
    		return df.unstack(level=-1)
    	else:
    		return df

    def dataframe_all(self):
    	"""
    	Load all data (idca and idco) to one big idco format :class:`pandas.DataFrame`.

    	No effort is made to prevent duplication of data in this DataFrame.
    	(e.g. if there are idco variables stacked to make a single idca
    	variable, these will appear in the output twice).  If there is a
    	lot of data, this DataFrame could be very large.

    	"""
    	import pandas
    	dfco = self.dataframe_idco(*self.variables_co())
    	dfca = self.dataframe_idca(*self.variables_ca(), wide=True)
    	dfca.columns = ['_'.join(str(c) for c in col).strip() for col in dfca.columns.values]
    	df = pandas.concat([dfco, dfca], axis=1)
    	for col in df.columns:
    		if numpy.all(df[col].astype(int) == df[col]):
    			df[col] = df[col].astype(int)
    	return df

    def export_all(self, *arg, **kwarg):
    	"""
    	Export all data (idca and idco) to one big idco format csv file.

    	This method takes the dataframe from :meth:`dataframe_all` and writes
    	it out to a csv file. All arguments are passed through to :meth:`pandas.DataFrame.to_csv`.
    	No effort is made to prevent duplication of data in this export
    	(e.g. if there are idco variables stacked to make a single idca
    	variable, these will appear in the output twice).

    	"""
    	import pandas
    	if 'index_label' not in kwarg:
    		kwarg['index_label']='caseid'
    	self.dataframe_all().to_csv(*arg, **kwarg)


    def __disown__(self):
        self.this.disown()
        _core.disown_Fountain(self)
        return weakref_proxy(self)
Fountain_swigregister = _core.Fountain_swigregister
Fountain_swigregister(Fountain)

class QuerySet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def qry_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySet_qry_idco(self, corrected)

    def qry_idco_(self) -> "std::string":
        return _core.QuerySet_qry_idco_(self)

    def qry_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySet_qry_idca(self, corrected)

    def qry_idca_(self) -> "std::string":
        return _core.QuerySet_qry_idca_(self)

    def qry_alts(self) -> "std::string":
        return _core.QuerySet_qry_alts(self)

    def qry_caseids(self) -> "std::string":
        return _core.QuerySet_qry_caseids(self)

    def qry_choice(self) -> "std::string":
        return _core.QuerySet_qry_choice(self)

    def qry_weight(self) -> "std::string":
        return _core.QuerySet_qry_weight(self)

    def qry_avail(self) -> "std::string":
        return _core.QuerySet_qry_avail(self)

    def tbl_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySet_tbl_idco(self, corrected)

    def tbl_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySet_tbl_idca(self, corrected)

    def tbl_alts(self) -> "std::string":
        return _core.QuerySet_tbl_alts(self)

    def tbl_caseids(self) -> "std::string":
        return _core.QuerySet_tbl_caseids(self)

    def tbl_choice(self) -> "std::string":
        return _core.QuerySet_tbl_choice(self)

    def tbl_weight(self) -> "std::string":
        return _core.QuerySet_tbl_weight(self)

    def tbl_avail(self) -> "std::string":
        return _core.QuerySet_tbl_avail(self)

    def unweighted(self) -> "bool":
        return _core.QuerySet_unweighted(self)

    def all_alts_always_available(self) -> "bool":
        return _core.QuerySet_all_alts_always_available(self)
    __swig_destroy__ = _core.delete_QuerySet
    __del__ = lambda self: None

    def __init__(self, validator: 'Facet'=None, validator2: 'PyObject *'=None):
        this = _core.new_QuerySet(validator, validator2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_validator_(self, validator: 'Facet', validator2: 'PyObject *') -> "void":
        return _core.QuerySet_set_validator_(self, validator, validator2)

    def get_validator(self) -> "PyObject *":
        return _core.QuerySet_get_validator(self)

    def __repr__(self) -> "std::string":
        return _core.QuerySet___repr__(self)

    def actual_type(self) -> "std::string":
        return _core.QuerySet_actual_type(self)

    def pickled(self) -> "PyObject *":
        return _core.QuerySet_pickled(self)

    def __getstate__(self):
    	args = {}
    	for i in dir(self):
    		if len(i)>4 and i[:4]=='get_' and i!='get_validator':
    			args['set_'+i[4:]] = getattr(self,i)()
    	return args
    def __setstate__(self, state):
    	self.__init__()
    	for key, value in state.items():
    		getattr(self,key)(value)
    def set_validator(self, v):
    	self.set_validator_(v,v)


QuerySet_swigregister = _core.QuerySet_swigregister
QuerySet_swigregister(QuerySet)

class QuerySetSimpleCO(QuerySet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def qry_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySetSimpleCO_qry_idco(self, corrected)

    def qry_idco_(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_idco_(self)

    def qry_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySetSimpleCO_qry_idca(self, corrected)

    def qry_idca_(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_idca_(self)

    def qry_alts(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_alts(self)

    def qry_caseids(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_caseids(self)

    def qry_choice(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_choice(self)

    def qry_weight(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_weight(self)

    def qry_avail(self) -> "std::string":
        return _core.QuerySetSimpleCO_qry_avail(self)

    def unweighted(self) -> "bool":
        return _core.QuerySetSimpleCO_unweighted(self)

    def all_alts_always_available(self) -> "bool":
        return _core.QuerySetSimpleCO_all_alts_always_available(self)
    __swig_destroy__ = _core.delete_QuerySetSimpleCO
    __del__ = lambda self: None

    def __repr__(self) -> "std::string":
        return _core.QuerySetSimpleCO___repr__(self)

    def actual_type(self) -> "std::string":
        return _core.QuerySetSimpleCO_actual_type(self)

    def __init__(self, validator: 'Facet'=None):
        this = _core.new_QuerySetSimpleCO(validator)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_validator(self, validator: 'Facet'=None) -> "void":
        return _core.QuerySetSimpleCO_set_validator(self, validator)

    def set_idco_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_idco_query(self, q)

    def set_choice_column(self, col: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_choice_column(self, col)

    def set_choice_column_map(self, cols: 'IntStringDict') -> "void":
        return _core.QuerySetSimpleCO_set_choice_column_map(self, cols)

    def set_avail_column_map(self, cols: 'IntStringDict') -> "void":
        return _core.QuerySetSimpleCO_set_avail_column_map(self, cols)

    def set_avail_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_avail_query(self, q)

    def set_avail_all(self) -> "void":
        return _core.QuerySetSimpleCO_set_avail_all(self)

    def set_weight_column(self, col: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_weight_column(self, col)

    def set_alts_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetSimpleCO_set_alts_query(self, q)

    def set_alts_values(self, alts: 'IntStringDict') -> "void":
        return _core.QuerySetSimpleCO_set_alts_values(self, alts)

    def get_idco_query(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_idco_query(self)

    def get_choice_column(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_choice_column(self)

    def get_choice_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetSimpleCO_get_choice_column_map(self)

    def get_avail_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetSimpleCO_get_avail_column_map(self)

    def get_avail_query(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_avail_query(self)

    def get_weight_column(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_weight_column(self)

    def get_alts_query(self) -> "std::string":
        return _core.QuerySetSimpleCO_get_alts_query(self)

    def _get_alts_values(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetSimpleCO__get_alts_values(self)
QuerySetSimpleCO_swigregister = _core.QuerySetSimpleCO_swigregister
QuerySetSimpleCO_swigregister(QuerySetSimpleCO)


from . import _QuerySetSimpleCO_extras as _morefuncs
del _morefuncs

class QuerySetTwoTable(QuerySet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def qry_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySetTwoTable_qry_idco(self, corrected)

    def qry_idco_(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_idco_(self)

    def qry_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.QuerySetTwoTable_qry_idca(self, corrected)

    def qry_idca_(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_idca_(self)

    def qry_alts(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_alts(self)

    def qry_caseids(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_caseids(self)

    def qry_choice(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_choice(self)

    def qry_weight(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_weight(self)

    def qry_avail(self) -> "std::string":
        return _core.QuerySetTwoTable_qry_avail(self)

    def unweighted(self) -> "bool":
        return _core.QuerySetTwoTable_unweighted(self)

    def all_alts_always_available(self) -> "bool":
        return _core.QuerySetTwoTable_all_alts_always_available(self)
    __swig_destroy__ = _core.delete_QuerySetTwoTable
    __del__ = lambda self: None

    def __repr__(self) -> "std::string":
        return _core.QuerySetTwoTable___repr__(self)

    def actual_type(self) -> "std::string":
        return _core.QuerySetTwoTable_actual_type(self)

    def pickled(self) -> "PyObject *":
        return _core.QuerySetTwoTable_pickled(self)

    def __init__(self, validator: 'Facet'=None):
        this = _core.new_QuerySetTwoTable(validator)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_validator(self, validator: 'Facet'=None) -> "void":
        return _core.QuerySetTwoTable_set_validator(self, validator)

    def set_idco_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_idco_query(self, q)

    def set_idca_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_idca_query(self, q)

    def set_choice_co(self, col: 'std::string const &') -> "void":
        """
        Set the choice expression that will evaluate on the idco table. 

        Parameters 
        ---------- 
        expr : str 
        	The expression to be evaluated. It should result in integer values 
        	corresponding to the alternative codes.

        """
        return _core.QuerySetTwoTable_set_choice_co(self, col)


    def set_choice_co_map(self, cols: 'IntStringDict') -> "void":
        return _core.QuerySetTwoTable_set_choice_co_map(self, cols)

    def set_choice_ca(self, col: 'std::string const &') -> "void":
        """
        Set the choice expression that will evaluate on the idca table. 

        Parameters 
        ---------- 
        expr : str 
        	The expression to be evaluated. It should evaluate to 1 if the alternative for the 
        	particular row was chosen, and 0 otherwise. (For certain specialized models,     
        	values other than 0 or 1 may be appropriate.)

        """
        return _core.QuerySetTwoTable_set_choice_ca(self, col)


    def set_avail_co_column_map(self, cols: 'IntStringDict') -> "void":
        return _core.QuerySetTwoTable_set_avail_co_column_map(self, cols)

    def set_avail_ca_column(self, col: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_avail_ca_column(self, col)

    def set_avail_all(self) -> "void":
        return _core.QuerySetTwoTable_set_avail_all(self)

    def set_weight_co_column(self, col: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_weight_co_column(self, col)

    def set_alts_query(self, q: 'std::string const &') -> "void":
        return _core.QuerySetTwoTable_set_alts_query(self, q)

    def set_alts_values(self, alts: 'IntStringDict') -> "void":
        return _core.QuerySetTwoTable_set_alts_values(self, alts)

    def get_idco_query(self) -> "std::string":
        return _core.QuerySetTwoTable_get_idco_query(self)

    def get_idca_query(self) -> "std::string":
        return _core.QuerySetTwoTable_get_idca_query(self)

    def get_choice_co(self) -> "std::string":
        return _core.QuerySetTwoTable_get_choice_co(self)

    def get_choice_co_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetTwoTable_get_choice_co_map(self)

    def get_choice_ca(self) -> "std::string":
        return _core.QuerySetTwoTable_get_choice_ca(self)

    def get_avail_co_column_map(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetTwoTable_get_avail_co_column_map(self)

    def get_avail_ca_column(self) -> "std::string":
        return _core.QuerySetTwoTable_get_avail_ca_column(self)

    def get_weight_co_column(self) -> "std::string":
        return _core.QuerySetTwoTable_get_weight_co_column(self)

    def get_alts_query(self) -> "std::string":
        return _core.QuerySetTwoTable_get_alts_query(self)

    def _get_alts_values(self) -> "std::map< long long,std::string,std::less< long long >,std::allocator< std::pair< long long const,std::string > > >":
        return _core.QuerySetTwoTable__get_alts_values(self)
QuerySetTwoTable_swigregister = _core.QuerySetTwoTable_swigregister
QuerySetTwoTable_swigregister(QuerySetTwoTable)


from . import _QuerySetTwoTable_extras as _morefuncs
del _morefuncs

class SQLiteDB(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, pylong_ptr_to_db: 'PyObject *'):
        this = _core.new_SQLiteDB(pylong_ptr_to_db)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_SQLiteDB
    __del__ = lambda self: None

    def close(self) -> "void":
        return _core.SQLiteDB_close(self)

    def copy_from_db(self, file_name_: 'std::string const &') -> "void":
        return _core.SQLiteDB_copy_from_db(self, file_name_)

    def backup(self, filename: 'std::string const &') -> "void":
        """
        Save the current SQLite database to another DB. 

        :param filename: The URI for where to save the DB.
        """
        return _core.SQLiteDB_backup(self, filename)


    def commit(self, raise_on_fail: 'int'=1) -> "void":
        """
        Commit to SQLite database. 

        :param raise_on_fail: Raise an exception if the commit fails for any reason.
        """
        return _core.SQLiteDB_commit(self, raise_on_fail)


    def drop(self, name: 'std::string') -> "void":
        return _core.SQLiteDB_drop(self, name)

    def all_table_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        """
        A list of all table names in the SQL database, including both data tables and
        administrative tables
        """
        return _core.SQLiteDB_all_table_names(self)


    def column_names(self, query: 'std::string') -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.SQLiteDB_column_names(self, query)

    def column_name(self, query: 'std::string', n: 'int') -> "std::string":
        return _core.SQLiteDB_column_name(self, query, n)

    def logger(self, log: 'PyObject *'=None) -> "PyObject *":
        """
        The SQLiteDB object contains a link to the standard python logging service. By default,
        no logger is connected. Use this function to assign a logger, and then use the usual
        python logging controls to set the quantity/destination of output. To stop logging,
        call this function without any arguments.
        """
        return _core.SQLiteDB_logger(self, log)


    def error_code(self) -> "int":
        return _core.SQLiteDB_error_code(self)

    def error_msg(self) -> "std::string":
        return _core.SQLiteDB_error_msg(self)

    def eval_integer(self, *args) -> "int":
        """
        Evaluate a SQL statement that should return a single text string. 

        :param sql: The SQL statement to evaluate.
        :param default_value: A default value to return if the statement does not return a single value.
        """
        return _core.SQLiteDB_eval_integer(self, *args)


    def eval_int64(self, *args) -> "long long":
        return _core.SQLiteDB_eval_int64(self, *args)

    def eval_float(self, *args) -> "double":
        """
        Evaluate a SQL statement that should return a single double precision floating point number. 

        :param sql: The SQL statement to evaluate.
        :param default_value: A default value to return if the statement does not return a single value.
        """
        return _core.SQLiteDB_eval_float(self, *args)


    def eval_text(self, *args) -> "std::string":
        return _core.SQLiteDB_eval_text(self, *args)

    def eval_int64_tuple(self, sql: 'std::string const &') -> "std::vector< long long,std::allocator< long long > >":
        return _core.SQLiteDB_eval_int64_tuple(self, sql)

    def eval_string_tuple(self, sql: 'std::string const &') -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.SQLiteDB_eval_string_tuple(self, sql)

    def __str__(self):
    	return "<SQLiteDB: %s>"%self.working_name
    def __repr__(self):
    	return "<SQLiteDB: %s>"%self.working_name
    exec_integer = eval_integer
    exec_float   = eval_float
    exec_text    = eval_text
    def Shell(self):
    	'''Enter an SQLite shell for accessing the contents of the database object.

    	The shell is based on the usual SQLite3 command shell, and is not a Python
    	interpreted environment. Use Ctrl-C (Windows) or Ctrl-D (Mac OS X) to escape
    	back to the usual Python environment.'''
    	from . import apsw
    	apsw.Shell(db=self).cmdloop()

SQLiteDB_swigregister = _core.SQLiteDB_swigregister
SQLiteDB_swigregister(SQLiteDB)

class Facet(SQLiteDB, Fountain):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ask_dna(self, c: 'long long const &'=0) -> "elm::VAS_dna":
        return _core.Facet_ask_dna(self, c)
    __swig_destroy__ = _core.delete_Facet
    __del__ = lambda self: None
    window_title = _swig_property(_core.Facet_window_title_get, _core.Facet_window_title_set)
    working_name = _swig_property(_core.Facet_working_name_get, _core.Facet_working_name_set)
    active_facet = _swig_property(_core.Facet_active_facet_get, _core.Facet_active_facet_set)

    def _get_queries(self) -> "PyObject *":
        return _core.Facet__get_queries(self)

    def _set_queries(self, q: 'PyObject *', qp: 'QuerySet', facetself: 'PyObject *') -> "void":
        return _core.Facet__set_queries(self, q, qp, facetself)

    def refresh_queries(self) -> "void":
        return _core.Facet_refresh_queries(self)

    def __init__(self, pylong_ptr_to_db: 'PyObject *'):
        this = _core.new_Facet(pylong_ptr_to_db)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def save_facet(self, name: 'std::string') -> "void":
        return _core.Facet_save_facet(self, name)

    def load_facet(self, *args) -> "void":
        return _core.Facet_load_facet(self, *args)

    def clear_facet(self) -> "void":
        return _core.Facet_clear_facet(self)

    def list_facets(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Facet_list_facets(self)

    def nCases(self) -> "unsigned int":
        """The number of cases currently active in this Fountain."""
        return _core.Facet_nCases(self)


    def nAlts(self) -> "unsigned int":
        """The number of alternatives currently active in this Fountain."""
        return _core.Facet_nAlts(self)


    def caseids(self, firstcasenum: 'unsigned int const &'=0, numberofcases: 'unsigned int const &'=0, no_error_checking: 'int'=0) -> "std::vector< long long,std::allocator< long long > >":
        return _core.Facet_caseids(self, firstcasenum, numberofcases, no_error_checking)

    def altids(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.Facet_altids(self)

    def alternative_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        """A vector of the alternative names used by this Fountain."""
        return _core.Facet_alternative_names(self)


    def alternative_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        """A vector of the alternative codes (64 bit integers) used by this Fountain."""
        return _core.Facet_alternative_codes(self)


    def alternative_name(self, arg2: 'long long') -> "std::string":
        """Given an alternative code, return the name."""
        return _core.Facet_alternative_name(self, arg2)


    def alternative_code(self, arg2: 'std::string') -> "long long":
        """Given an alternative name, return the code."""
        return _core.Facet_alternative_code(self, arg2)


    def check_ca(self, column: 'std::string const &') -> "bool":
        return _core.Facet_check_ca(self, column)

    def check_co(self, column: 'std::string const &') -> "bool":
        return _core.Facet_check_co(self, column)

    def variables_ca(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Facet_variables_ca(self)

    def variables_co(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Facet_variables_co(self)

    def query_idca(self, columns: 'StrVector', validate: 'bool'=False, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_idca(self, columns, validate, caseid)

    def query_idco(self, columns: 'StrVector', validate: 'bool'=False, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_idco(self, columns, validate, caseid)

    def query_alts(self, caseid: 'long long *') -> "std::string":
        return _core.Facet_query_alts(self, caseid)

    def query_choice(self, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_choice(self, caseid)

    def query_avail(self, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_avail(self, caseid)

    def query_weight(self, caseid: 'long long *'=None) -> "std::string":
        return _core.Facet_query_weight(self, caseid)

    def qry_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.Facet_qry_idca(self, corrected)

    def qry_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.Facet_qry_idco(self, corrected)

    def qry_idca_(self) -> "std::string":
        return _core.Facet_qry_idca_(self)

    def qry_idco_(self) -> "std::string":
        return _core.Facet_qry_idco_(self)

    def qry_alts(self) -> "std::string":
        return _core.Facet_qry_alts(self)

    def qry_choice(self) -> "std::string":
        return _core.Facet_qry_choice(self)

    def qry_avail(self) -> "std::string":
        return _core.Facet_qry_avail(self)

    def qry_weight(self) -> "std::string":
        return _core.Facet_qry_weight(self)

    def qry_caseids(self) -> "std::string":
        return _core.Facet_qry_caseids(self)

    def tbl_idca(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.Facet_tbl_idca(self, corrected)

    def tbl_idco(self, corrected: 'bool const &'=True) -> "std::string":
        return _core.Facet_tbl_idco(self, corrected)

    def tbl_alts(self) -> "std::string":
        return _core.Facet_tbl_alts(self)

    def tbl_choice(self) -> "std::string":
        return _core.Facet_tbl_choice(self)

    def tbl_avail(self) -> "std::string":
        return _core.Facet_tbl_avail(self)

    def tbl_weight(self) -> "std::string":
        return _core.Facet_tbl_weight(self)

    def tbl_caseids(self) -> "std::string":
        return _core.Facet_tbl_caseids(self)

    def unweighted(self) -> "bool":
        return _core.Facet_unweighted(self)

    def all_alts_always_available(self) -> "bool":
        return _core.Facet_all_alts_always_available(self)

    def _array_idco_reader(self, qry: 'std::string const &', array: 'elm::darray *', caseids: 'elm::darray *') -> "void":
        return _core.Facet__array_idco_reader(self, qry, array, caseids)

    def _array_idca_reader(self, qry: 'std::string const &', array: 'elm::darray *', caseids: 'elm::darray *', altids: 'LongLongVector') -> "void":
        return _core.Facet__array_idca_reader(self, qry, array, caseids, altids)

    def _array_idca_reader_blind(self, qry: 'std::string const &', arraytype: 'int', altids: 'LongLongVector') -> "void":
        return _core.Facet__array_idca_reader_blind(self, qry, arraytype, altids)

    def sql(self):
    	print("sql_idco:   %s"%(self.sql_idco   if self.sql_idco   else "<blank>"))
    	print("sql_idca:   %s"%(self.sql_idca   if self.sql_idca   else "<blank>"))
    	print("sql_alts:   %s"%(self.sql_alts   if self.sql_alts   else "<blank>"))
    	print("sql_choice: %s"%(self.sql_choice if self.sql_choice else "<blank>"))
    	print("sql_avail:  %s"%(self.sql_avail  if self.sql_avail  else "<blank>"))
    	print("sql_weight: %s"%(self.sql_weight if self.sql_weight else "<blank>"))

Facet_swigregister = _core.Facet_swigregister
Facet_swigregister(Facet)


from .db import DB
from .dt import DT

ELM_IGNORED = _core.ELM_IGNORED
ELM_UPDATED = _core.ELM_UPDATED
ELM_INITIALIZED = _core.ELM_INITIALIZED
ELM_CREATED = _core.ELM_CREATED
ELM_FAILED = _core.ELM_FAILED
class ParameterLinkArray(three_dim):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self):
        this = _core.new_ParameterLinkArray()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_ParameterLinkArray
    __del__ = lambda self: None

    def __str__(self) -> "std::string":
        return _core.ParameterLinkArray___str__(self)

    def __repr__(self) -> "std::string":
        return _core.ParameterLinkArray___repr__(self)

    def pull(self, listorder: 'etk::ndarray const *', apporder: 'etk::ndarray *') -> "void":
        return _core.ParameterLinkArray_pull(self, listorder, apporder)

    def push(self, listorder: 'etk::ndarray *', apporder: 'etk::ndarray const *') -> "void":
        return _core.ParameterLinkArray_push(self, listorder, apporder)
ParameterLinkArray_swigregister = _core.ParameterLinkArray_swigregister
ParameterLinkArray_swigregister(ParameterLinkArray)

class cellcodeset_iterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __iter__(self) -> "elm::cellcodeset_iterator":
        return _core.cellcodeset_iterator___iter__(self)

    def next(self) -> "elm::cellcode":
        return _core.cellcodeset_iterator_next(self)

    def __next__(self) -> "elm::cellcode":
        return _core.cellcodeset_iterator___next__(self)

    def __init__(self, parent: 'cellcodeset'):
        this = _core.new_cellcodeset_iterator(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_cellcodeset_iterator
    __del__ = lambda self: None
cellcodeset_iterator_swigregister = _core.cellcodeset_iterator_swigregister
cellcodeset_iterator_swigregister(cellcodeset_iterator)

class cellcodeset(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args):
        this = _core.new_cellcodeset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def contains(self, j: 'elm::cellcode const &') -> "bool":
        return _core.cellcodeset_contains(self, j)

    def insert_set(self, i: 'cellcodeset') -> "void":
        return _core.cellcodeset_insert_set(self, i)

    def append(self, i: 'elm::cellcode const &') -> "void":
        return _core.cellcodeset_append(self, i)

    def remove(self, i: 'elm::cellcode const &') -> "bool":
        return _core.cellcodeset_remove(self, i)

    def noop(self) -> "void":
        return _core.cellcodeset_noop(self)

    def __iadd__(self, *args) -> "elm::cellcodeset &":
        return _core.cellcodeset___iadd__(self, *args)

    def __isub__(self, *args) -> "elm::cellcodeset &":
        return _core.cellcodeset___isub__(self, *args)

    def __len__(self) -> "int":
        return _core.cellcodeset___len__(self)

    def __repr__(self) -> "std::string":
        return _core.cellcodeset___repr__(self)

    def __iter__(self) -> "elm::cellcodeset_iterator":
        return _core.cellcodeset___iter__(self)
    __swig_destroy__ = _core.delete_cellcodeset
    __del__ = lambda self: None
cellcodeset_swigregister = _core.cellcodeset_swigregister
cellcodeset_swigregister(cellcodeset)


def max_cellcode() -> "elm::cellcode":
    return _core.max_cellcode()
max_cellcode = _core.max_cellcode
class string_and_cellcode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    text = _swig_property(_core.string_and_cellcode_text_get, _core.string_and_cellcode_text_set)
    code = _swig_property(_core.string_and_cellcode_code_get, _core.string_and_cellcode_code_set)

    def __init__(self):
        this = _core.new_string_and_cellcode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_string_and_cellcode
    __del__ = lambda self: None
string_and_cellcode_swigregister = _core.string_and_cellcode_swigregister
string_and_cellcode_swigregister(string_and_cellcode)

class cellcodepair(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    up = _swig_property(_core.cellcodepair_up_get, _core.cellcodepair_up_set)
    dn = _swig_property(_core.cellcodepair_dn_get, _core.cellcodepair_dn_set)

    def __init__(self, *args):
        this = _core.new_cellcodepair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __lt__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___lt__(self, x)

    def __eq__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___eq__(self, x)

    def __gt__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___gt__(self, x)

    def __ge__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___ge__(self, x)

    def __le__(self, x: 'cellcodepair') -> "bool":
        return _core.cellcodepair___le__(self, x)
    __swig_destroy__ = _core.delete_cellcodepair
    __del__ = lambda self: None
cellcodepair_swigregister = _core.cellcodepair_swigregister
cellcodepair_swigregister(cellcodepair)

class cellcode_infodict(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.cellcode_infodict_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.cellcode_infodict___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.cellcode_infodict___bool__(self)

    def __len__(self) -> "std::map< long long,elm::VAS_dna_info >::size_type":
        return _core.cellcode_infodict___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::mapped_type const &":
        return _core.cellcode_infodict___getitem__(self, key)

    def __delitem__(self, key: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "void":
        return _core.cellcode_infodict___delitem__(self, key)

    def has_key(self, key: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "bool":
        return _core.cellcode_infodict_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _core.cellcode_infodict_keys(self)

    def values(self) -> "PyObject *":
        return _core.cellcode_infodict_values(self)

    def items(self) -> "PyObject *":
        return _core.cellcode_infodict_items(self)

    def __contains__(self, key: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "bool":
        return _core.cellcode_infodict___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _core.cellcode_infodict_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _core.cellcode_infodict_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _core.cellcode_infodict___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _core.cellcode_infodict_asdict(self)

    def __init__(self, *args):
        this = _core.new_cellcode_infodict(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _core.cellcode_infodict_empty(self)

    def size(self) -> "std::map< long long,elm::VAS_dna_info >::size_type":
        return _core.cellcode_infodict_size(self)

    def swap(self, v: 'cellcode_infodict') -> "void":
        return _core.cellcode_infodict_swap(self, v)

    def begin(self) -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_begin(self)

    def end(self) -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_end(self)

    def rbegin(self) -> "std::map< long long,elm::VAS_dna_info >::reverse_iterator":
        return _core.cellcode_infodict_rbegin(self)

    def rend(self) -> "std::map< long long,elm::VAS_dna_info >::reverse_iterator":
        return _core.cellcode_infodict_rend(self)

    def clear(self) -> "void":
        return _core.cellcode_infodict_clear(self)

    def get_allocator(self) -> "std::map< long long,elm::VAS_dna_info >::allocator_type":
        return _core.cellcode_infodict_get_allocator(self)

    def count(self, x: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::size_type":
        return _core.cellcode_infodict_count(self, x)

    def erase(self, *args) -> "void":
        return _core.cellcode_infodict_erase(self, *args)

    def find(self, x: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_find(self, x)

    def lower_bound(self, x: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< long long,elm::VAS_dna_info >::key_type const &') -> "std::map< long long,elm::VAS_dna_info >::iterator":
        return _core.cellcode_infodict_upper_bound(self, x)
    __swig_destroy__ = _core.delete_cellcode_infodict
    __del__ = lambda self: None
cellcode_infodict_swigregister = _core.cellcode_infodict_swigregister
cellcode_infodict_swigregister(cellcode_infodict)

class cellcode_list(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.cellcode_list_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.cellcode_list___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.cellcode_list___bool__(self)

    def __len__(self) -> "std::list< long long >::size_type":
        return _core.cellcode_list___len__(self)

    def __getslice__(self, i: 'std::list< long long >::difference_type', j: 'std::list< long long >::difference_type') -> "std::list< long long,std::allocator< long long > > *":
        return _core.cellcode_list___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.cellcode_list___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< long long >::difference_type', j: 'std::list< long long >::difference_type') -> "void":
        return _core.cellcode_list___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.cellcode_list___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< long long >::value_type const &":
        return _core.cellcode_list___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.cellcode_list___setitem__(self, *args)

    def pop(self) -> "std::list< long long >::value_type":
        return _core.cellcode_list_pop(self)

    def append(self, x: 'std::list< long long >::value_type const &') -> "void":
        return _core.cellcode_list_append(self, x)

    def empty(self) -> "bool":
        return _core.cellcode_list_empty(self)

    def size(self) -> "std::list< long long >::size_type":
        return _core.cellcode_list_size(self)

    def swap(self, v: 'cellcode_list') -> "void":
        return _core.cellcode_list_swap(self, v)

    def begin(self) -> "std::list< long long >::iterator":
        return _core.cellcode_list_begin(self)

    def end(self) -> "std::list< long long >::iterator":
        return _core.cellcode_list_end(self)

    def rbegin(self) -> "std::list< long long >::reverse_iterator":
        return _core.cellcode_list_rbegin(self)

    def rend(self) -> "std::list< long long >::reverse_iterator":
        return _core.cellcode_list_rend(self)

    def clear(self) -> "void":
        return _core.cellcode_list_clear(self)

    def get_allocator(self) -> "std::list< long long >::allocator_type":
        return _core.cellcode_list_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.cellcode_list_pop_back(self)

    def erase(self, *args) -> "std::list< long long >::iterator":
        return _core.cellcode_list_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_cellcode_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::list< long long >::value_type const &') -> "void":
        return _core.cellcode_list_push_back(self, x)

    def front(self) -> "std::list< long long >::value_type const &":
        return _core.cellcode_list_front(self)

    def back(self) -> "std::list< long long >::value_type const &":
        return _core.cellcode_list_back(self)

    def assign(self, n: 'std::list< long long >::size_type', x: 'std::list< long long >::value_type const &') -> "void":
        return _core.cellcode_list_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.cellcode_list_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.cellcode_list_insert(self, *args)

    def pop_front(self) -> "void":
        return _core.cellcode_list_pop_front(self)

    def push_front(self, x: 'std::list< long long >::value_type const &') -> "void":
        return _core.cellcode_list_push_front(self, x)

    def reverse(self) -> "void":
        return _core.cellcode_list_reverse(self)
    __swig_destroy__ = _core.delete_cellcode_list
    __del__ = lambda self: None
cellcode_list_swigregister = _core.cellcode_list_swigregister
cellcode_list_swigregister(cellcode_list)

class VAS_dna_info(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    dns = _swig_property(_core.VAS_dna_info_dns_get, _core.VAS_dna_info_dns_set)
    name = _swig_property(_core.VAS_dna_info_name_get, _core.VAS_dna_info_name_set)
    is_branch = _swig_property(_core.VAS_dna_info_is_branch_get, _core.VAS_dna_info_is_branch_set)

    def __init__(self, *args):
        this = _core.new_VAS_dna_info(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def is_elemental(self) -> "bool":
        return _core.VAS_dna_info_is_elemental(self)
    __swig_destroy__ = _core.delete_VAS_dna_info
    __del__ = lambda self: None
VAS_dna_info_swigregister = _core.VAS_dna_info_swigregister
VAS_dna_info_swigregister(VAS_dna_info)

class VAS_dna(cellcode_infodict):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def read_sequence(self, seq: 'std::string const &') -> "void":
        return _core.VAS_dna_read_sequence(self, seq)

    def add_sequence(self, *args) -> "void":
        return _core.VAS_dna_add_sequence(self, *args)

    def generate_sequence(self) -> "std::string":
        return _core.VAS_dna_generate_sequence(self)

    def generate_phenotype(self) -> "std::string":
        return _core.VAS_dna_generate_phenotype(self)

    def add_edge(self, source: 'elm::cellcode const &', sink: 'elm::cellcode const &') -> "std::string":
        return _core.VAS_dna_add_edge(self, source, sink)

    def remove_edge(self, source: 'elm::cellcode const &', sink: 'elm::cellcode const &') -> "std::string":
        return _core.VAS_dna_remove_edge(self, source, sink)

    def add_cell(self, *args) -> "int":
        return _core.VAS_dna_add_cell(self, *args)

    def clear(self) -> "void":
        return _core.VAS_dna_clear(self)

    def elemental_codes(self) -> "elm::cellcodeset":
        return _core.VAS_dna_elemental_codes(self)

    def all_known_codes(self) -> "elm::cellcodeset":
        return _core.VAS_dna_all_known_codes(self)

    def branches_in_ascending_order(self, *args) -> "std::list< elm::cellcode,std::allocator< elm::cellcode > >":
        return _core.VAS_dna_branches_in_ascending_order(self, *args)

    def __init__(self):
        this = _core.new_VAS_dna()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_VAS_dna
    __del__ = lambda self: None
VAS_dna_swigregister = _core.VAS_dna_swigregister
VAS_dna_swigregister(VAS_dna)

class VAS_System(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def n_elemental(self) -> "unsigned int const &":
        return _core.VAS_System_n_elemental(self)

    def n_branches(self) -> "unsigned int const &":
        return _core.VAS_System_n_branches(self)

    def n_edges(self) -> "unsigned int const &":
        return _core.VAS_System_n_edges(self)

    def alloc_break(self, i: 'unsigned int const &') -> "unsigned int const &":
        return _core.VAS_System_alloc_break(self, i)

    def n_alloc_break(self) -> "size_t":
        return _core.VAS_System_n_alloc_break(self)

    def size(self) -> "size_t":
        return _core.VAS_System_size(self)

    def display(self) -> "std::string":
        return _core.VAS_System_display(self)

    def display_phenotype(self) -> "std::string":
        return _core.VAS_System_display_phenotype(self)

    def display_edges(self) -> "std::string":
        return _core.VAS_System_display_edges(self)

    def elemental_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.VAS_System_elemental_names(self)

    def elemental_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.VAS_System_elemental_codes(self)

    def all_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.VAS_System_all_codes(self)

    def add_cell(self, *args) -> "int":
        return _core.VAS_System_add_cell(self, *args)

    def regrow(self) -> "void":
        return _core.VAS_System_regrow(self)

    def __init__(self):
        this = _core.new_VAS_System()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_VAS_System
    __del__ = lambda self: None
VAS_System_swigregister = _core.VAS_System_swigregister
VAS_System_swigregister(VAS_System)

class ComponentVector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.ComponentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.ComponentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.ComponentVector___bool__(self)

    def __len__(self) -> "std::vector< elm::LinearComponent >::size_type":
        return _core.ComponentVector___len__(self)

    def __getslice__(self, i: 'std::vector< elm::LinearComponent >::difference_type', j: 'std::vector< elm::LinearComponent >::difference_type') -> "std::vector< elm::LinearComponent,std::allocator< elm::LinearComponent > > *":
        return _core.ComponentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _core.ComponentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< elm::LinearComponent >::difference_type', j: 'std::vector< elm::LinearComponent >::difference_type') -> "void":
        return _core.ComponentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _core.ComponentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< elm::LinearComponent >::value_type const &":
        return _core.ComponentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _core.ComponentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< elm::LinearComponent >::value_type":
        return _core.ComponentVector_pop(self)

    def append(self, x: 'LinearComponent') -> "void":
        return _core.ComponentVector_append(self, x)

    def empty(self) -> "bool":
        return _core.ComponentVector_empty(self)

    def size(self) -> "std::vector< elm::LinearComponent >::size_type":
        return _core.ComponentVector_size(self)

    def swap(self, v: 'ComponentVector') -> "void":
        return _core.ComponentVector_swap(self, v)

    def begin(self) -> "std::vector< elm::LinearComponent >::iterator":
        return _core.ComponentVector_begin(self)

    def end(self) -> "std::vector< elm::LinearComponent >::iterator":
        return _core.ComponentVector_end(self)

    def rbegin(self) -> "std::vector< elm::LinearComponent >::reverse_iterator":
        return _core.ComponentVector_rbegin(self)

    def rend(self) -> "std::vector< elm::LinearComponent >::reverse_iterator":
        return _core.ComponentVector_rend(self)

    def clear(self) -> "void":
        return _core.ComponentVector_clear(self)

    def get_allocator(self) -> "std::vector< elm::LinearComponent >::allocator_type":
        return _core.ComponentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _core.ComponentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< elm::LinearComponent >::iterator":
        return _core.ComponentVector_erase(self, *args)

    def __init__(self, *args):
        this = _core.new_ComponentVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'LinearComponent') -> "void":
        return _core.ComponentVector_push_back(self, x)

    def front(self) -> "std::vector< elm::LinearComponent >::value_type const &":
        return _core.ComponentVector_front(self)

    def back(self) -> "std::vector< elm::LinearComponent >::value_type const &":
        return _core.ComponentVector_back(self)

    def assign(self, n: 'std::vector< elm::LinearComponent >::size_type', x: 'LinearComponent') -> "void":
        return _core.ComponentVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _core.ComponentVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _core.ComponentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< elm::LinearComponent >::size_type') -> "void":
        return _core.ComponentVector_reserve(self, n)

    def capacity(self) -> "std::vector< elm::LinearComponent >::size_type":
        return _core.ComponentVector_capacity(self)
    __swig_destroy__ = _core.delete_ComponentVector
    __del__ = lambda self: None
ComponentVector_swigregister = _core.ComponentVector_swigregister
ComponentVector_swigregister(ComponentVector)

class _base_LinearSubBundle_1(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core._base_LinearSubBundle_1_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core._base_LinearSubBundle_1___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core._base_LinearSubBundle_1___bool__(self)

    def __len__(self) -> "std::map< long long,elm::ComponentList >::size_type":
        return _core._base_LinearSubBundle_1___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::mapped_type const &":
        return _core._base_LinearSubBundle_1___getitem__(self, key)

    def __delitem__(self, key: 'std::map< long long,elm::ComponentList >::key_type const &') -> "void":
        return _core._base_LinearSubBundle_1___delitem__(self, key)

    def has_key(self, key: 'std::map< long long,elm::ComponentList >::key_type const &') -> "bool":
        return _core._base_LinearSubBundle_1_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _core._base_LinearSubBundle_1_keys(self)

    def values(self) -> "PyObject *":
        return _core._base_LinearSubBundle_1_values(self)

    def items(self) -> "PyObject *":
        return _core._base_LinearSubBundle_1_items(self)

    def __contains__(self, key: 'std::map< long long,elm::ComponentList >::key_type const &') -> "bool":
        return _core._base_LinearSubBundle_1___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _core._base_LinearSubBundle_1_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _core._base_LinearSubBundle_1_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _core._base_LinearSubBundle_1___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _core._base_LinearSubBundle_1_asdict(self)

    def __init__(self, *args):
        this = _core.new__base_LinearSubBundle_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _core._base_LinearSubBundle_1_empty(self)

    def size(self) -> "std::map< long long,elm::ComponentList >::size_type":
        return _core._base_LinearSubBundle_1_size(self)

    def swap(self, v: '_base_LinearSubBundle_1') -> "void":
        return _core._base_LinearSubBundle_1_swap(self, v)

    def begin(self) -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_begin(self)

    def end(self) -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_end(self)

    def rbegin(self) -> "std::map< long long,elm::ComponentList >::reverse_iterator":
        return _core._base_LinearSubBundle_1_rbegin(self)

    def rend(self) -> "std::map< long long,elm::ComponentList >::reverse_iterator":
        return _core._base_LinearSubBundle_1_rend(self)

    def clear(self) -> "void":
        return _core._base_LinearSubBundle_1_clear(self)

    def get_allocator(self) -> "std::map< long long,elm::ComponentList >::allocator_type":
        return _core._base_LinearSubBundle_1_get_allocator(self)

    def count(self, x: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::size_type":
        return _core._base_LinearSubBundle_1_count(self, x)

    def erase(self, *args) -> "void":
        return _core._base_LinearSubBundle_1_erase(self, *args)

    def find(self, x: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_find(self, x)

    def lower_bound(self, x: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< long long,elm::ComponentList >::key_type const &') -> "std::map< long long,elm::ComponentList >::iterator":
        return _core._base_LinearSubBundle_1_upper_bound(self, x)
    __swig_destroy__ = _core.delete__base_LinearSubBundle_1
    __del__ = lambda self: None
_base_LinearSubBundle_1_swigregister = _core._base_LinearSubBundle_1_swigregister
_base_LinearSubBundle_1_swigregister(_base_LinearSubBundle_1)

class LinearComponent(object):
    """
    A combination of a parameter and data.

    This class represents a single term of a linear function, i.e. a parameter
    multiplied by some data.  The data may be a single column of raw data
    from a data :class:`Fountain`, or it may be some prescribed function of
    raw data (e.g. logarithm of cost, or cost divided by income); the principal
    requirement is that the data function contains only data and no parameters
    to be estimated, other than the single linear coefficient.

    Parameters
    ----------
    param : :class:`str` or :class:`.ParameterRef`
    	The name of, or reference to, a parameter.
    data : :class:`str` or :class:`.DataRef`
    	The name of, or reference to, some data.  This may be a raw column in
    	a data :class:`Fountain`, or an expression that can be evaluated, including
    	a number expressed as a string. To express a constant (i.e. a parameter
    	with no data) give 1.0.
    multiplier : float
    	A convenient method to multiply the data by a constant, which can
    	be given as a float instead of a string.
    category : None or int or string or tuple
    	Some LinearComponent's apply only to certain things.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _data = _swig_property(_core.LinearComponent__data_get, _core.LinearComponent__data_set)
    _param = _swig_property(_core.LinearComponent__param_get, _core.LinearComponent__param_set)
    _altcode = _swig_property(_core.LinearComponent__altcode_get, _core.LinearComponent__altcode_set)
    _altname = _swig_property(_core.LinearComponent__altname_get, _core.LinearComponent__altname_set)
    _upcode = _swig_property(_core.LinearComponent__upcode_get, _core.LinearComponent__upcode_set)
    _dncode = _swig_property(_core.LinearComponent__dncode_get, _core.LinearComponent__dncode_set)
    multiplier = _swig_property(_core.LinearComponent_multiplier_get, _core.LinearComponent_multiplier_set)

    def __repr__(self) -> "std::string":
        return _core.LinearComponent___repr__(self)

    def __str__(self) -> "std::string":
        return _core.LinearComponent___str__(self)

    def __init__(self, *args, **kwargs):
        this = _core.new_LinearComponent(*args, **kwargs)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    Create = staticmethod(_core.LinearComponent_Create)
    __swig_destroy__ = _core.delete_LinearComponent
    __del__ = lambda self: None

    def __add__(self, *args) -> "elm::ComponentList":
        return _core.LinearComponent___add__(self, *args)

    def altcallsign(self):
    	return "%i: %s"%(self.altcode, self.altname)
    def set_from_callsign(self, x):
    	c,n = x.split(": ")
    	self.altcode = long(c)
    	self.altname = n

    @property
    def data(self):
    	from .roles import DataRef
    	return DataRef(self._data)
    @data.setter
    def data(self, value):
    	self._data = value

    @property
    def param(self):
    	from .roles import ParameterRef
    	return ParameterRef(self._param)
    @param.setter
    def param(self, value):
    	self._param = value

    def __pos__(self):
    	return self

    _add = __add__
    def __add__(self, other):
    	if other==():
    		return self
    	return self._add(other)

    def __radd__(self, other):
    	if other==():
    		return self
    	return self._add(other)

    def __mul__(self,other):
    	from .roles import DataRef
    	if isinstance(other,(int,float,DataRef)):
    		return LinearComponent(data=self.data * other, param=self.param)
    	else:
    		raise TypeError('unsupported operand type(s) for LinearComponent*: {}'.format(type(other)))

    def __rmul__(self,other):
    	from .roles import DataRef
    	if isinstance(other,(int,float,DataRef)):
    		return LinearComponent(data=self.data * other, param=self.param)
    	else:
    		raise TypeError('unsupported operand type(s) for LinearComponent*: {}'.format(type(other)))

    def __imul__(self,other):
    	from .roles import DataRef
    	if isinstance(other,(int,float,DataRef)):
    		self.data = self.data * other
    	else:
    		raise TypeError('unsupported operand type(s) for LinearComponent*: {}'.format(type(other)))

    def __iter__(self):
    	return iter(LinearFunction() + self)

    def __eq__(self, other):
    	if isinstance(other, LinearFunction) and len(other)==1:
    		other = other[0]
    	if not isinstance(other, LinearComponent):
    		return False
    	if self.param != other.param:
    		return False
    	if self.data != other.data:
    		return False
    	if self.multiplier != other.multiplier:
    		return False
    	return True


LinearComponent_swigregister = _core.LinearComponent_swigregister
LinearComponent_swigregister(LinearComponent)

def LinearComponent_Create(obj: 'PyObject *') -> "elm::LinearComponent":
    return _core.LinearComponent_Create(obj)
LinearComponent_Create = _core.LinearComponent_Create

COMPONENTLIST_TYPE_UTILITYCA = _core.COMPONENTLIST_TYPE_UTILITYCA
COMPONENTLIST_TYPE_UTILITYCO = _core.COMPONENTLIST_TYPE_UTILITYCO
COMPONENTLIST_TYPE_LOGSUM = _core.COMPONENTLIST_TYPE_LOGSUM
COMPONENTLIST_TYPE_EDGE = _core.COMPONENTLIST_TYPE_EDGE
COMPONENTLIST_TYPE_SIMPLECO = _core.COMPONENTLIST_TYPE_SIMPLECO
class LinearFunction(ComponentVector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _receiver_type = _swig_property(_core.LinearFunction__receiver_type_get, _core.LinearFunction__receiver_type_set)
    parentmodel = _swig_property(_core.LinearFunction_parentmodel_get, _core.LinearFunction_parentmodel_set)

    def __init__(self, type: 'int'=0, parentmodel: 'Model2'=None):
        this = _core.new_LinearFunction(type, parentmodel)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def receive_utility_ca(self, *args, **kwargs) -> "void":
        return _core.LinearFunction_receive_utility_ca(self, *args, **kwargs)

    def receive_allocation(self, *args, **kwargs) -> "void":
        return _core.LinearFunction_receive_allocation(self, *args, **kwargs)

    def receive_utility_co(self, *args) -> "void":
        return _core.LinearFunction_receive_utility_co(self, *args)

    def receive_utility_co_kwd(self, *args, **kwargs) -> "void":
        return _core.LinearFunction_receive_utility_co_kwd(self, *args, **kwargs)

    def __code__(self) -> "std::string":
        return _core.LinearFunction___code__(self)

    def __str__(self) -> "std::string":
        return _core.LinearFunction___str__(self)

    def __repr__(self) -> "std::string":
        return _core.LinearFunction___repr__(self)

    def __indent_repr__(self, indent: 'int') -> "std::string":
        return _core.LinearFunction___indent_repr__(self, indent)

    def needs(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.LinearFunction_needs(self)

    def _add(self, *args) -> "elm::ComponentList":
        return _core.LinearFunction__add(self, *args)

    def _inplace_add(self, *args) -> "void":
        return _core.LinearFunction__inplace_add(self, *args)

    def __add__(self, other):
    	if other==():
    		return self
    	return self._add(other)
    def __iadd__(self, other):
    	if other==():
    		return self
    	try:
    		self._inplace_add(other)
    	except NotImplementedError as t:
    		t.args = (t.args[0] + "\n  self is type {}\n  other is type {}".format(type(self),type(other)),) + t.args[1:]
    		raise t
    	return self
    def __radd__(self, other):
    	return LinearFunction() + other + self
    def __pos__(self):
    	return self
    def __mul__(self, other):
    	trial = LinearFunction()
    	for component in self:
    		trial += component * other
    	return trial
    def __rmul__(self, other):
    	trial = LinearFunction()
    	for component in self:
    		trial += other * component
    	return trial
    def evaluate(self, dataspace, model):
    	if len(self)>0:
    		i = self[0]
    		y = i.data.eval(**dataspace) * i.param.default_value(0).value(model)
    	for i in self[1:]:
    		y += i.data.eval(**dataspace) * i.param.default_value(0).value(model)
    	return y
    def evaluator1d(self, factorlabel='', x_ident=None):
    	if x_ident is None:
    		try:
    			x_ident = self._x_ident
    		except AttributeError:
    			raise TypeError('a x_ident must be given')
    	if x_ident is None:
    		raise TypeError('a x_ident must be given')
    	from .util.plotting import ComputedFactor
    	return ComputedFactor( label=factorlabel, func=lambda x,m: self.evaluate({x_ident:x}, m) )
    def __contains__(self, val):
    	from .roles import ParameterRef, DataRef
    	if isinstance(val, ParameterRef):
    		for i in self:
    			if i.param==val:
    				return True
    		return False
    	if isinstance(val, DataRef):
    		for i in self:
    			if i.data==val:
    				return True
    		return False
    	raise TypeError("the searched for content must be of type ParameterRef or DataRef")
    def _index_of(self, val):
    	from .roles import ParameterRef, DataRef
    	if isinstance(val, ParameterRef):
    		for n,i in enumerate(self):
    			if i.param==val:
    				return n
    		raise KeyError('ParameterRef not found')
    	if isinstance(val, DataRef):
    		for n,i in enumerate(self):
    			if i.data==val:
    				return n
    		raise KeyError('DataRef not found')
    	raise TypeError("the searched for content must be of type ParameterRef or DataRef")

    def reformat_param(self, container=None, pattern=None, repl=None, **kwargs):
    	"""
    	Transform all the parameters in the LinearFunction.

    	Parameters
    	----------
    	container : str
    		A format string, into which the previous parameters are formatted.
    		Use this to append things to the parameter names.
    	pattern : str
    	repl : str
    		Passed to `re.sub` with each existing parameter as the base string
    		to be searched.
    	"""
    	import re
    	r = LinearFunction()
    	for i in self:
    		if pattern is None:
    			param = i.param
    		else:
    			if repl is None:
    				raise TypeError('must give repl with pattern')
    			param = re.sub(pattern, repl, i.param, **kwargs)
    		if container is None:
    			container = '{}'
    		r += LinearComponent(data=i.data, param=container.format(param), multiplier=i.multiplier)
    	try:
    		r._x_ident = self._x_ident
    	except AttributeError:
    		pass
    	return r

    def reformat_data(self, container=None, pattern=None, repl=None, **kwargs):
    	"""
    	Transform all the data in the LinearFunction.

    	Parameters
    	----------
    	container : str
    		A format string, into which the previous data strings are formatted.
    		Use this to apply common global transforms to the data.
    	pattern : str
    	repl : str
    		Passed to `re.sub` with each existing data string as the base string
    		to be searched.
    	"""
    	import re
    	r = LinearFunction()
    	for i in self:
    		if pattern is None:
    			data = i.data
    		else:
    			if repl is None:
    				raise TypeError('must give repl with pattern')
    			data = re.sub(pattern, repl, i.data, **kwargs)
    		if container is None:
    			container = '{}'
    		r += LinearComponent(data=container.format(data), param=i.param, multiplier=i.multiplier)
    	try:
    		r._x_ident = self._x_ident
    	except AttributeError:
    		pass
    	return r

    def __eq__(self, other):
    	if not isinstance(other, LinearFunction):
    		return False
    	if len(self) != len(other):
    		return False
    	for i,j in zip(self, other):
    		if i != j: return False
    	return True


    def __getstate__(self):
    	state = {}
    	state['code'] = self.__code__()
    	try:
    		state['_x_ident'] = self._x_ident
    	except AttributeError:
    		pass
    	return state

    def __setstate__(self, state):
    	from .roles import P,X
    	self.__init__()
    	self += eval(state['code'])
    	if '_x_ident' in state:
    		self._x_ident = state['_x_ident']



    __swig_destroy__ = _core.delete_LinearFunction
    __del__ = lambda self: None
LinearFunction_swigregister = _core.LinearFunction_swigregister
LinearFunction_swigregister(LinearFunction)

class ComponentCellcodeMap(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, type: 'int'=0, parentmodel: 'Model2'=None):
        this = _core.new_ComponentCellcodeMap(type, parentmodel)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __repr__(self) -> "std::string":
        return _core.ComponentCellcodeMap___repr__(self)

    def _create(self, *args) -> "void":
        return _core.ComponentCellcodeMap__create(self, *args)

    def size(self) -> "unsigned int":
        return _core.ComponentCellcodeMap_size(self)

    def empty(self) -> "bool":
        return _core.ComponentCellcodeMap_empty(self)

    def clear(self) -> "void":
        return _core.ComponentCellcodeMap_clear(self)

    def __getitem__(self, key: 'elm::cellcode const &') -> "elm::LinearComponent &":
        return _core.ComponentCellcodeMap___getitem__(self, key)

    def __setitem__(self, key: 'elm::cellcode const &', x: 'LinearComponent') -> "void":
        return _core.ComponentCellcodeMap___setitem__(self, key, x)

    def __delitem__(self, key: 'elm::cellcode const &') -> "void":
        return _core.ComponentCellcodeMap___delitem__(self, key)

    def __contains__(self, key: 'elm::cellcode const &') -> "bool":
        return _core.ComponentCellcodeMap___contains__(self, key)

    def __len__(self) -> "int":
        return _core.ComponentCellcodeMap___len__(self)

    def _link(self, parent: 'elm::cellcode const &', child: 'elm::cellcode const &') -> "void":
        return _core.ComponentCellcodeMap__link(self, parent, child)

    def nodes(self) -> "std::vector< elm::cellcode,std::allocator< elm::cellcode > >":
        return _core.ComponentCellcodeMap_nodes(self)
    __swig_destroy__ = _core.delete_ComponentCellcodeMap
    __del__ = lambda self: None
ComponentCellcodeMap_swigregister = _core.ComponentCellcodeMap_swigregister
ComponentCellcodeMap_swigregister(ComponentCellcodeMap)

class LinearCOBundle(_base_LinearSubBundle_1):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    parentmodel = _swig_property(_core.LinearCOBundle_parentmodel_get, _core.LinearCOBundle_parentmodel_set)

    def __init__(self, *args):
        this = _core.new_LinearCOBundle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def metasize(self) -> "size_t":
        return _core.LinearCOBundle_metasize(self)

    def __str__(self) -> "std::string":
        return _core.LinearCOBundle___str__(self)

    def __repr__(self) -> "std::string":
        return _core.LinearCOBundle___repr__(self)

    def needs(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.LinearCOBundle_needs(self)

    def add_blank(self, i: 'elm::cellcode const &') -> "elm::ComponentList &":
        return _core.LinearCOBundle_add_blank(self, i)

    def _call(self, *args) -> "void":
        return _core.LinearCOBundle__call(self, *args)

    def __call__(self, altcode, data, param="", multiplier=1.0):
    	if isinstance(altcode, str) and isinstance(data, int):
    		_ = data
    		data = altcode
    		altcode = _
    	if isinstance(altcode, str) and isinstance(data, str):
    		try:
    			a = DB.alternatives(self.parentmodel, 'reversedict')
    			if altcode in a:
    				altcode = a[altcode]
    			elif data in a:
    				_ = a[data]
    				data = altcode
    				altcode = _
    		except AttributeError:
    			raise TypeError('cannot identify alternative')
    	self._call(altcode, data, param, multiplier)

    def __setitem__(self, key, value):
    	parent = self.parentmodel
    	if parent is not None and not parent.option.autocreate_parameters:
    		if isinstance(value, LinearFunction):
    			for i in value:
    				if i.param not in parent:
    					raise KeyError("Parameter '{}' is not found in model and autocreate_parameters is off".format(i.param))
    		if isinstance(value, LinearComponent):
    			if value.param not in parent:
    				raise KeyError("Parameter '{}' is not found in model and autocreate_parameters is off".format(value.param))
    	from .roles import ParameterRef, DataRef
    	if value is None:
    		value = LinearFunction()
    	if isinstance(value, (int,float)):
    		if value==0:
    			value = LinearFunction()
    		else:
    			raise TypeError("Assigning a nonzero fixed value to a utility function is not supported, try using a holdfast parameter instead")
    	if isinstance(value, DataRef):
    		value = LinearComponent(data=str(value))
    	if isinstance(value, ParameterRef):
    		value = LinearComponent(param=value, data='1')
    	if isinstance(value, LinearComponent):
    		value = LinearFunction() + value
    	return super().__setitem__(key, value)

    __swig_destroy__ = _core.delete_LinearCOBundle
    __del__ = lambda self: None
LinearCOBundle_swigregister = _core.LinearCOBundle_swigregister
LinearCOBundle_swigregister(LinearCOBundle)

class LinearBundle(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    descrip = _swig_property(_core.LinearBundle_descrip_get, _core.LinearBundle_descrip_set)

    def __init__(self, *args):
        this = _core.new_LinearBundle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args) -> "void":
        return _core.LinearBundle___call__(self, *args)

    def clean(self, db: 'Facet') -> "void":
        return _core.LinearBundle_clean(self, db)

    def __baserepr__(self) -> "std::string":
        return _core.LinearBundle___baserepr__(self)

    def _set_ca(self, *args) -> "void":
        return _core.LinearBundle__set_ca(self, *args)

    def _set_co(self, x: 'LinearCOBundle') -> "void":
        return _core.LinearBundle__set_co(self, x)

    def _get_ca(self) -> "elm::ComponentList &":
        return _core.LinearBundle__get_ca(self)

    def _get_co(self) -> "elm::LinearCOBundle_1 *":
        return _core.LinearBundle__get_co(self)

    ca = property(lambda self: self._get_ca(), lambda self,x: self._set_ca(x))
    co = property(lambda self: self._get_co(), lambda self,x: self._set_co(x))

    def __getitem__(self, key):
    	return self._get_co().add_blank(key)
    def __setitem__(self, key, value):
    	self._get_co()[key] = value
    def __delitem__(self, key):
    	del self._get_co()[key]
    def __repr__(self):
    	r = self.__baserepr__()
    	r += "\n ca: "+"\n     ".join(repr(self.ca).split("\n"))
    	r += "\n co: "+"\n     ".join(repr(self.co).split("\n"))
    	return r

    __swig_destroy__ = _core.delete_LinearBundle
    __del__ = lambda self: None
LinearBundle_swigregister = _core.LinearBundle_swigregister
LinearBundle_swigregister(LinearBundle)

class LinearFunctionPair(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    descrip = _swig_property(_core.LinearFunctionPair_descrip_get, _core.LinearFunctionPair_descrip_set)

    def __init__(self, *args):
        this = _core.new_LinearFunctionPair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args) -> "void":
        return _core.LinearFunctionPair___call__(self, *args)

    def clean(self, db: 'Facet') -> "void":
        return _core.LinearFunctionPair_clean(self, db)

    def __repr__(self) -> "std::string":
        return _core.LinearFunctionPair___repr__(self)

    def _set_ca(self, *args) -> "void":
        return _core.LinearFunctionPair__set_ca(self, *args)

    def _set_co(self, *args) -> "void":
        return _core.LinearFunctionPair__set_co(self, *args)

    def _get_ca(self) -> "elm::ComponentList &":
        return _core.LinearFunctionPair__get_ca(self)

    def _get_co(self) -> "elm::ComponentList *":
        return _core.LinearFunctionPair__get_co(self)

    def _set_ca_1(self,x):
    #//if type(x) is ParameterRef: x = LinearComponent(param=str(x), data="1")
    	self._set_ca(x)
    def _set_co_1(self,x):
    #//if type(x) is ParameterRef: x = LinearComponent(param=str(x), data="1")
    	self._set_co(x)
    ca = property(lambda self: self._get_ca(), lambda self,x: self._set_ca_1(x))
    co = property(lambda self: self._get_co(), lambda self,x: self._set_co_1(x))

    __swig_destroy__ = _core.delete_LinearFunctionPair
    __del__ = lambda self: None
LinearFunctionPair_swigregister = _core.LinearFunctionPair_swigregister
LinearFunctionPair_swigregister(LinearFunctionPair)

class LinearCOBundle_2(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _receiver_type = _swig_property(_core.LinearCOBundle_2__receiver_type_get, _core.LinearCOBundle_2__receiver_type_set)
    parentmodel = _swig_property(_core.LinearCOBundle_2_parentmodel_get, _core.LinearCOBundle_2_parentmodel_set)

    def __init__(self, parentmodel: 'Model2'=None):
        this = _core.new_LinearCOBundle_2(parentmodel)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __repr__(self) -> "std::string":
        return _core.LinearCOBundle_2___repr__(self)

    def __call__(self, upcode: 'elm::cellcode', dncode: 'elm::cellcode') -> "void":
        return _core.LinearCOBundle_2___call__(self, upcode, dncode)

    def downlinks(self, upcode: 'elm::cellcode const &') -> "std::vector< elm::cellcode,std::allocator< elm::cellcode > >":
        return _core.LinearCOBundle_2_downlinks(self, upcode)

    def size(self) -> "unsigned int":
        return _core.LinearCOBundle_2_size(self)

    def empty(self) -> "bool":
        return _core.LinearCOBundle_2_empty(self)

    def clear(self) -> "void":
        return _core.LinearCOBundle_2_clear(self)

    def __getitem__(self, key: 'cellcodepair') -> "elm::EdgeValue &":
        return _core.LinearCOBundle_2___getitem__(self, key)

    def __setitem__(self, key: 'cellcodepair', x: 'LinearFunction') -> "void":
        return _core.LinearCOBundle_2___setitem__(self, key, x)

    def __delitem__(self, key: 'cellcodepair') -> "void":
        return _core.LinearCOBundle_2___delitem__(self, key)

    def __contains__(self, key: 'cellcodepair') -> "bool":
        return _core.LinearCOBundle_2___contains__(self, key)

    def __len__(self) -> "int":
        return _core.LinearCOBundle_2___len__(self)

    def links(self) -> "::std::vector< elm::cellcodepair,std::allocator< elm::cellcodepair > >":
        return _core.LinearCOBundle_2_links(self)
    __swig_destroy__ = _core.delete_LinearCOBundle_2
    __del__ = lambda self: None
LinearCOBundle_2_swigregister = _core.LinearCOBundle_2_swigregister
LinearCOBundle_2_swigregister(LinearCOBundle_2)

class ComponentGraphDNA(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    db = _swig_property(_core.ComponentGraphDNA_db_get, _core.ComponentGraphDNA_db_set)
    nodes = _swig_property(_core.ComponentGraphDNA_nodes_get, _core.ComponentGraphDNA_nodes_set)
    edges = _swig_property(_core.ComponentGraphDNA_edges_get, _core.ComponentGraphDNA_edges_set)

    def __init__(self, *args):
        this = _core.new_ComponentGraphDNA(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, arg2: 'ComponentGraphDNA') -> "bool":
        return _core.ComponentGraphDNA___eq__(self, arg2)

    def valid(self) -> "bool":
        return _core.ComponentGraphDNA_valid(self)

    def node_name(self, node_code: 'elm::cellcode const &') -> "std::string":
        return _core.ComponentGraphDNA_node_name(self, node_code)

    def node_code(self, node_name: 'std::string const &') -> "elm::cellcode":
        return _core.ComponentGraphDNA_node_code(self, node_name)
    root_code = _swig_property(_core.ComponentGraphDNA_root_code_get, _core.ComponentGraphDNA_root_code_set)

    def __repr__(self) -> "std::string":
        return _core.ComponentGraphDNA___repr__(self)

    def elemental_codes(self) -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_elemental_codes(self)

    def all_node_codes(self) -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_all_node_codes(self)

    def nest_node_codes(self) -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_nest_node_codes(self)

    def elemental_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.ComponentGraphDNA_elemental_names(self)

    def all_node_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.ComponentGraphDNA_all_node_names(self)

    def nest_node_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.ComponentGraphDNA_nest_node_names(self)

    def dn_node_codes(self, node_code: 'elm::cellcode const &') -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_dn_node_codes(self, node_code)

    def up_node_codes(self, node_code: 'elm::cellcode const &', include_implicit_root: 'bool'=True) -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_up_node_codes(self, node_code, include_implicit_root)

    def chain_dn_node_codes(self, node_code: 'elm::cellcode const &') -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_chain_dn_node_codes(self, node_code)

    def chain_up_node_codes(self, node_code: 'elm::cellcode const &') -> "elm::cellcodeset":
        return _core.ComponentGraphDNA_chain_up_node_codes(self, node_code)

    def node_callsign(self, altcode):
    	try:
    		return "%i: %s"%(altcode, self.node_name(altcode))
    	except LarchError:
    		return "%i: %s"%(altcode, "alt_%i"%(altcode))
    def elemental_callsigns(self):
    	return [self.node_callsign(j) for j in self.elemental_codes()]
    def all_node_callsigns(self):
    	return [self.node_callsign(j) for j in self.all_node_codes()]
    def nest_node_callsigns(self):
    	return [self.node_callsign(j) for j in self.nest_node_codes()]
    def dn_node_callsigns(self,code):
    	return [self.node_callsign(j) for j in self.dn_node_codes(code)]
    def up_node_callsigns(self,code):
    	return [self.node_callsign(j) for j in self.up_node_codes(code)]
    def up_node_candidate_callsigns(self,code):
    	candidates = self.nest_node_codes()
    	candidates -= self.chain_dn_node_codes(code)
    	candidates -= code
    	candidates += 0
    	return [self.node_callsign(j) for j in candidates]
    def dn_node_candidate_callsigns(self,code):
    	candidates = self.all_node_codes()
    	candidates -= 0
    	candidates -= self.chain_up_node_codes(code)
    	candidates -= code
    	return [self.node_callsign(j) for j in candidates]

    __swig_destroy__ = _core.delete_ComponentGraphDNA
    __del__ = lambda self: None
ComponentGraphDNA_swigregister = _core.ComponentGraphDNA_swigregister
ComponentGraphDNA_swigregister(ComponentGraphDNA)


def __LinearFunction__call(self, *args, **kwargs):
	try:
		if (self._receiver_type==0):
			raise LarchError("LinearFunction improperly initialized")
		elif (self._receiver_type & COMPONENTLIST_TYPE_UTILITYCA):
			self.receive_utility_ca(*args, **kwargs)
		elif (self._receiver_type & COMPONENTLIST_TYPE_UTILITYCO):
			if len(kwargs)>0 and len(args)==0:
				self.receive_utility_co_kwd(**kwargs)
			elif len(kwargs)==0 and len(args)>0:
				if len(args)<2: raise LarchError("LinearFunction for co type requires at least two arguments: data and alt")
				self.receive_utility_co(*args)
			else:
				raise LarchError("LinearFunction for co type requires all-or-none use of keyword arguments")
		elif (self._receiver_type & COMPONENTLIST_TYPE_EDGE):
			self.receive_allocation(*args, **kwargs)
		else:
			raise LarchError("LinearFunction Not Implemented for type %i list"%self._receiver_type)
####if self.parentmodel:
####	self.parentmodel.freshen()
	except TypeError:
		for arg in args:
			print('type=',type(arg), 'value=',arg)
		for key,arg in kwargs.items():
			print('key=',key,'type=',type(arg), 'value=',arg)
		raise
LinearFunction.__call__ = __LinearFunction__call
del __LinearFunction__call
LinearFunction.__long_len = LinearFunction.__len__
LinearFunction.__len__ = lambda self: int(self.__long_len())

def __ComponentCellcodeMap__call(self, nest_name, nest_code=None, param_name="", multiplier=1.0, parent=None, parents=None, children=None):
	if isinstance(nest_name,(int,)) and nest_code is None:
		nest_name, nest_code = "nest%i"%nest_name, nest_name
	if isinstance(nest_name,(int,)) and isinstance(nest_code,(str,)):
		nest_name, nest_code = nest_code, nest_name
	self._create(nest_name, nest_code, param_name, multiplier)
	if parent is not None:
		self._link(parent,nest_code)
	if parents is not None:
		for p in parents: self._link(p,nest_code)
	if children is not None:
		for c in children: self._link(nest_code,c)
####if self.parentmodel:
####	self.parentmodel.freshen()
	return self[nest_code]
ComponentCellcodeMap.__call__ = __ComponentCellcodeMap__call
del __ComponentCellcodeMap__call

class model_options_t(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    gradient_diagnostic = _swig_property(_core.model_options_t_gradient_diagnostic_get, _core.model_options_t_gradient_diagnostic_set)
    hessian_diagnostic = _swig_property(_core.model_options_t_hessian_diagnostic_get, _core.model_options_t_hessian_diagnostic_set)
    threads = _swig_property(_core.model_options_t_threads_get, _core.model_options_t_threads_set)
    calc_null_likelihood = _swig_property(_core.model_options_t_calc_null_likelihood_get, _core.model_options_t_calc_null_likelihood_set)
    null_disregards_holdfast = _swig_property(_core.model_options_t_null_disregards_holdfast_get, _core.model_options_t_null_disregards_holdfast_set)
    calc_std_errors = _swig_property(_core.model_options_t_calc_std_errors_get, _core.model_options_t_calc_std_errors_set)
    mute_nan_warnings = _swig_property(_core.model_options_t_mute_nan_warnings_get, _core.model_options_t_mute_nan_warnings_set)
    force_finite_diff_grad = _swig_property(_core.model_options_t_force_finite_diff_grad_get, _core.model_options_t_force_finite_diff_grad_set)
    save_db_hash = _swig_property(_core.model_options_t_save_db_hash_get, _core.model_options_t_save_db_hash_set)
    force_recalculate = _swig_property(_core.model_options_t_force_recalculate_get, _core.model_options_t_force_recalculate_set)
    teardown_after_estimate = _swig_property(_core.model_options_t_teardown_after_estimate_get, _core.model_options_t_teardown_after_estimate_set)
    weight_autorescale = _swig_property(_core.model_options_t_weight_autorescale_get, _core.model_options_t_weight_autorescale_set)
    weight_choice_rebalance = _swig_property(_core.model_options_t_weight_choice_rebalance_get, _core.model_options_t_weight_choice_rebalance_set)
    suspend_xylem_rebuild = _swig_property(_core.model_options_t_suspend_xylem_rebuild_get, _core.model_options_t_suspend_xylem_rebuild_set)
    log_turns = _swig_property(_core.model_options_t_log_turns_get, _core.model_options_t_log_turns_set)
    enforce_bounds = _swig_property(_core.model_options_t_enforce_bounds_get, _core.model_options_t_enforce_bounds_set)
    enforce_network_constraints = _swig_property(_core.model_options_t_enforce_network_constraints_get, _core.model_options_t_enforce_network_constraints_set)
    enforce_constraints = _swig_property(_core.model_options_t_enforce_constraints_get, _core.model_options_t_enforce_constraints_set)
    autocreate_parameters = _swig_property(_core.model_options_t_autocreate_parameters_get, _core.model_options_t_autocreate_parameters_set)
    ignore_bad_constraints = _swig_property(_core.model_options_t_ignore_bad_constraints_get, _core.model_options_t_ignore_bad_constraints_set)
    idca_avail_ratio_floor = _swig_property(_core.model_options_t_idca_avail_ratio_floor_get, _core.model_options_t_idca_avail_ratio_floor_set)
    author = _swig_property(_core.model_options_t_author_get, _core.model_options_t_author_set)

    def __init__(self, *args, **kwargs):
        this = _core.new_model_options_t(*args, **kwargs)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, *args, **kwargs) -> "void":
        return _core.model_options_t___call__(self, *args, **kwargs)

    def copy(self, other: 'model_options_t') -> "void":
        return _core.model_options_t_copy(self, other)

    def __repr__(self) -> "std::string":
        return _core.model_options_t___repr__(self)

    def __str__(self) -> "std::string":
        return _core.model_options_t___str__(self)

    def _save_buffer(self) -> "std::string":
        return _core.model_options_t__save_buffer(self)

    def __getitem__(self, k):
    	return getattr(self, k)
    def __setitem__(self, k, v):
    	return setattr(self, k, v)
    def _as_dict(self):
    	keys = dir(self)
    	dct = {}
    	for k in keys:
    		if k[0:2]!="__" and k not in ['copy', 'this', 'thisown', '_as_dict']:
    			dct[k] = getattr(self, k)
    	return dct
    def __setattr__(self, key, value):
    	if key not in dir(self) and key not in ['copy', 'this', 'thisown', '_as_dict']:
    		raise TypeError( "cannot create the new attribute '%s' for %s" % (str(key),str(type(self))) )
    	super(model_options_t, self).__setattr__(key, value)


    __swig_destroy__ = _core.delete_model_options_t
    __del__ = lambda self: None
model_options_t_swigregister = _core.model_options_t_swigregister
model_options_t_swigregister(model_options_t)

class runstats(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    iteration = _swig_property(_core.runstats_iteration_get, _core.runstats_iteration_set)
    results = _swig_property(_core.runstats_results_get, _core.runstats_results_set)
    timestamp = _swig_property(_core.runstats_timestamp_get, _core.runstats_timestamp_set)
    number_threads = _swig_property(_core.runstats_number_threads_get, _core.runstats_number_threads_set)
    number_cpu_cores = _swig_property(_core.runstats_number_cpu_cores_get, _core.runstats_number_cpu_cores_set)
    processor = _swig_property(_core.runstats_processor_get, _core.runstats_processor_set)
    process_label = _swig_property(_core.runstats_process_label_get, _core.runstats_process_label_set)
    process_starttime = _swig_property(_core.runstats_process_starttime_get, _core.runstats_process_starttime_set)
    process_endtime = _swig_property(_core.runstats_process_endtime_get, _core.runstats_process_endtime_set)
    _notes = _swig_property(_core.runstats__notes_get, _core.runstats__notes_set)

    def elapsed_time(self) -> "double":
        return _core.runstats_elapsed_time(self)

    def runtime_seconds(self) -> "double":
        return _core.runstats_runtime_seconds(self)

    def runtime(self) -> "std::string":
        return _core.runstats_runtime(self)

    def __init__(self, *args):
        this = _core.new_runstats(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_runstats
    __del__ = lambda self: None

    def other(self) -> "PyObject *":
        return _core.runstats_other(self)

    def set_other(self, other: 'PyObject *') -> "void":
        return _core.runstats_set_other(self, other)

    def prepend_timing(self, previously: 'runstats') -> "void":
        return _core.runstats_prepend_timing(self, previously)

    def append_timing(self, subsequently: 'runstats') -> "void":
        return _core.runstats_append_timing(self, subsequently)

    def notes(self) -> "std::string":
        return _core.runstats_notes(self)

    def write(self, *args) -> "void":
        return _core.runstats_write(self, *args)

    def flush(self) -> "void":
        return _core.runstats_flush(self)

    def write_result(self, *args) -> "void":
        return _core.runstats_write_result(self, *args)

    def __repr__(self) -> "std::string":
        return _core.runstats___repr__(self)

    def dictionary(self) -> "PyObject *":
        return _core.runstats_dictionary(self)

    def pickled_dictionary(self) -> "std::string":
        return _core.runstats_pickled_dictionary(self)

    def read_from_dictionary(self, dictionary: 'PyObject *') -> "void":
        return _core.runstats_read_from_dictionary(self, dictionary)

    def start_process(self, name: 'std::string const &') -> "void":
        return _core.runstats_start_process(self, name)

    def end_process(self) -> "void":
        return _core.runstats_end_process(self)

    def process_duration(self, *args) -> "double":
        return _core.runstats_process_duration(self, *args)

    def total_duration(self) -> "double":
        return _core.runstats_total_duration(self)

    def process_duration_fancy(self, *args) -> "std::string":
        return _core.runstats_process_duration_fancy(self, *args)

    def total_duration_fancy(self) -> "std::string":
        return _core.runstats_total_duration_fancy(self)

    def __getstate__(self) -> "PyObject *":
        return _core.runstats___getstate__(self)

    def __setstate__(self, state):
    	self.__init__()
    	self.read_from_dictionary(state)

runstats_swigregister = _core.runstats_swigregister
runstats_swigregister(runstats)

class Needs(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _core.Needs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _core.Needs___nonzero__(self)

    def __bool__(self) -> "bool":
        return _core.Needs___bool__(self)

    def __len__(self) -> "std::map< std::string,elm::darray_req >::size_type":
        return _core.Needs___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::mapped_type const &":
        return _core.Needs___getitem__(self, key)

    def __delitem__(self, key: 'std::map< std::string,elm::darray_req >::key_type const &') -> "void":
        return _core.Needs___delitem__(self, key)

    def has_key(self, key: 'std::map< std::string,elm::darray_req >::key_type const &') -> "bool":
        return _core.Needs_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _core.Needs_keys(self)

    def values(self) -> "PyObject *":
        return _core.Needs_values(self)

    def items(self) -> "PyObject *":
        return _core.Needs_items(self)

    def __contains__(self, key: 'std::map< std::string,elm::darray_req >::key_type const &') -> "bool":
        return _core.Needs___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _core.Needs_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _core.Needs_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _core.Needs___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _core.Needs_asdict(self)

    def __init__(self, *args):
        this = _core.new_Needs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _core.Needs_empty(self)

    def size(self) -> "std::map< std::string,elm::darray_req >::size_type":
        return _core.Needs_size(self)

    def swap(self, v: 'Needs') -> "void":
        return _core.Needs_swap(self, v)

    def begin(self) -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_begin(self)

    def end(self) -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_end(self)

    def rbegin(self) -> "std::map< std::string,elm::darray_req >::reverse_iterator":
        return _core.Needs_rbegin(self)

    def rend(self) -> "std::map< std::string,elm::darray_req >::reverse_iterator":
        return _core.Needs_rend(self)

    def clear(self) -> "void":
        return _core.Needs_clear(self)

    def get_allocator(self) -> "std::map< std::string,elm::darray_req >::allocator_type":
        return _core.Needs_get_allocator(self)

    def count(self, x: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::size_type":
        return _core.Needs_count(self, x)

    def erase(self, *args) -> "void":
        return _core.Needs_erase(self, *args)

    def find(self, x: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_find(self, x)

    def lower_bound(self, x: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< std::string,elm::darray_req >::key_type const &') -> "std::map< std::string,elm::darray_req >::iterator":
        return _core.Needs_upper_bound(self, x)

    def __repr__(self):
    	return "<Needs:" + ",".join(["{}({})".format(i,len(j.get_variables())) for i,j in self.items()]) + ">"

    __swig_destroy__ = _core.delete_Needs
    __del__ = lambda self: None
Needs_swigregister = _core.Needs_swigregister
Needs_swigregister(Needs)

class darray_req(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    dtype = _swig_property(_core.darray_req_dtype_get, _core.darray_req_dtype_set)
    dimty = _swig_property(_core.darray_req_dimty_get, _core.darray_req_dimty_set)
    n_alts = _swig_property(_core.darray_req_n_alts_get, _core.darray_req_n_alts_set)
    contig = _swig_property(_core.darray_req_contig_get, _core.darray_req_contig_set)

    def __init__(self, *args):
        this = _core.new_darray_req(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_darray_req
    __del__ = lambda self: None

    def nVars(self) -> "size_t":
        return _core.darray_req_nVars(self)

    def nAlts(self) -> "size_t":
        return _core.darray_req_nAlts(self)

    def get_variables(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _core.darray_req_get_variables(self)

    def set_variables(self, v: 'StrVector') -> "void":
        return _core.darray_req_set_variables(self, v)

    def __str__(self) -> "std::string":
        return _core.darray_req___str__(self)

    def __repr__(self) -> "std::string":
        return _core.darray_req___repr__(self)

    def satisfied_by(self, x: 'elm::darray const *') -> "int":
        return _core.darray_req_satisfied_by(self, x)
darray_req_swigregister = _core.darray_req_swigregister
darray_req_swigregister(darray_req)

class darray_export_map(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, caseindexes: 'etk::ndarray *'=None, altindexes: 'etk::ndarray *'=None, data_array: 'etk::ndarray *'=None, n_cases: 'size_t const &'=0, n_alts: 'size_t const &'=0):
        this = _core.new_darray_export_map(caseindexes, altindexes, data_array, n_cases, n_alts)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_darray_export_map
    __del__ = lambda self: None

    def maplink(self, caseindexes: 'etk::ndarray *', altindexes: 'etk::ndarray *', data_array: 'etk::ndarray *', n_cases: 'size_t const &', n_alts: 'size_t const &') -> "void":
        return _core.darray_export_map_maplink(self, caseindexes, altindexes, data_array, n_cases, n_alts)

    def clear(self) -> "void":
        return _core.darray_export_map_clear(self)

    def get_ptr_at(self, caseindex: 'long long const &', altindex: 'long long const &') -> "double const *":
        return _core.darray_export_map_get_ptr_at(self, caseindex, altindex)

    def export_into(self, ExportTo: 'double *', c: 'unsigned int const &', a: 'unsigned int const &', numberOfVars: 'unsigned int const &') -> "void":
        return _core.darray_export_map_export_into(self, ExportTo, c, a, numberOfVars)

    def get_value_at(self, caseindex: 'long long const &', altindex: 'long long const &', varindex: 'long long const &') -> "double":
        return _core.darray_export_map_get_value_at(self, caseindex, altindex, varindex)

    def active(self) -> "bool":
        return _core.darray_export_map_active(self)

    def nvars(self) -> "size_t":
        return _core.darray_export_map_nvars(self)

    def nrows(self) -> "size_t":
        return _core.darray_export_map_nrows(self)

    def ncases(self) -> "size_t const &":
        return _core.darray_export_map_ncases(self)

    def nalts(self) -> "size_t const &":
        return _core.darray_export_map_nalts(self)
darray_export_map_swigregister = _core.darray_export_map_swigregister
darray_export_map_swigregister(darray_export_map)


def check_darray(x: 'elm::darray const *') -> "std::string":
    return _core.check_darray(x)
check_darray = _core.check_darray
class ParameterList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    _parameter_name_index = _swig_property(_core.ParameterList__parameter_name_index_get, _core.ParameterList__parameter_name_index_set)

    def __init__(self, *args):
        this = _core.new_ParameterList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __contains__(self, param_name: 'std::string const &') -> "bool":
        return _core.ParameterList___contains__(self, param_name)

    def _len(self) -> "size_t":
        return _core.ParameterList__len(self)

    def parameter_index(self, param_name: 'std::string const &') -> "size_t":
        return _core.ParameterList_parameter_index(self, param_name)

    def zeros(self) -> "PyObject *":
        return _core.ParameterList_zeros(self)

    def tearDown(self) -> "void":
        return _core.ParameterList_tearDown(self)

    def freshen(self) -> "void":
        return _core.ParameterList_freshen(self)
    __swig_destroy__ = _core.delete_ParameterList
    __del__ = lambda self: None
ParameterList_swigregister = _core.ParameterList_swigregister
ParameterList_swigregister(ParameterList)


ParameterList.__len__ = lambda self: int(self._len())

class ParameterAlias(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    name = _swig_property(_core.ParameterAlias_name_get, _core.ParameterAlias_name_set)
    refers_to = _swig_property(_core.ParameterAlias_refers_to_get, _core.ParameterAlias_refers_to_set)
    multiplier = _swig_property(_core.ParameterAlias_multiplier_get, _core.ParameterAlias_multiplier_set)
    _refers_to_modelparam = _swig_property(_core.ParameterAlias__refers_to_modelparam_get, _core.ParameterAlias__refers_to_modelparam_set)

    def get_referred_modelparam(self) -> "PyObject *":
        return _core.ParameterAlias_get_referred_modelparam(self)

    def set_referred_modelparam(self, arg2: 'PyObject *') -> "void":
        return _core.ParameterAlias_set_referred_modelparam(self, arg2)
    __swig_destroy__ = _core.delete_ParameterAlias
    __del__ = lambda self: None

    def __init__(self, name: 'std::string const &', refers_to: 'std::string const &', multiplier: 'double const &'):
        this = _core.new_ParameterAlias(name, refers_to, multiplier)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __repr__(self) -> "std::string":
        return _core.ParameterAlias___repr__(self)

    def __str__(self) -> "std::string":
        return _core.ParameterAlias___str__(self)

    @property
    def value(self):
    	return self.multiplier * self.get_referred_modelparam().value
    @property
    def null_value(self):
    	return self.multiplier * self.get_referred_modelparam().null_value
    @property
    def t_stat(self):
    	if self.multiplier == 1:
    		return "= {}".format(self.refers_to)
    	elif self.multiplier == 0:
    		return "= 0"
    	else:
    		return "= {} * {}".format(self.refers_to,self.multiplier)
    def __getitem__(self, *arg):
    	return self.__getattribute__(*arg)


ParameterAlias_swigregister = _core.ParameterAlias_swigregister
ParameterAlias_swigregister(ParameterAlias)


def algorithm_name(algo: 'char const &') -> "std::string":
    return _core.algorithm_name(algo)
algorithm_name = _core.algorithm_name
class sherpa_result(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    starting_obj_value = _swig_property(_core.sherpa_result_starting_obj_value_get, _core.sherpa_result_starting_obj_value_set)
    best_obj_value = _swig_property(_core.sherpa_result_best_obj_value_get, _core.sherpa_result_best_obj_value_set)
    result = _swig_property(_core.sherpa_result_result_get, _core.sherpa_result_result_set)
    explain_stop = _swig_property(_core.sherpa_result_explain_stop_get, _core.sherpa_result_explain_stop_set)

    def __init__(self):
        this = _core.new_sherpa_result()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_sherpa_result
    __del__ = lambda self: None
sherpa_result_swigregister = _core.sherpa_result_swigregister
sherpa_result_swigregister(sherpa_result)

class sherpa(ParameterList):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    _LL_current = _swig_property(_core.sherpa__LL_current_get, _core.sherpa__LL_current_set)
    _LL_best = _swig_property(_core.sherpa__LL_best_get, _core.sherpa__LL_best_set)
    max_iterations = _swig_property(_core.sherpa_max_iterations_get, _core.sherpa_max_iterations_set)

    def robust_covariance_matrix(self) -> "etk::symmetric_matrix *":
        return _core.sherpa_robust_covariance_matrix(self)

    def __init__(self, *args):
        this = _core.new_sherpa(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def any_holdfast(self) -> "bool":
        return _core.sherpa_any_holdfast(self)

    def count_holdfast(self) -> "size_t":
        return _core.sherpa_count_holdfast(self)

    def hessfull_to_hessfree(self, full_matrix: 'etk::symmetric_matrix const *', free_matrix: 'etk::symmetric_matrix *') -> "void":
        return _core.sherpa_hessfull_to_hessfree(self, full_matrix, free_matrix)

    def hessfree_to_hessfull(self, full_matrix: 'etk::symmetric_matrix *', free_matrix: 'etk::symmetric_matrix const *') -> "void":
        return _core.sherpa_hessfree_to_hessfull(self, full_matrix, free_matrix)

    def resize_allocated_memory(self) -> "void":
        return _core.sherpa_resize_allocated_memory(self)

    def _get_inverse_hessian_array(self) -> "etk::symmetric_matrix *":
        return _core.sherpa__get_inverse_hessian_array(self)

    def _set_inverse_hessian_array(self, arg2: 'etk::symmetric_matrix *') -> "void":
        return _core.sherpa__set_inverse_hessian_array(self, arg2)

    def _del_inverse_hessian_array(self) -> "void":
        return _core.sherpa__del_inverse_hessian_array(self)

    def _get_robust_covar_array(self) -> "etk::symmetric_matrix *":
        return _core.sherpa__get_robust_covar_array(self)

    def _set_robust_covar_array(self, arg2: 'etk::symmetric_matrix *') -> "void":
        return _core.sherpa__set_robust_covar_array(self, arg2)

    def _del_robust_covar_array(self) -> "void":
        return _core.sherpa__del_robust_covar_array(self)

    def _get_parameter_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_parameter_array(self)

    def _get_parameter_minbound_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_parameter_minbound_array(self)

    def _get_parameter_maxbound_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_parameter_maxbound_array(self)

    def _get_holdfast_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_holdfast_array(self)

    def _get_null_values_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_null_values_array(self)

    def _get_init_values_array(self) -> "etk::ndarray *":
        return _core.sherpa__get_init_values_array(self)

    def _set_parameter_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_parameter_array(self, arg2)

    def _set_parameter_minbound_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_parameter_minbound_array(self, arg2)

    def _set_parameter_maxbound_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_parameter_maxbound_array(self, arg2)

    def _set_holdfast_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_holdfast_array(self, arg2)

    def _set_null_values_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_null_values_array(self, arg2)

    def _set_init_values_array(self, arg2: 'etk::ndarray *') -> "void":
        return _core.sherpa__set_init_values_array(self, arg2)

    parameter_array = property(_get_parameter_array, None, None, "An array of current parameter values")
    parameter_minimums = property(_get_parameter_minbound_array, None, None, "An array of minimum parameter values")
    parameter_maximums = property(_get_parameter_maxbound_array, None, None, "An array of maximum parameter values")
    parameter_holdfast_array = property(_get_holdfast_array, None, None, "An array of current holdfast flags")
    parameter_initial_values_array = property(_get_init_values_array, None, None, "An array of initial parameter values")
    parameter_null_values_array = property(_get_null_values_array, None, None, "An array of parameter null values")


    def parameter(self, *args, **kwargs) -> "elm::ModelParameter":
        return _core.sherpa_parameter(self, *args, **kwargs)

    def __getitem__(self, *args) -> "elm::ModelParameter":
        return _core.sherpa___getitem__(self, *args)

    def alias(self, *args) -> "elm::ModelAlias":
        return _core.sherpa_alias(self, *args)

    def del_alias(self, alias_name: 'std::string const &') -> "void":
        return _core.sherpa_del_alias(self, alias_name)

    def unlink_alias(self, alias_name: 'std::string const &') -> "void":
        return _core.sherpa_unlink_alias(self, alias_name)
    __swig_destroy__ = _core.delete_sherpa
    __del__ = lambda self: None
sherpa_swigregister = _core.sherpa_swigregister
sherpa_swigregister(sherpa)

class Model2(sherpa):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def _xylem(self) -> "elm::VAS_System const &":
        return _core.Model2__xylem(self)

    def _sayweakself(self, *args) -> "void":
        return _core.Model2__sayweakself(self, *args)

    def _setweakself(self, ref_to_self: 'PyObject *') -> "void":
        return _core.Model2__setweakself(self, ref_to_self)

    def _get_root_cellcode(self) -> "elm::cellcode":
        return _core.Model2__get_root_cellcode(self)

    def _set_root_cellcode(self, r: 'elm::cellcode const &') -> "void":
        return _core.Model2__set_root_cellcode(self, r)
    _nCases_recall = _swig_property(_core.Model2__nCases_recall_get, _core.Model2__nCases_recall_set)

    def _force_feed(self, forced_features: 'int') -> "void":
        return _core.Model2__force_feed(self, forced_features)

    def freshen(self) -> "void":
        return _core.Model2_freshen(self)

    def CoefUtilityCA(self) -> "PyObject *":
        return _core.Model2_CoefUtilityCA(self)

    def CoefUtilityCO(self) -> "PyObject *":
        return _core.Model2_CoefUtilityCO(self)

    def Coef(self, label: 'std::string const &') -> "etk::ndarray const *":
        return _core.Model2_Coef(self, label)

    def needs(self) -> "std::map< std::string,elm::darray_req,std::less< std::string >,std::allocator< std::pair< std::string const,elm::darray_req > > >":
        val = _core.Model2_needs(self)

        temp = {}
        for i,j in val.items(): temp[i] = j
        val = temp


        return val


    def provision(self, *args) -> "void":

        if len(args)==0:
        	if hasattr(self,'df') and isinstance(self.df,(DB,DT)):
        		args = (self.df.provision(self.needs()), )
        	else:
        		raise LarchError('model has no df specified for provisioning')


        return _core.Model2_provision(self, *args)


    def is_provisioned(self, ex: 'bool'=False) -> "int":
        return _core.Model2_is_provisioned(self, ex)

    def Data(self, label: 'std::string const &') -> "elm::darray const *":
        return _core.Model2_Data(self, label)

    def DataEdit(self, label: 'std::string const &') -> "elm::darray *":
        return _core.Model2_DataEdit(self, label)
    Data_UtilityCE_manual = _swig_property(_core.Model2_Data_UtilityCE_manual_get, _core.Model2_Data_UtilityCE_manual_set)
    Data_UtilityCE_builtin = _swig_property(_core.Model2_Data_UtilityCE_builtin_get, _core.Model2_Data_UtilityCE_builtin_set)
    Data_SamplingCE_builtin = _swig_property(_core.Model2_Data_SamplingCE_builtin_get, _core.Model2_Data_SamplingCE_builtin_set)

    def get_weight_scale_factor(self) -> "double":
        return _core.Model2_get_weight_scale_factor(self)

    def auto_rescale_weights(self, mean_weight: 'double const &'=1.0) -> "std::string":
        return _core.Model2_auto_rescale_weights(self, mean_weight)

    def restore_scale_weights(self) -> "void":
        return _core.Model2_restore_scale_weights(self)

    def clear_cache(self) -> "void":
        return _core.Model2_clear_cache(self)

    def loglike(self) -> "double":
        return _core.Model2_loglike(self)

    def loglike_casewise(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_loglike_casewise(self, *args)

    def _gradient_casewise(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2__gradient_casewise(self, *args)

    def finite_diff_gradient(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_finite_diff_gradient(self, *args)

    def calc_utility(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_utility(self, *args)

    def calc_probability(self, u: 'etk::ndarray *') -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_probability(self, u)

    def calc_logsums(self, u: 'etk::ndarray *') -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_logsums(self, u)

    def calc_utility_probability(self, utilitydataco: 'etk::ndarray *', utilitydataca: 'etk::ndarray *'=None, availability: 'etk::ndarray *'=None) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_utility_probability(self, utilitydataco, utilitydataca, availability)

    def calc_utility_logsums(self, utilitydataco: 'etk::ndarray *', utilitydataca: 'etk::ndarray *'=None, availability: 'etk::ndarray *'=None) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_calc_utility_logsums(self, utilitydataco, utilitydataca, availability)

    def d_logsums(self) -> "PyObject *":
        return _core.Model2_d_logsums(self)

    def loglike_given_utility(self) -> "double":
        return _core.Model2_loglike_given_utility(self)

    def negative_d_loglike_given_utility(self) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_negative_d_loglike_given_utility(self)

    def calculate_parameter_covariance(self) -> "void":
        return _core.Model2_calculate_parameter_covariance(self)

    def _mnl_gradient_full_casewise(self) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2__mnl_gradient_full_casewise(self)

    def _ngev_gradient_full_casewise(self, singlethread: 'bool'=False) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2__ngev_gradient_full_casewise(self, singlethread)

    def _ngev_d_prob(self) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2__ngev_d_prob(self)

    def log_likelihood_from_prob(self, probarray: 'etk::ndarray *') -> "double":
        return _core.Model2_log_likelihood_from_prob(self, probarray)

    def _get_top_logsums_out(self) -> "PyObject *":
        return _core.Model2__get_top_logsums_out(self)

    def _set_top_logsums_out(self, arg2: 'PyObject *') -> "void":
        return _core.Model2__set_top_logsums_out(self, arg2)

    def _del_top_logsums_out(self) -> "void":
        return _core.Model2__del_top_logsums_out(self)

    def _get_casewise_grad_buffer(self) -> "PyObject *":
        return _core.Model2__get_casewise_grad_buffer(self)

    def _set_casewise_grad_buffer(self, setval: 'PyObject *') -> "void":
        return _core.Model2__set_casewise_grad_buffer(self, setval)

    def _del_casewise_grad_buffer(self) -> "void":
        return _core.Model2__del_casewise_grad_buffer(self)

    def _get_casewise_d_logsums(self) -> "PyObject *":
        return _core.Model2__get_casewise_d_logsums(self)

    def _set_casewise_d_logsums(self, setval: 'PyObject *') -> "void":
        return _core.Model2__set_casewise_d_logsums(self, setval)

    def _del_casewise_d_logsums(self) -> "void":
        return _core.Model2__del_casewise_d_logsums(self)

    def top_logsums_out_currently_valid(self) -> "bool":
        return _core.Model2_top_logsums_out_currently_valid(self)

    def _setUp_NNNL_host(self, ncases: 'unsigned int const &') -> "void":
        return _core.Model2__setUp_NNNL_host(self, ncases)

    def _parameter_report(self, other1: 'etk::ndarray const *'=None, other2: 'etk::ndarray const *'=None) -> "std::string":
        return _core.Model2__parameter_report(self, other1, other2)
    _LL_null = _swig_property(_core.Model2__LL_null_get, _core.Model2__LL_null_set)
    _LL_nil = _swig_property(_core.Model2__LL_nil_get, _core.Model2__LL_nil_set)
    _LL_constants = _swig_property(_core.Model2__LL_constants_get, _core.Model2__LL_constants_set)

    def write_runstats_note(self, comment: 'std::string const &') -> "void":
        return _core.Model2_write_runstats_note(self, comment)

    def read_runstats_notes(self) -> "std::string":
        return _core.Model2_read_runstats_notes(self)

    def start_timing(self, name: 'std::string const &') -> "void":
        return _core.Model2_start_timing(self, name)

    def finish_timing(self) -> "void":
        return _core.Model2_finish_timing(self)

    def alias_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Model2_alias_names(self)

    def probability(self, params: 'etk::ndarray *'=None) -> "etk::ndarray *":
        return _core.Model2_probability(self, params)

    def _get_hessian_array(self) -> "etk::symmetric_matrix *":
        return _core.Model2__get_hessian_array(self)

    def _set_hessian_array(self, arg2: 'etk::symmetric_matrix *') -> "void":
        return _core.Model2__set_hessian_array(self, arg2)

    def _del_hessian_array(self) -> "void":
        return _core.Model2__del_hessian_array(self)

    def parameter_values(self, *args) -> "void":
        return _core.Model2_parameter_values(self, *args)

    def parameter_values_as_bytes(self) -> "PyObject *":
        return _core.Model2_parameter_values_as_bytes(self)

    def utilityca(self, *args) -> "void":
        return _core.Model2_utilityca(self, *args)

    def utilityco(self, *args) -> "void":
        return _core.Model2_utilityco(self, *args)
    utility = _swig_property(_core.Model2_utility_get, _core.Model2_utility_set)
    quantity = _swig_property(_core.Model2_quantity_get, _core.Model2_quantity_set)
    quantity_scale = _swig_property(_core.Model2_quantity_scale_get, _core.Model2_quantity_scale_set)
    nest = _swig_property(_core.Model2_nest_get, _core.Model2_nest_set)
    link = _swig_property(_core.Model2_link_get, _core.Model2_link_set)
    samplingbias = _swig_property(_core.Model2_samplingbias_get, _core.Model2_samplingbias_set)

    def Input_Graph(self) -> "elm::ComponentGraphDNA":
        return _core.Model2_Input_Graph(self)

    def logger(self, l: 'PyObject *'=None) -> "PyObject *":
        return _core.Model2_logger(self, l)
    _string_sender_ptr = _swig_property(_core.Model2__string_sender_ptr_get, _core.Model2__string_sender_ptr_set)
    option = _swig_property(_core.Model2_option_get, _core.Model2_option_set)

    def _maximize_bhhh(self) -> "elm::runstats":
        return _core.Model2__maximize_bhhh(self)

    def loglike_null(self) -> "double":
        return _core.Model2_loglike_null(self)

    def estimate(self, *args) -> "elm::runstats":

        if self._ref_to_db is not None and self.is_provisioned()==0:
        	self.provision()
        	self.setUpMessage = "autoprovision yes (estimate)"
        	if self.logger(): self.logger().info("autoprovisioned data from database")


        return _core.Model2_estimate(self, *args)


    def estimate_tight(self, magnitude: 'double'=8) -> "elm::runstats":
        return _core.Model2_estimate_tight(self, magnitude)

    def _get_parameter(self) -> "PyObject *":
        return _core.Model2__get_parameter(self)

    def _get_nest(self) -> "PyObject *":
        return _core.Model2__get_nest(self)

    def _get_link(self) -> "PyObject *":
        return _core.Model2__get_link(self)

    def _get_utilityca(self) -> "PyObject *":
        return _core.Model2__get_utilityca(self)

    def _get_utilityco(self) -> "PyObject *":
        return _core.Model2__get_utilityco(self)

    def _get_samplingbiasca(self) -> "PyObject *":
        return _core.Model2__get_samplingbiasca(self)

    def _get_samplingbiasco(self) -> "PyObject *":
        return _core.Model2__get_samplingbiasco(self)

    def _get_logger(self) -> "PyObject *":
        return _core.Model2__get_logger(self)

    def _get_estimation_statistics(self) -> "PyObject *":
        return _core.Model2__get_estimation_statistics(self)

    def _get_estimation_run_statistics(self) -> "PyObject *":
        return _core.Model2__get_estimation_run_statistics(self)

    def _set_estimation_statistics(self, *args, **kwargs) -> "void":
        return _core.Model2__set_estimation_statistics(self, *args, **kwargs)

    def _set_estimation_run_statistics_pickle(self, dict: 'PyObject *') -> "void":
        return _core.Model2__set_estimation_run_statistics_pickle(self, dict)

    def prints(self, precision: 'unsigned int const &'=5, cell_width: 'unsigned int const &'=11) -> "std::string":
        return _core.Model2_prints(self, precision, cell_width)

    def full_report(self, precision: 'unsigned int const &'=5, cell_width: 'unsigned int const &'=11) -> "std::string":
        return _core.Model2_full_report(self, precision, cell_width)

    def __repr__(self) -> "std::string":
        return _core.Model2___repr__(self)

    def __init__(self, *args):
        this = _core.new_Model2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        try:
        	from . import _autoinit_loggers
        except:
        	pass
        else:
        	if _autoinit_loggers:
        		self.logger(1)
        try:
        	self._ref_to_db = args[0]
        except IndexError:
        	self._ref_to_db = None
        from .logging import easy_logging_active
        if easy_logging_active():
        	self.logger(True)
        try:
        	self._pull_graph_from_db()
        except LarchError:
        	pass
        from .util import dicta
        self.descriptions = dicta()



    __swig_destroy__ = _core.delete_Model2
    __del__ = lambda self: None

    def delete_data_fountain(self) -> "void":
        val = _core.Model2_delete_data_fountain(self)

        self._ref_to_db = None


        return val


    def change_data_fountain(self, datafile: 'Fountain') -> "void":
        return _core.Model2_change_data_fountain(self, datafile)

    def setUp(self, and_load_data: 'bool'=True, force: 'bool'=False, cache: 'bool'=False, check_validity: 'bool'=True) -> "void":

        if self.logger(): self.logger().log(20, "Model.setUp...")
        if self._ref_to_db is not None and self.is_provisioned()==0 and and_load_data:
        	self.provision(cache=cache)
        	self.setUpMessage = "autoprovision yes (setUp)"
        	if self.logger(): self.logger().info("autoprovisioned data from database")


        val = _core.Model2_setUp(self, and_load_data, force, cache, check_validity)

        if self.logger(): self.logger().log(20, "Model.setUp complete")


        return val


    def _pull_graph_from_db(self) -> "void":
        return _core.Model2__pull_graph_from_db(self)
    setUpMessage = _swig_property(_core.Model2_setUpMessage_get, _core.Model2_setUpMessage_set)

    def tearDown(self) -> "void":
        return _core.Model2_tearDown(self)

    def unprovision(self) -> "void":
        return _core.Model2_unprovision(self)
    title = _swig_property(_core.Model2_title_get, _core.Model2_title_set)

    def save_buffer(self) -> "std::string":
        return _core.Model2_save_buffer(self)

    def negative_d_loglike(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_negative_d_loglike(self, *args)

    def negative_d_loglike_cached(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_negative_d_loglike_cached(self, *args)

    def negative_d_loglike_nocache(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_negative_d_loglike_nocache(self, *args)

    def bhhh_cached(self, *args) -> "std::shared_ptr< etk::symmetric_matrix >":
        return _core.Model2_bhhh_cached(self, *args)

    def bhhh_nocache(self, *args) -> "std::shared_ptr< etk::symmetric_matrix >":
        return _core.Model2_bhhh_nocache(self, *args)

    def bhhh(self, *args) -> "std::shared_ptr< etk::symmetric_matrix >":
        return _core.Model2_bhhh(self, *args)

    def bhhh_direction(self, *args) -> "std::shared_ptr< etk::ndarray >":
        return _core.Model2_bhhh_direction(self, *args)

    def bhhh_tolerance(self, *args) -> "double":
        return _core.Model2_bhhh_tolerance(self, *args)

    def bhhh_tolerance_nocache(self, *args) -> "double":
        return _core.Model2_bhhh_tolerance_nocache(self, *args)

    def Utility(self) -> "etk::ndarray *":
        return _core.Model2_Utility(self)

    def Probability(self) -> "etk::ndarray *":
        return _core.Model2_Probability(self)

    def Cond_Prob(self) -> "etk::ndarray *":
        return _core.Model2_Cond_Prob(self)

    def Allocation(self) -> "etk::ndarray *":
        return _core.Model2_Allocation(self)

    def Quantity(self) -> "etk::ndarray *":
        return _core.Model2_Quantity(self)

    def CaseLogLike(self) -> "etk::ndarray *":
        return _core.Model2_CaseLogLike(self)

    def SamplingWeight(self) -> "etk::ndarray *":
        return _core.Model2_SamplingWeight(self)

    def AdjProbability(self) -> "etk::ndarray *":
        return _core.Model2_AdjProbability(self)

    def nAlts(self) -> "unsigned long long":
        return _core.Model2_nAlts(self)

    def nCases(self) -> "unsigned long long":
        return _core.Model2_nCases(self)

    def alternative_names(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _core.Model2_alternative_names(self)

    def alternative_codes(self) -> "std::vector< long long,std::allocator< long long > >":
        return _core.Model2_alternative_codes(self)

    def _compute_d2_loglike(self, *args) -> "void":
        return _core.Model2__compute_d2_loglike(self, *args)

    def teardown(self) -> "void":
        return _core.Model2_teardown(self)
Model2_swigregister = _core.Model2_swigregister
Model2_swigregister(Model2)

class autoindex_string(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def at_index(self, index: 'size_t const &') -> "std::string const &":
        return _core.autoindex_string_at_index(self, index)

    def __len__(self) -> "size_t":
        return _core.autoindex_string___len__(self)

    def clear(self) -> "void":
        return _core.autoindex_string_clear(self)

    def strings(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _core.autoindex_string_strings(self)

    def drop(self, codex: 'std::string const &') -> "size_t":
        return _core.autoindex_string_drop(self, codex)

    def __contains__(self, codex: 'std::string const &') -> "bool":
        return _core.autoindex_string___contains__(self, codex)

    def __init__(self, *args):
        this = _core.new_autoindex_string(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_autoindex_string
    __del__ = lambda self: None

    def extend(self, init: 'StrVector') -> "void":
        return _core.autoindex_string_extend(self, init)

    def index_from_string(self, codex: 'std::string const &') -> "size_t":
        return _core.autoindex_string_index_from_string(self, codex)

    def string_from_index(self, index: 'size_t const &') -> "std::string":
        return _core.autoindex_string_string_from_index(self, index)

    def reorder(self, replacement_list: 'StrVector') -> "void":
        return _core.autoindex_string_reorder(self, replacement_list)

    def __getitem__(self, key):
    	if isinstance(key, int):
    		if key<len(self):
    			if key>=0:
    				return key
    			else:
    				key = len(self)+key
    				if key<0:
    					raise IndexError()
    				return key
    		else:
    			raise IndexError()
    	elif isinstance(key, str):
    		return self.index_from_string(key)
    	elif isinstance(key, bytes):
    		return self.index_from_string(key.decode('utf8'))
    def __repr__(self):
    	return "larch.core.autoindex_string(" + repr(self.strings()) + ")"

autoindex_string_swigregister = _core.autoindex_string_swigregister
autoindex_string_swigregister(autoindex_string)

class ModelParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _core.new_ModelParameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_ModelParameter
    __del__ = lambda self: None

    def _get_value(self) -> "double":
        return _core.ModelParameter__get_value(self)

    def _set_value(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_value(self, value)

    def _get_min(self) -> "double":
        return _core.ModelParameter__get_min(self)

    def _set_min(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_min(self, value)

    def _del_min(self) -> "void":
        return _core.ModelParameter__del_min(self)

    def _get_max(self) -> "double":
        return _core.ModelParameter__get_max(self)

    def _set_max(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_max(self, value)

    def _del_max(self) -> "void":
        return _core.ModelParameter__del_max(self)

    def _set_std_err(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_std_err(self, value)

    def _set_t_stat(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_t_stat(self, value)

    def _get_std_err(self) -> "double":
        return _core.ModelParameter__get_std_err(self)

    def _get_t_stat(self) -> "double":
        return _core.ModelParameter__get_t_stat(self)

    def _get_robust_std_err(self) -> "double":
        return _core.ModelParameter__get_robust_std_err(self)

    def _get_name(self) -> "std::string":
        return _core.ModelParameter__get_name(self)

    def _get_holdfast(self) -> "signed char":
        return _core.ModelParameter__get_holdfast(self)

    def _set_holdfast(self, *args) -> "void":
        return _core.ModelParameter__set_holdfast(self, *args)

    def _del_holdfast(self) -> "void":
        return _core.ModelParameter__del_holdfast(self)

    def _get_nullvalue(self) -> "double":
        return _core.ModelParameter__get_nullvalue(self)

    def _set_nullvalue(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_nullvalue(self, value)

    def _get_initvalue(self) -> "double":
        return _core.ModelParameter__get_initvalue(self)

    def _set_initvalue(self, value: 'double const &') -> "void":
        return _core.ModelParameter__set_initvalue(self, value)

    def _get_index(self) -> "size_t":
        return _core.ModelParameter__get_index(self)

    def _get_complete_covariance_matrix(self) -> "etk::symmetric_matrix *":
        return _core.ModelParameter__get_complete_covariance_matrix(self)

    def _get_model(self) -> "PyObject *":
        return _core.ModelParameter__get_model(self)

    value = property(_get_value, _set_value, None, "the current value for the parameter")
    null_value = property(_get_nullvalue, _set_nullvalue, None, "the null value for the parameter (used for null models and t-stats)")
    initial_value = property(_get_initvalue, _set_initvalue, None, "the initial value of the parameter")
    minimum = property(_get_min, _set_min, _del_min, "the min bound for the parameter during estimation")
    min_value = minimum
    maximum = property(_get_max, _set_max, _del_max, "the max bound for the parameter during estimation")
    max_value = maximum
    holdfast = property(_get_holdfast, _set_holdfast, _del_holdfast, "a flag indicating if the parameter value should be held fast (constrained to keep its value) during estimation")
    std_err = property(_get_std_err, None, None, "the standard error of the estimator (read-only)")
    robust_std_err = property(_get_robust_std_err, None, None, "the robust standard error of the estimator via bhhh sandwich (read-only)")
    name = property(_get_name, None, None, "the parameter name (read-only)")
    @property
    def name_(self):
    	return self.name.replace(" ","_")
    index = property(_get_index, None, None, "the parameter index within the model (read-only)")
    def _get_t_stat_or_replacement(self):
    	if self.holdfast>0:
    		return "fixed value"
    	t = self._get_t_stat()
    	if numpy.isfinite(t):
    		return t
    	try:
    		t1= self._get_model().t_stat_replacements[self._get_index()]
    		if t1 is None:
    			t1 = t
    		return t1
    	except:
    		return t
    t_stat = property(_get_t_stat_or_replacement, None, None, "the t-statistic for the estimator (read-only)")
    def __repr__(self):
    	return "ModelParameter('{}', value={})".format(self.name, self.value)
    @property
    def covariance(self):
    	"the covariance of the estimator (read-only)"
    	slot = self.index
    	cov = self._get_complete_covariance_matrix()
    	model = self._get_model()
    	ret = {}
    	for name, val in zip(model.parameter_names(), cov[:,slot]):
    		ret[name] = val
    	return ret
    @property
    def robust_covariance(self):
    	"the robust covariance of the estimator via bhhh sandwich (read-only)"
    	slot = self.index
    	model = self._get_model()
    	cov = model.robust_covariance_matrix
    	ret = {}
    	for name, val in zip(model.parameter_names(), cov[:,slot]):
    		ret[name] = val
    	return ret
    def __call__(self, **kwargs):
    	for key,val in kwargs.items():
    		setattr(self,key,val)

ModelParameter_swigregister = _core.ModelParameter_swigregister
ModelParameter_swigregister(ModelParameter)

class ModelAlias(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _core.new_ModelAlias(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_ModelAlias
    __del__ = lambda self: None

    def _get_value(self) -> "double":
        return _core.ModelAlias__get_value(self)

    def _get_min(self) -> "double":
        return _core.ModelAlias__get_min(self)

    def _get_max(self) -> "double":
        return _core.ModelAlias__get_max(self)

    def _get_std_err(self) -> "std::string":
        return _core.ModelAlias__get_std_err(self)

    def _get_t_stat(self) -> "std::string":
        return _core.ModelAlias__get_t_stat(self)

    def _get_robust_std_err(self) -> "std::string":
        return _core.ModelAlias__get_robust_std_err(self)

    def _get_name(self) -> "std::string":
        return _core.ModelAlias__get_name(self)

    def _get_holdfast(self) -> "signed char":
        return _core.ModelAlias__get_holdfast(self)

    def _get_nullvalue(self) -> "double":
        return _core.ModelAlias__get_nullvalue(self)

    def _get_initvalue(self) -> "double":
        return _core.ModelAlias__get_initvalue(self)

    def _get_refers_to(self) -> "std::string":
        return _core.ModelAlias__get_refers_to(self)

    def _set_refers_to(self, other: 'std::string const &') -> "void":
        return _core.ModelAlias__set_refers_to(self, other)

    def _get_multiplier(self) -> "double":
        return _core.ModelAlias__get_multiplier(self)

    def _set_multiplier(self, other: 'double const &') -> "void":
        return _core.ModelAlias__set_multiplier(self, other)

    def _get_model(self) -> "PyObject *":
        return _core.ModelAlias__get_model(self)

    value = property(_get_value, None, None, "the current value for the parameter")
    null_value = property(_get_nullvalue, None, None, "the null value for the parameter (used for null models and t-stats)")
    initial_value = property(_get_initvalue, None, None, "the initial value of the parameter")
    minimum = property(_get_min, None, None, "the min bound for the parameter during estimation")
    min_value = minimum
    maximum = property(_get_max, None, None, "the max bound for the parameter during estimation")
    max_value = maximum
    holdfast = property(_get_holdfast, None, None, "a flag indicating if the parameter value should be held fast (constrained to keep its value) during estimation")
    std_err = property(_get_std_err, None, None, "the standard error of the estimator (read-only)")
    robust_std_err = property(_get_robust_std_err, None, None, "the robust standard error of the estimator via bhhh sandwich (read-only)")
    name = property(_get_name, None, None, "the alias name (read-only)")
    refers_to = property(_get_refers_to, _set_refers_to, None, "the name of the parameter to which this alias refers")
    multiplier = property(_get_multiplier, _set_multiplier, None, "the multiplier of the referred parameter")
    @property
    def name_(self):
    	return self.name.replace(" ","_")
    t_stat = property(_get_t_stat, None, None, "the t-statistic for the estimator (read-only)")
    def __repr__(self):
    	return "ModelAlias('{}', value={})".format(self.name, self.value)
    def __call__(self, **kwargs):
    	for key,val in kwargs.items():
    		setattr(self,key,val)
    def describe(self):
    	return self.name+" "+self._get_std_err()

ModelAlias_swigregister = _core.ModelAlias_swigregister
ModelAlias_swigregister(ModelAlias)



