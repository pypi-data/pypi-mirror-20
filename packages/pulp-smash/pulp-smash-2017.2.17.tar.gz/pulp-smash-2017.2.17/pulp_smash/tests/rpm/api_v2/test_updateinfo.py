# coding=utf-8
"""Test updateinfo XML generated by yum distributor."""
import unittest
from urllib.parse import urljoin
from xml.etree import ElementTree

from packaging.version import Version
from requests.exceptions import HTTPError

from pulp_smash import api, config, selectors, utils
from pulp_smash.constants import (
    ORPHANS_PATH,
    REPOSITORY_PATH,
    RPM,
    RPM_ERRATUM_ID,
    RPM_ERRATUM_RPM_NAME,
    RPM_NAMESPACES,
    RPM_PKGLISTS_UPDATEINFO_FEED_URL,
    RPM_SIGNED_FEED_URL,
    RPM_UNSIGNED_FEED_URL,
)
from pulp_smash.tests.rpm.api_v2.utils import (
    gen_distributor,
    gen_repo,
    get_repodata,
    get_repodata_repomd_xml,
)
from pulp_smash.tests.rpm.utils import check_issue_2277, set_up_module


def setUpModule():  # pylint:disable=invalid-name
    """Possibly skip the tests in this module.

    Skip tests if `Pulp #2277 <https://pulp.plan.io/issues/2277>`_ affects us.
    """
    set_up_module()
    cfg = config.get_config()
    if cfg.version < Version('2.11') and check_issue_2277(cfg):
        raise unittest.SkipTest('https://pulp.plan.io/issues/2277')


def _gen_errata_typical():
    """Generate and return a typical erratum with a unique ID."""
    return {
        'id': utils.uuid4(),
        'description': (
            'This sample description contains some non-ASCII characters '
            ', such as: 汉堡™, and also contains a long line which some '
            'systems may be tempted to wrap.  It will be tested to see '
            'if the string survives a round-trip through the API and '
            'back out of the yum distributor as XML without any '
            'modification.'
        ),
        'issued': '2015-03-05 05:42:53 UTC',
        'pkglist': [{
            'name': 'pkglist-name',
            'packages': [{
                'arch': 'i686',
                'epoch': '0',
                'filename': 'libpfm-4.4.0-9.el7.i686.rpm',
                'name': 'libpfm',
                'release': '9.el7',
                'src': 'libpfm-4.4.0-9.el7.src.rpm',
                'sum': [
                    'sha256',
                    ('ca42a0d97fd99a195b30f9256823a46c94f632c126ab4fbbdd7e1276'
                     '41f30ee4')
                ],
                'version': '4.4.0',
            }],
        }],
        'references': [{
            'href': 'https://example.com/errata/PULP-2017-1234.html',
            'id': 'PULP-2017:1234',
            'title': 'PULP-2017:1234',
            'type': 'self'
        }],
        'solution': 'sample solution',
        'status': 'final',
        'title': 'sample title',
        'type': 'pulp',
        'version': '6',  # intentionally string, not int
    }


def _gen_errata_no_pkglist():
    """Generate and return an erratum with no package list and a unique ID."""
    return {
        'description': 'this unit has no packages',
        'id': utils.uuid4(),
        'issued': '2015-04-05 05:42:53 UTC',
        'solution': 'solution for no pkglist',
        'status': 'final',
        'title': 'no pkglist',
        'type': 'PULP',
        'version': '9',
    }


def _get_updates_by_id(update_info_tree):
    """Return each "update" element in ``update_info_tree``, keyed by ID.

    :param update_info_tree: An ``Element``.
    :returns: A dict in the form ``{id, update_element}``.
    """
    return {
        update.findall('id')[0].text: update
        for update in update_info_tree.findall('update')
    }


class UpdateInfoTestCase(utils.BaseAPITestCase):
    """Tests to ensure ``updateinfo.xml`` can be created and is valid."""

    @classmethod
    def setUpClass(cls):
        """Create an RPM repository, upload errata, and publish the repository.

        More specifically, do the following:

        1. Create an RPM repository with a distributor.
        2. Generate a pair of errata. Upload them to Pulp and import them into
           the repository.
        3. Publish the repository. Fetch the ``updateinfo.xml`` file from the
           distributor (via ``repomd.xml``), and parse it.
        """
        super(UpdateInfoTestCase, cls).setUpClass()
        cls.errata = {
            'import_no_pkglist': _gen_errata_no_pkglist(),
            'import_typical': _gen_errata_typical(),
        }
        cls.tasks = {}  # {'import_no_pkglist': (…), 'import_typical': (…)}

        # Create a repository and add a yum distributor.
        client = api.Client(cls.cfg, api.json_handler)
        body = gen_repo()
        body['distributors'] = [gen_distributor()]
        repo = client.post(REPOSITORY_PATH, body)
        repo = client.get(repo['_href'], params={'details': True})
        cls.resources.add(repo['_href'])

        # Import errata into our repository. Publish the repository.
        for key, erratum in cls.errata.items():
            report = utils.upload_import_erratum(
                cls.cfg,
                erratum,
                repo['_href'],
            )
            cls.tasks[key] = tuple(api.poll_spawned_tasks(cls.cfg, report))
        utils.publish_repo(cls.cfg, repo)

        # Fetch and parse updateinfo.xml (or updateinfo.xml.gz), via repomd.xml
        cls.root_element = (
            get_repodata(cls.cfg, repo['distributors'][0], 'updateinfo')
        )

    def test_root(self):
        """Assert the root element of the tree has a tag of "updates"."""
        self.assertEqual(self.root_element.tag, 'updates')

    def test_one_update_per_errata(self):
        """Assert there is one "update" element per importer erratum."""
        update_elements = self.root_element.findall('update')
        self.assertEqual(len(update_elements), len(self.errata))

    def test_update_ids_alone(self):
        """Assert each "update" element has one "id" child element.

        Each "update" element has an "id" child element. Each parent should
        have exactly one of these children.
        """
        for update_element in self.root_element.findall('update'):
            with self.subTest(update_element=update_element):
                self.assertEqual(len(update_element.findall('id')), 1)

    def test_update_ids_unique(self):
        """Assert each update ID is unique.

        Each "update" element has an "id" child element. These IDs should be
        unique.
        """
        update_ids = set()
        for update_element in self.root_element.findall('update'):
            for id_element in update_element.findall('id'):
                update_id = id_element.text
                with self.subTest(update_id=update_id):
                    self.assertNotIn(update_id, update_ids)
                    update_ids.add(update_id)

    def test_one_task_per_import(self):
        """Assert only one task is spawned per erratum upload."""
        for key, tasks in self.tasks.items():
            with self.subTest(key=key):
                self.assertEqual(len(tasks), 1)

    def test_tasks_state(self):
        """Assert each task's state is "finished".

        This test assumes :meth:`test_one_task_per_import` passes.
        """
        for key, tasks in self.tasks.items():
            with self.subTest(key=key):
                self.assertEqual(tasks[0]['state'], 'finished')

    def test_tasks_result(self):
        """Assert each task's result success flag (if present) is true.

        This test assumes :meth:`test_one_task_per_import` passes.
        """
        for key, tasks in self.tasks.items():
            with self.subTest(key=key):
                if 'result' not in tasks[0]:
                    continue
                result = tasks[0]['result']
                self.assertTrue(result['success_flag'], result)

    def test_erratum_description(self):
        """Assert the update info tree has a correct erratum description.

        This test case uploads an erratum that has an interesting description
        with non-ASCII characters, long lines, etc. The erratum description is
        later made available in the update info tree. Verify the description is
        unchanged.
        """
        erratum = self.errata['import_typical']
        update_element = _get_updates_by_id(self.root_element)[erratum['id']]
        description_elements = update_element.findall('description')
        self.assertEqual(len(description_elements), 1, description_elements)
        self.assertEqual(description_elements[0].text, erratum['description'])

    def test_reboot_not_suggested(self):
        """Assert the update info tree does not suggest a spurious reboot.

        The ``import_typical`` erratum does not suggest that a reboot be
        applied. As a result, the relevant ``<update>`` element in the
        ``updateinfo.xml`` file should not have a ``<reboot_suggested>`` tag.
        Verify that this is so. See `Pulp #2032`_.

        .. NOTE:: In previous versions of Pulp, if no reboot should be applied,
            a ``<reboot_suggested>False</reboot_suggested>`` element would be
            present. See `Pulp #1782`_.

        .. _Pulp #1782: https://pulp.plan.io/issues/1782
        .. _Pulp #2032: https://pulp.plan.io/issues/2032
        """
        if selectors.bug_is_untestable(2032, self.cfg.version):
            self.skipTest('https://pulp.plan.io/issues/2032')
        erratum_id = self.errata['import_typical']['id']
        update_element = _get_updates_by_id(self.root_element)[erratum_id]
        reboot_elements = update_element.findall('reboot_suggested')
        self.assertEqual(
            len(reboot_elements),
            0,
            [ElementTree.tostring(elem) for elem in reboot_elements],
        )


class ErratumPkgListCountTestCase(utils.BaseAPITestCase):
    """Tests for ``updateinfo.xml`` erratum package list count."""

    @classmethod
    def setUpClass(cls):
        """Create RPM repository, delete a package, and publish the repository.

        More specifically, do the following:

        1. Create an RPM repository with a distributor.
        2. Sync the created repository.
        3. Remove the ``gorilla`` package
        4. Publish the repository. Fetch the ``updateinfo.xml`` file from the
           distributor (via ``repomd.xml``), and parse it.
        """
        super(ErratumPkgListCountTestCase, cls).setUpClass()

        # Create a repository.
        client = api.Client(cls.cfg, api.json_handler)
        body = gen_repo()
        body['importer_config']['feed'] = RPM_SIGNED_FEED_URL
        body['distributors'] = [gen_distributor()]
        repo = client.post(REPOSITORY_PATH, body)
        repo = client.get(repo['_href'], params={'details': True})
        cls.resources.add(repo['_href'])

        # Sync the repo.
        utils.sync_repo(cls.cfg, repo['_href'])

        # Remove the gorilla package unit
        client.post(
            urljoin(repo['_href'], 'actions/unassociate/'),
            {'criteria': {'filters': {'unit': {'name': RPM_ERRATUM_RPM_NAME}}}}
        )

        # Publish the repository
        utils.publish_repo(cls.cfg, repo)

        # Fetch and parse updateinfo.xml (or updateinfo.xml.gz), via repomd.xml
        root_element = (
            get_repodata(cls.cfg, repo['distributors'][0], 'updateinfo')
        )

        # Fetch the erratum and erratum pkglist for the gorilla package
        updates = _get_updates_by_id(root_element)
        erratum = updates[RPM_ERRATUM_ID]
        cls.erratum_pkglists = erratum.findall('pkglist')

    def test_one_pkglist(self):
        """Ensure there is only one pkglist element on a erratum."""
        self.assertEqual(len(self.erratum_pkglists), 1)

    def test_pkglist_children(self):
        """Ensure pkglist children structure.

        Check if the erratum pkglist have the following structure::

            <collection short="">
                <name>1</name>
            </collection>
        """
        pkglist = self.erratum_pkglists[0]
        names = pkglist.findall('collection[@short=""]/name')
        with self.subTest(comment='pkglist have one name children'):
            self.assertEqual(len(names), 1)
        name = names[0]
        with self.subTest(comment='name have no children'):
            self.assertEqual(len(name.getchildren()), 0)
        with self.subTest(comment='name have 1 as text'):
            self.assertEqual(name.text, '1')


class PkglistsTestCase(unittest.TestCase):
    """Sync a repository whose updateinfo file has multiple pkglist sections.

    This test case targets `Pulp #2227 <https://pulp.plan.io/issues/2227>`_.
    """

    def test_all(self):
        """Sync a repo whose updateinfo file has multiple pkglist sections.

        Do the following:

        1. Create and sync a repository with an importer and distributor.
           Ensure the importer's feed is set to
           :data:`pulp_smash.constants.RPM_PKGLISTS_UPDATEINFO_FEED_URL`.
        2. Publish the repository, and fetch and parse its updateinfo file.
        3. Verify the updateinfo contains the correct number of ``<pkglists>``
           sections, with the correct contents in each.
        """
        cfg = config.get_config()
        if selectors.bug_is_untestable(2227, cfg.version):
            self.skipTest('https://pulp.plan.io/issues/2277')

        # Create and sync a repository.
        client = api.Client(cfg, api.json_handler)
        body = gen_repo()
        body['importer_config']['feed'] = RPM_PKGLISTS_UPDATEINFO_FEED_URL
        body['distributors'] = [gen_distributor()]
        repo = client.post(REPOSITORY_PATH, body)
        repo = client.get(repo['_href'], params={'details': True})
        self.addCleanup(client.delete, repo['_href'])
        utils.sync_repo(cfg, repo['_href'])

        # Publish the repository, and fetch and parse its updateinfo file.
        self.assertEqual(len(repo['distributors']), 1, repo['distributors'])
        utils.publish_repo(cfg, repo)
        root_element = get_repodata(cfg, repo['distributors'][0], 'updateinfo')

        # Verify the contents of the updateinfo file.
        debug = ElementTree.tostring(root_element)
        pkglists = root_element.find('update').findall('pkglist')
        self.assertEqual(len(pkglists), 3, debug)

        collections = [pkglist.find('collection') for pkglist in pkglists]
        names = {collection.find('name').text for collection in collections}
        self.assertEqual(names, {'1', '2', '3'}, debug)

        packages = {
            collection.find('package').find('filename').text
            for collection in collections
        }
        self.assertEqual(packages, {
            'penguin-0.9.1-1.noarch.rpm',
            'shark-0.1-1.noarch.rpm',
            'walrus-5.21-1.noarch.rpm',
        }, debug)


class CleanUpTestCase(unittest.TestCase):
    """Test whether old ``updateinfo.xml`` files are cleaned up.

    Do the following:

    1. Create, populate and publish a repository. Verify that an
       ``updateinfo.xml`` file is present and can be downloaded.
    2. Add an additional content unit to the repository, and publish it again.
       Verify that the ``updateinfo.xml`` file created by the first publish is
       no longer available, and that a new ``updateinfo.xml`` file is
       available.

    This procedure targets `Pulp #2096 <https://pulp.plan.io/issues/2096>`_.
    Note that the second publish must be an incremental publish.
    """

    @classmethod
    def setUpClass(cls):
        """Create and sync a repository."""
        cls.cfg = config.get_config()
        client = api.Client(cls.cfg, api.json_handler)
        body = gen_repo()
        body['distributors'] = [gen_distributor()]
        body['importer_config']['feed'] = RPM_UNSIGNED_FEED_URL
        cls.repo = client.post(REPOSITORY_PATH, body)
        try:
            cls.repo = client.get(cls.repo['_href'], params={'details': True})
        except:
            cls.tearDownClass()
            raise
        cls.updateinfo_xml_hrefs = []

    @classmethod
    def tearDownClass(cls):
        """Remove the created repository and any orphans."""
        client = api.Client(cls.cfg)
        client.delete(cls.repo['_href'])
        client.delete(ORPHANS_PATH)

    def test_01_first_publish(self):
        """Populate and publish the repository."""
        utils.sync_repo(self.cfg, self.repo['_href'])
        client = api.Client(self.cfg)
        client.post(urljoin(self.repo['_href'], 'actions/unassociate/'), {
            'criteria': {
                'filters': {'unit': {'filename': RPM}},
                'type_ids': ('rpm',),
            }
        })
        utils.publish_repo(self.cfg, self.repo)
        self.updateinfo_xml_hrefs.append(self.get_updateinfo_xml_href())

        with self.subTest(comment='check number of RPMs in repo'):
            units = (
                utils.search_units(self.cfg, self.repo, {'type_ids': ('rpm',)})
            )
            self.assertEqual(len(units), 31)
        with self.subTest(comment='check updateinfo.xml is available'):
            client.get(self.updateinfo_xml_hrefs[0])

    def test_02_second_publish(self):
        """Add an additional content unit and publish the repository again."""
        utils.sync_repo(self.cfg, self.repo['_href'])
        utils.publish_repo(self.cfg, self.repo)
        self.updateinfo_xml_hrefs.append(self.get_updateinfo_xml_href())

        client = api.Client(self.cfg)
        with self.subTest(comment='check number of RPMs in repo'):
            units = (
                utils.search_units(self.cfg, self.repo, {'type_ids': ('rpm',)})
            )
            self.assertEqual(len(units), 32)
        with self.subTest(comment='check updateinfo.xml has a new path'):
            # pylint:disable=no-value-for-parameter
            self.assertNotEqual(*self.updateinfo_xml_hrefs)
        with self.subTest(comment='check old updateinfo.xml is unavailable'):
            with self.assertRaises(HTTPError):
                client.get(self.updateinfo_xml_hrefs[0])
        with self.subTest(comment='check new updateinfo.xml is available'):
            client.get(self.updateinfo_xml_hrefs[1])

    def get_updateinfo_xml_href(self):
        """Return the path to the ``updateinfo.xml`` file."""
        # Download and search through ``.../repodata/repomd.xml``.
        distributor = self.repo['distributors'][0]
        repomd_xml = get_repodata_repomd_xml(self.cfg, distributor)
        xpath = (
            "{{{namespace}}}data[@type='updateinfo']/{{{namespace}}}location"
            .format(namespace=RPM_NAMESPACES['metadata/repo'])
        )
        location_elements = repomd_xml.findall(xpath)

        # Build the URL to the updateinfo.xml file.
        path = urljoin('/pulp/repos/', distributor['config']['relative_url'])
        if not path.endswith('/'):
            path += '/'
        path = urljoin(path, location_elements[0].get('href'))
        return path
