'''
Installer script for activation and deactivation of the entrydir_pypath module in the
user-specific Python initialization hook.
'''

import os
import sys
import site
import shutil
import tempfile
import tokenize

INIT_COMMAND = 'import entrydir_pypath'


def find_init_command_rows(module):
    '''
    Returns a list indices for unindented rows that match the entrydir_pypath initialization
    command. The index of the starting row of the file is 0.
    '''
    init_names = INIT_COMMAND.split()
    indent = 0
    index = 0
    init_rows = []
    with open(module) as handle:
        for token in tokenize.generate_tokens(handle.readline):
            if token[0] == tokenize.NEWLINE:
                if indent == 0:
                    index = 0
            elif token[0] == tokenize.NL:
                pass
            elif token[0] == tokenize.INDENT:
                indent += 1
                index = None
            elif token[0] == tokenize.DEDENT:
                indent -= 1
                if indent == 0:
                    index = 0
            elif token[0] == tokenize.NAME:
                if index is not None and token[1] == init_names[index]:
                    index += 1
                    if index == len(init_names):
                        init_rows.append(token[2][0] - 1)
                        index = None
            else:
                index = None

    return init_rows


def find_insert_row(module):
    '''
    Finds a row that is suitable for insertion of the entrydir_pypath initialization command.
    The index of the starting row of the file is 0.
    '''
    prev_break = None
    last_break = None
    with open(module) as handle:
        for token in tokenize.generate_tokens(handle.readline):
            if token[0] in [tokenize.NEWLINE, tokenize.NL]:
                prev_break = last_break
                last_break = token
            elif token[0] == tokenize.INDENT:
                last_break = prev_break
                break
            elif token[0] == tokenize.NAME:
                if token[2][1] == 0 and token[1] not in ['import', 'from']:
                    break

    if last_break is None:
        return 0
    return last_break[2][0]


def get_reconfig(module, activate):
    '''
    Sets up the contents of a reconfigured module with the specified state of activation for
    initialization of entrydir_pypath. Return None if no change of the module contents is
    required.
    '''
    with open(module) as handle:
        config = handle.readlines()

    command_rows = find_init_command_rows(module)
    if activate:
        if command_rows:
            return None
        insert_row = find_insert_row(module)
        head = config[:insert_row]
        tail = config[insert_row:]
        mid = []
        if head and head[-1].rstrip() != '':
            mid.append('\n')
        mid.append(INIT_COMMAND + '\n')
        if tail and tail[0].rstrip() != '':
            mid.append('\n')
        return head + mid + tail

    if not command_rows:
        return None

    reconfig = config
    command_rows.reverse()
    for index in command_rows:
        head = reconfig[:index]
        tail = reconfig[index + 1:]
        if head and tail and head[-1].rstrip() == '' and tail[0].rstrip == '':
            head.pop()
        reconfig = head + tail
    return reconfig


def config_usercustomize(activate):
    '''
    Configures activation and deactivation of the entrydir_pypath module in the user-specific
    Python initialization hook in accorcance with the specified state of activation.
    '''
    base = site.USER_SITE
    if not os.path.exists(base):
        os.makedirs(base)

    package = os.path.join(base, 'usercustomize')
    if os.path.isdir(package):
        module = os.path.join(package, '__init__.py')
    else:
        module = os.path.join(base, 'usercustomize.py')

    if not os.path.exists(module):
        if activate:
            with open(module, 'w') as handle:
                handle.write(INIT_COMMAND + '\n')
        return

    reconfig = get_reconfig(module, activate)
    if reconfig is None:
        return

    # Just remove the module if it matches a one-line file generated by this installer
    if not reconfig and module.endswith('usercustomize.py'):
        os.remove(module)
        if os.path.isfile(module + 'c'):
            os.remove(module + 'c')
        return

    with tempfile.NamedTemporaryFile('w', -1, '.tmp', os.path.basename(module) + '-',
                                     os.path.dirname(module), False) as handle:
        tmpnew = handle.name
        handle.writelines(reconfig)

    backup = module + '.bak'
    if not os.path.exists(backup):
        shutil.copy(module, backup)

    tmpold = module + '.bak.tmp'
    if os.path.exists(tmpold):
        os.remove(tmpold)

    os.rename(module, tmpold)
    os.rename(tmpnew, module)
    os.remove(tmpold)


def main():
    '''
    Postinstallation entry point for package configuration.
    '''
    script = os.path.basename(sys.argv[0])
    arg = sys.argv[1] if len(sys.argv) >= 2 else ''
    if arg == '-install':
        config_usercustomize(True)
        return
    elif arg == '-remove':
        config_usercustomize(False)
        return
    elif arg in ['-h', '--h'] or 'help' in arg:
        print('Python user-hook configuration utility for entrydir_pypath')
        print('')
        print(script + ' -install')
        print('        activates entrydir_pypath in the usercustimize module')
        print('')
        print(script + ' -remove')
        print('        deactivates entrydir_pypath in the usercustimize module')
        print('')
        print(script + ' -help')
        print('        prints this message')
        print('')
        return

    sys.stderr.write(script + ': Invalid command line arguments. ' +
                     'Use -help to display usage information.\n')
    return 1


if __name__ == "__main__":
    sys.exit(main())
