# -*- coding: utf-8 -*-
"""
some quick concepts:

thresholds: https://en.wikipedia.org/wiki/Thresholding_(image_processing)
    unimodal: https://en.wikipedia.org/wiki/Unimodal_thresholding
    techniques : http://pequan.lip6.fr/~bereziat/pima/2012/seuillage/sezgin04.pdf
    useful functions: http://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html
Region growing: https://en.wikipedia.org/wiki/Region_growing
    use: cv2.floodFill, cv2.watershed
    watershed: https://en.wikipedia.org/wiki/Watershed_(image_processing)
    watershed example: http://docs.opencv.org/3.1.0/d3/db4/tutorial_py_watershed.html#gsc.tab=0
"""
from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from builtins import zip
from builtins import range
from past.utils import old_div


import cv2
import matplotlib.animation as animation
import matplotlib.pyplot as plt
import numpy as np

from RRtoolbox.lib.arrayops.basic import convertXY,overlayXY, overlay, normalize, \
    isnumpy, anorm2
from RRtoolbox.lib.arrayops.convert import spoint2opointfunc
from RRtoolbox.lib.arrayops.filters import smooth,normsigmoid, filterFactory
from RRtoolbox.lib.arrayops.mask import brightness, thresh_biggestCnt
from RRtoolbox.lib.directory import Directory
from RRtoolbox.lib.image import getcoors, ImCoors, random_color
from RRtoolbox.lib.plotter import Plotim

base = "/mnt/4E443F99443F82AF/MEGAsync/"#"/media/davtoh/DavtohDisk1/Davtoh/University/"
IMAGEPATH = Directory(base + "TESIS/DATA_RAW/IMAGES")
SAVETO = Directory(base + "TESIS/DATA_PROCESSED/Tests")

def printParams(params, header = True, epilog = True, width = 100):
    """
    print dictionary parameters.

    :param params: dictionary generated by globals() or locals()
    :param header: if True uses header or if string uses it.
    :param epilog: if True uses epilog or if string uses it.
    :param width: header and epilog width
    :return:
    """
    if header is True:
        header="These Are The Parameters:".center(width,"*")
    if header: print(header)
    for key,val in list(params.items()):
        print("{}: {}".format(key,val))
    if epilog is True:
        epilog="*"*width
    if epilog: print(epilog)

def correctString(string, includeSpaces = True, replace = None):
    """
    Changes invalid characters.

    :param string: str
    :param includeSpaces: if True string includes spaces, else suppress them
    :param replace: use replace character for invalid
    :return: corrected string
    """
    parts = []
    for e in string:
        if e.isalnum():
            parts.append(e)
        elif includeSpaces and e==" ":
            parts.append(e)
        elif replace:
            parts.append(replace)
    return ''.join(parts)

def hist_cdf(img,window_len=0,window='hanning'):
    """
    get image histogram and the normalized cumulative distribution function.

    :param img: imaeg
    :param window_len:
    :param window:
    :return: histogram (int), normalized cdf (float)
    """
    hist,bins = np.histogram(img.flatten(),256,[0,256])
    if window_len: hist = smooth(hist,window_len,window) # if window_len=0 => no filter
    cdf = hist.cumsum() # cumulative distribution function
    cdf_normalized = cdf*float(hist.max())/cdf.max() #normalized cdf
    return hist,cdf_normalized

def animateSimoid(alfas,betas,x=None,interval=1000,show=True,frames=None):
    """
    Show sigmoid filter or animation of it if alfas or betas are iterable.

    :param alfas: array of alfa values or alfa value
    :param betas: array of beta values or beta value
    :param x: array of values or matrix to filter
    :param interval: time in millisecond of each update
    :return: None
    #example1:
    alfas = 10
    betas = np.linspace(0,256,256)
    simulateSimoid(alfas,betas)
    #example2:
    import cv2
    grayim = cv2.imread("asift2fore.png",0).astype("float")
    ani = simulateSimoid(125,np.linspace(0, 10, 13),grayim,100,show=False)
    ani.save('sigmoid.gif', fps=1)
    """
    if x is None:
        x = np.linspace(0, 255, 256)
    else:
        x = np.array(x,dtype=np.float)
    alfas = np.array(alfas,dtype=np.float)
    betas = np.array(betas,dtype=np.float)
    fig, ax = plt.subplots()
    # correct arrays
    if not len(alfas.shape): alfas = np.array((alfas,),dtype=np.float)
    if not len(betas.shape): betas = np.array((betas,),dtype=np.float)
    alfas[alfas==0]=0.01 # replacing 0 for aproximation
    if len(x.shape) == 1:  # if x is array
        ax_minx,ax_maxx = np.min(x),np.max(x) # control x axis
        ax_miny,ax_maxy = -1.5,1.5 # control y axis
        ax.hold(False) # plot replaces previous plots
        title = 'Sigmoid Filter: x = ['+str(ax_minx)+'-'+str(ax_maxx)+']'
        def updatefig(*args):
            args[1][0] = (args[1][0]+1)%len(alfas) # increase alfas index
            if args[1][0] ==0: # increase beta index
                args[1][1] = (args[1][1]+1)%len(betas)
            ax.plot(x, normsigmoid(x,alfas[args[1][0]],betas[args[1][1]]))
            ax.axis([ax_minx, ax_maxx, ax_miny, ax_maxy]) # set axis dimensions
            ax.set_title(title)
            ax.text(0, -1, ' alfa='+str(alfas[args[1][0]])+', beta='+str(betas[args[1][1]])) # set text
            return ax,
    else:  # if x is matrix array
        im = plt.imshow(normsigmoid(x,alfas[0],betas[0]), cmap=plt.get_cmap('jet'))
        title = 'Sigmoid Filter: x = '+str(x.shape)
        title_obj = plt.title(title) # plt.getp(title_obj)
        plt.colorbar()
        def updatefig(*args):
            args[1][0] = (args[1][0]+1)%len(alfas) # increase alfas index
            if args[1][0] ==0: # increase beta index
                args[1][1] = (args[1][1]+1)%len(betas)
            plt.setp(title_obj,text = title+', alfa='+str(alfas[args[1][0]])+', beta='+str(betas[args[1][1]])) # set title
            im.set_array(normsigmoid(x,alfas[args[1][0]],betas[args[1][1]]))
            plt.draw() # update plt title after image is shown
            return im,

    ab= np.array([-2,0])
    if frames is None:
        frames = len(alfas)*len(betas)
    ani = animation.FuncAnimation(fig, updatefig, frames, interval=interval, blit=True,fargs=[ab])
    if show: plt.show()
    return ani

def graphHistogram(img, show=True, size=None, hold=True):
    """
    Graph histogram from image.

    :param img: gray or BGR image
    :param show: if show in window
    :param size: size of image to get
    :param hold: if use hold on a previous plt figure
    :return: figure
    """
    if not hold: plt.figure()
    sz = img.shape
    if len(sz)==2:
        histr = cv2.calcHist([img],[0],None,[256],[0,256])
        plt.plot(histr,color = "k")
        plt.xlim([0,256])
    else:
        color = ('b','g','r')
        for i,col in enumerate(color):
            histr = cv2.calcHist([img],[i],None,[256],[0,256])
            plt.plot(histr,color = col)
            plt.xlim([0,256])
    fig = plt.gcf()
    if size is not None: fig.set_size_inches(*size)
    if show: plt.show()
    return fig

def graphmath(y, colors= None, linedic={'ls': '-'}, win=None, title=None, show=True):
    """
    Plots data.

    :param y: data to plot in y axis (x is its index)
    :param colors: list of colors for each y index
    :param linedic: line properties
    :param win: window title, if it is not None creates a figure.
    :param title: plot title
    :param show: if True, shows; Fase, only builds plot
    :return: figure, lines
    """
    #http://matplotlib.org/users/pyplot_tutorial.html
    if not isinstance(y,(tuple,list)): y = [y]
    if win is not None: plt.figure(win)
    if title is not None: plt.title(title)
    lines = []
    for i,axisy in enumerate(y):
        if colors is None:
            line = plt.plot(axisy)
        else:
            line = plt.plot(axisy,colors[i])
        lines.extend(line)
        plt.setp(line,**linedic)
    #plt.xlim([0,256])
    fig = plt.gcf()
    if show: plt.show()
    return fig, lines

def stem(x,y,color):
    """
    plot a stem in plot.

    :param x: x coordinate
    :param y: y coordinate
    :param color: the color of the stem
    :return: None
    """
    # remainder of how to plot stems in matplotlib
    markerline, stemlines, baseline = plt.stem(x,y,linefmt='b-', markerfmt='bo', basefmt='r-')
    plt.setp(stemlines, linewidth=1, color = color)     # set stems
    plt.setp(markerline, 'markerfacecolor', color)    # make points

def getthresh(gray):
    """
    Get best possible thresh to threshold object from the gray image.

    :param gray: gray image
    :return: thresh value
    """
    hist,cdf = hist_cdf(gray,11)
    th1 = 130 #np.min(np.where(cdf.max()*0.2<=cdf))
    th2 = np.max(np.where(hist.max()==hist))
    th3 = np.min(np.where(np.mean(cdf)<=cdf))
    #th4=findminima(hist,np.mean([th1,th2,th3]))
    return np.mean([th1,th2,th3])

def threshold(src, thresh, maxval=255, type=cv2.THRESH_BINARY):
    """
    Eliminate small objects from threshold.

    :param src:
    :param thresh:
    :param maxval:
    :param type:
    :return:
    """
    from .recommended import getKernel
    shape = src.shape
    kernel = getKernel(shape[0]*shape[1])
    #ks = kernel.shape[0]/3 # kenerl size?
    #kz = np.mean(src.shape)/50
    #kernel = np.ones((kz,kz),np.uint8)
    retval,th = cv2.threshold(src, thresh, maxval, type)
    th = cv2.morphologyEx(th, cv2.MORPH_OPEN, kernel)
    return th

def pad(im,pad_val,pad_width=1,expand = False):
    """
    Fills borders with given value.

    :param im: numpy array
    :param pad_val: value to use
    :param pad_width: border width
    :param expand:
    :return:
    """
    if expand:
        w,h = im.shape[0:2]
        padding = pad_width*2
        if len(im.shape)>2:
            back = np.ones((w+padding,h+padding,im.shape[2]),np.uint8)
        else:
            back = np.ones((w+padding,h+padding),np.uint8)
        x,y= convertXY(0,0,back.shape,im.shape,flag=4)
        im = overlayXY(x,y,back,im)

    im[0:pad_width,:] = pad_val
    im[:,0:pad_width] = pad_val
    im[-1:-1-pad_width:-1,:] = pad_val
    im[:,-1:-1-pad_width:-1] = pad_val
    return im

def croppad(im,pad_width=0):
    """

    :param im:
    :param pad_width:
    :return:
    """
    if pad_width:
        return im[pad_width:-pad_width,pad_width:-pad_width]
    return im

def retinalmask(gray,invert = False):
    """
    Mask of a ellipse enclosing retina.

    :param gray: gray image
    :param invert: invert mask
    :return: mask
    """
    thresh = getthresh(gray) # obtain optimus threshold
    rough_mask=threshold(gray,thresh,1,0)
    contours,hierarchy = cv2.findContours(rough_mask,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
    index,maxarea = 0,0
    for i in range(len(contours)):
        area = cv2.contourArea(contours[i])
        if area>maxarea: index,maxarea = i,area
    cnt = contours[index]
    ellipse = cv2.fitEllipse(cnt)
    if invert:
        mask = np.ones(gray.shape,dtype=np.uint8)
        cv2.ellipse(mask,ellipse,0,-1)
    else:
        mask = np.zeros(gray.shape,dtype=np.uint8)
        cv2.ellipse(mask,ellipse,1,-1)
    return mask

def circularMask(shape, radious = None, center=None):
    """

    :param shape:
    :param radious:
    :param center:
    :return:
    """
    # http://stackoverflow.com/a/8650741/5288758
    sa,sb = shape[:2]
    if center is None:
        a,b = sa//2,sb//2
    else:
        a, b = center
    if radious is None: radious = (sa+sb)//4
    y,x = np.ogrid[-a:sa-a, -b:sb-b]
    return x**2 + y**2 <= radious**2

def circularKernel(shape, dtype= None, radious = None, center=None, fillwith = 1):
    """

    :param shape:
    :param dtype:
    :param radious:
    :param center:
    :param fillwith:
    :return:
    """
    # http://stackoverflow.com/a/8650741/5288758
    mask = circularMask(shape=shape,radious=radious,center=center)
    array = np.zeros(mask.shape,dtype=dtype)
    array[mask] = fillwith
    return array

def simulateLens(img, scaled_shape = (300,300), parameters = (10,30,None),color = 0):
    """
    Place lens-like object in image.

    :param img: image to place lens
    :param scaled_shape: shape to resize processing image to increase performance
    :param parameters: for internal process used to filter image when getting brightness
    :param color: color of the lens
    :return: image with simulated lens
    """
    sz = img.shape[0:2] # get original image size
    scalepoints = spoint2opointfunc(sz,scaled_shape) # make rescaling function: scaled point -to- original point function
    scaled_img = cv2.resize(img,scaled_shape) # resize to scaled image
    fore2 = scaled_img.copy()

    if parameters is not None:
        myfilter = filterFactory(*parameters) # alfa,beta1,beta2
        fore2=myfilter(fore2.astype("float"))*255#*fore.astype("float")
        fore2 = fore2.astype("uint8")

    P = brightness(fore2) # get scaled image brightness
    thresh,sure_bg = cv2.threshold(P,0,1,cv2.THRESH_BINARY+cv2.THRESH_OTSU) # obtain over threshold
    thresh,sure_fg = cv2.threshold(P,thresh+10,1,cv2.THRESH_BINARY)

    markers = np.ones_like(sure_fg).astype("int32") # make background markers
    markers[sure_bg==1]=0 # mark unknown markers
    markers[sure_fg==1]=2 # mark sure object markers

    cv2.watershed(scaled_img,markers) # get watershed on markers

    thresh,lastthresh = cv2.threshold(markers.astype("uint8"),1,1,cv2.THRESH_BINARY) # get binary image of contour
    # find biggest area and contour
    contours,hierarchy = cv2.findContours(lastthresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
    index = 0
    maxarea = 0
    for i in range(len(contours)):
        area = cv2.contourArea(contours[i])
        if area>maxarea:
            index = i
            maxarea = area
    cnt = contours[index]
    cnt2 = np.int32(scalepoints(cnt)) # rescale contour to original image contour
    ellipse = cv2.fitEllipse(cnt2) # get ellipse for original image to simulate lens
    mask = np.ones(sz,dtype=np.uint8) # create mask
    cv2.ellipse(mask,ellipse,0,-1) # project lens over mask
    # simulate lens
    img[mask>0]=color # use mask to project black color over original image
    return img,mask

def simulateLens_approx(img, scaled_shape = (300,300), color = 0):
    """
    Place lens-like object in image.

    :param img: image to place lens
    :param scaled_shape: shape to resize processing image to increase performance
    :param parameters: for internal process used to filter image when getting brightness
    :param color: color of the lens
    :return: image with simulated lens
    """
    sz = img.shape[0:2] # get original image size
    if scaled_shape is None:
        P = brightness(img)
    else:
        P = brightness(cv2.resize(img,scaled_shape)) # get scaled image brightness
    thresh,lastthresh = cv2.threshold(P,0,1,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    cnt = CircleClosure(lastthresh)
    if scaled_shape is not None:
        scalepoints = spoint2opointfunc(sz,scaled_shape) # make rescaling function: scaled point -to- original point function
        cnt = np.int32(scalepoints(cnt)) # rescale contour to original image contour
    ellipse = cv2.fitEllipse(cnt) # get ellipse for original image to simulate lens
    mask = np.ones(sz,dtype=np.uint8) # create mask
    cv2.ellipse(mask,ellipse,0,-1) # project lens over mask
    # simulate lens
    img[mask>0]=color # use mask to project black color over original image
    return img,mask

def getalfa(foregray,backgray,window = None):
    """
    Get alfa transparency for merging to retinal images.

    :param foregray: image on top
    :param backgray: image at bottom
    :param window: window used to customizing alfa, values go from 0 for transparency to any value
                    where the maximum is visible i.e a window with all the same values does nothing.
                    a binary image can be used, where 0 is transparent and 1 is visible.
                    If not window is given alfa is left as intended.
    :return: float window modified by alfa
    """
    backmask = normalize(normsigmoid(backgray,10,180)+normsigmoid(backgray,3.14,192)+normsigmoid(backgray,-3.14,45))
    foremask = normalize(normsigmoid(foregray,-1,242)*normsigmoid(foregray,3.14,50))
    foremask = normalize(foremask * backmask)
    foremask[foremask>0.9] = 2.0
    ksize = (21,21)
    foremask = normalize(cv2.blur(foremask,ksize))
    if window is not None: foremask *= normalize(window)
    return foremask

def equalization(img):
    """
    Histogram equalization of an image as in:

        http://docs.opencv.org/doc/tutorials/imgproc/histograms/histogram_equalization/histogram_equalization.html

    :param img: image
    :return: equalized image, cdf (cumulative distribution function)
    """
    # http://docs.opencv.org/3.1.0/d5/daf/tutorial_py_histogram_equalization.html#gsc.tab=0
    # get hist and cdf from img
    hist,bins = np.histogram(img.flatten(),256,[0,256])
    cdf = hist.cumsum()
    # get equalized img in img2
    cdf_m = np.ma.masked_equal(cdf,0) # masking to leave out 0
    cdf_m = (cdf_m - cdf_m.min())*255/(cdf_m.max()-cdf_m.min()) # applying equalization
    cdf = np.ma.filled(cdf_m,0).astype('uint8') # cumulative distribution function
    return cdf[img], cdf


def getColors(im, coors=None):
    """
    Get coordinates' colors.

    :param im: image to get colors form coors.
    :param coors: coordinates of points.
    :return:
    """
    if coors is None: coors = getcoors(im)
    return [im[cor[1],cor[0]] for cor in coors]


def getColorsRange(im, coors=None):
    """
    get max and min values of colors in coordinates.

    :param im: image to get colors form coors.
    :param coors: coordinates of points.
    :return: max color, min color range
    """
    colors = getColors(im, coors)
    maxC,minC = np.max(colors,0),np.min(colors,0)
    return maxC,minC


def drawContours(mask, contours, min=50, max=256):
    """
    draw contours in mask.

    :param mask: mask to draw
    :param contours: contours
    :param min: min color range
    :param max: max color range
    :return: drawn mask
    """
    if len(mask.shape) > 2:
        ch = mask.shape[2]
    else:
        ch = 1
    for i in range(len(contours)):
        cv2.drawContours(mask, contours, i, random_color(ch, min, max), 2)
    return mask

def graphDeffects(img,cnt,defects,cline=(0,255,0),cpoint=(0,0,255),thickness=2, alfa=None):
    """
    Graphs convexity defects.

    :param img: source BGR image
    :param cnt: contour
    :param defects: convexity defects
    :param cline: line's color
    :param cpoint: points' colors
    :return: processed img
    """
    if alfa is not None:
        temp,img = img,np.zeros_like(img)
        imalfa = np.zeros(img.shape[:2])
    for i in range(defects.shape[0]):
        s,e,f,d = defects[i,0]
        start = tuple(cnt[s][0])
        end = tuple(cnt[e][0])
        far = tuple(cnt[f][0])
        cv2.line(img,start,end,cline,thickness)
        cv2.circle(img,far,thickness,cpoint,-1)
        if alfa is not None:
            cv2.line(imalfa,start,end,1,thickness)
            cv2.circle(imalfa,far,thickness,1,-1)
    if alfa is None:
        return img
    return overlay(temp, img, alpha=imalfa * alfa)

def twoMaxTest(defects,epsilon=0.5):
    """
    Filters distances from defects.

    :param defects:
    :param epsilon:
    :return:
    """
    distances = defects[:,0,3]
    two_max = np.argpartition(distances, -2)[-2:] # get indeces of two maximum values
    d1,d2 = distances[two_max[0]],distances[two_max[1]]*epsilon
    if d1>d2:
        return True
    else:
        return False

def separatingLine(cnt,defects):
    """
    Gets start and end points of separating line of deepest convexity defects.

    :param cnt: contour
    :param defects: convexity defects
    :return: start, end
    """
    positions = defects[:,0,2] # get positions
    distances = defects[:,0,3] # get its distances from hull
    two_max = np.argpartition(distances, -2)[-2:] # get indexes of two maximum distances
    point1 = tuple(cnt[positions[two_max[0]]][0]) # get point a one side
    point2 = tuple(cnt[positions[two_max[1]]][0]) # get point at the other side
    return point1,point2

def extendedSeparatingLine(shape, cnt, defects):
    """
    Get start and end points of separating line of deepest convexity defects extended to shape corners.

    :param shape: (x,y)
    :param cnt: contour
    :param defects: convexity defects
    :return: start, end
    """
    return extendLine(shape,*separatingLine(cnt, defects)) # extend the two points to the corners of the shape

def extendLine(shape,point1,point2):
    """
    extends a line passing by point 1 and 2 to reach shape borders.

    :param shape:
    :param point1:
    :param point2:
    :return:
    """
    h,w = shape[0:2]
    x1,y1 = point1
    x2,y2 = point2
    m = old_div((y2-y1),float(x2-x1))
    if m != float:
        if x1==x2: # vertical line
            start = x1,0
            end = x1,h
            return start,end
        if y1==y2: # horizontal line
            start = 0,y1
            end = w,y1
            return start,end
        return (x1,y1),(x2,y2) # unknown case, return "as it"
    # calculate using equation
    b = int(y1-x1*m)
    # find interception with xf and yf axis
    if b>h: # if start outside yf
        start = int(old_div((h-b),m)),h # (yf-b)/m, yf
    else: # if start inside yf
        start = 0,b # 0,y
    y = int(m*w+b) # m*xf+b
    if y<0: # if end outside yf
        end = int(old_div(-b,m)),0# x,0
    else: # if end inside yf
        end = w,y # xf, y
    return start,end # return extended line to image border

def colorpolygontest(res):
    """
    Get from polygontest a BGR color version.

    """
    # TO SPEED UP
    res = np.int0(np.around(res))
    mini = res.min()
    if not mini: mini = -1
    minie = old_div(255.0,mini)
    maxi = res.max()
    if not maxi: maxi = 1
    maxie = old_div(255.0,maxi)

    drawing = np.zeros((maxi-mini+1,3),np.uint8)  # image to draw the distance
    # correct res by adding minimum distance to res it is shifted to 0
    if mini<0:
        res += abs(mini)
    else:
        res -= mini
    #define the colors
    for h,i in enumerate(range(mini,maxi+1)):
        if i<0:
            drawing.itemset((h,0),255-int(minie*i))
        elif i>0:
            drawing.itemset((h,2),255-int(maxie*i))
        else:
            drawing[h]=[255,255,255]

    return drawing[res] # appy pallete

def _polygontest(src,cnt):
    """
    Draws polygontest in image from contour. (Helper function for polygontest)

    :param src: source binary image of int32
    :param cnt: contour
    :return: calculated polygon test in src
    """
    rows,cols = src.shape[0:2]
    for i in range(rows):# Calculate distance from each point
        for j in range(cols):
            src.itemset((i,j),cv2.pointPolygonTest(cnt,(j,i),True))
    return src

def center_polygontest(cnt,center):
    """
    Polygon tests from contour and center.

    :param cnt: contour
    :param center: (x,y)
    :return: array of tests
    """
    tempcnt = np.array([[center]])
    return np.absolute([cv2.pointPolygonTest(tempcnt,(i[0,0],i[0,1]),True) for i in cnt])

def center_distances(cnt,center):
    """
    Distances from contour and center.

    :param cnt: contour
    :param center: (x,y)
    :return: array of distances
    """
    return np.sqrt(np.sum(np.power(cnt-center,2),2)) # array.anorm(cnt-(cx,cy))

def pointdistance(point1,point2):
    """
    Distance from point1 to point2.

    :param point1: (x1,y1)
    :param point2: (x2,y2)
    :return: distance
    """
    x1,y1 = point1
    x2,y2 = point2
    return np.sqrt((x1-x2)**2+(y1-y2)**2)

def polygontest(src,cnt,mask = None):
    """
    Draw polygon test from contour in image.

    :param src: source binary image of int32
    :param cnt: contour
    :param mask: binary image
    :return: calculated polygontest with mask in src
    """
    if mask:
        for i,j in zip(*np.where(mask==1)):
            src.itemset((i,j),cv2.pointPolygonTest(cnt,(j,i),True))
        return src
    else:
        return _polygontest(src,cnt)

def polycenter(res):
    """
    Return centers from polygon test.

    :param res: polygontest
    :return: center, multiple centers
    """
    pts =  np.where(res == res.max())
    center_pts = list(zip(pts[1],pts[0]))
    center = pts[1][old_div(len(pts[0]),2)],pts[0][old_div(len(pts[0]),2)]
    return center,center_pts

def getThreshCenter1(thresh):
    """
    Get center with distance Transform's method.

    :param thresh:
    :return:
    """
    dist_transform = cv2.distanceTransform(thresh,cv2.DIST_LABEL_PIXEL,5) # simulate inside points
    dist_transform[thresh==0] = -1 # simulate outside points
    center,center_pts = polycenter(dist_transform) # get centers
    return center

def getThreshCenter2(thresh):
    """
    Get center with moments' method.

    :param thresh:
    :return:
    """
    cnt = thresh_biggestCnt(thresh)
    M = cv2.moments(cnt) # find moments
    cx = int(old_div(M['m10'],M['m00']))
    cy = int(old_div(M['m01'],M['m00']))
    return cx,cy

def getThreshCenter3(thresh):
    """
    Get center with boxCenter method.

    :param thresh:
    :return:
    """
    y,x = np.where(thresh==1)
    return ImCoors(list(zip(x, y)), np.int32).boxCenter

def getThreshCenter4(thresh):
    """
    Get center with mean's method.

    :param thresh:
    :return:
    """
    y,x = np.where(thresh==1)
    return ImCoors(list(zip(x, y)), np.int32).mean

def CircleClosure(thresh,epsilon=0.5):
    """
    Rough reduction of bumps from a circle or ellipse.

    :param thresh: binary image
    :return: approximated contours
    """
    #GET DESIRED CENTER
    # simulate polygon test with distance transform
    dist_transform = cv2.distanceTransform(thresh,cv2.DIST_LABEL_PIXEL,5) # simulate inside points
    dist_transform[thresh==0] = -1 # simulate outside points
    center,center_pts = polycenter(dist_transform) # get centers
    centerVal = dist_transform[center[1],center[0]] # selected center value

    #DRAW CIRCLE
    overcircle = np.zeros_like(thresh,np.uint8) # circle canvas
    cv2.circle(overcircle,center,centerVal,1,-1) # draw circle
    overcircle[thresh==0]=0 # thresh mask
    cnt = thresh_biggestCnt(overcircle) # get contours of biggest object

    #DEFECTS
    hull = cv2.convexHull(cnt,returnPoints = False) # find hull
    defects = cv2.convexityDefects(cnt,hull) # find defects
    if twoMaxTest(defects,epsilon):
        #SEPARATING LINE
        start,end = extendedSeparatingLine(thresh.shape, cnt, defects) # find line from biggest defects
        newThresh = thresh.copy() # do not modify thresh
        cv2.line(newThresh,start,end,0,2) # draw separating line
        approxcnt = thresh_biggestCnt(newThresh) # get contours of biggest object
        return approxcnt # return approximated contours
    else:
        return thresh_biggestCnt(thresh) # return original contours, with no defects!

def graphpolygontest(test, win ="Polygon test", centralcol = (0, 100, 0), centercol=(100, 100, 0)):
    """
    Visualize polygon test with its centers.

    :param test: polygon test or (image, contours) to make polygon test
    :param win: window name
    :param centralcol: multiple centers' color
    :param centercol: center's color
    :return: Plotim object

    Example::

        object.center_pts returns multiple centers
        object.center returns center most point
        object.sample returns polygontest
        object.plot() visualizes polygontest
    """
    if not isnumpy(test):
        src,cnt = test
        test = polygontest(src.copy().astype(np.int32),cnt,mask = None)

    graph = colorpolygontest(test)
    center,center_pts = polycenter(test)
    for pt in center_pts:
        cv2.circle(graph,pt,1,centralcol,-1)
    cv2.circle(graph,center,1,centercol,-1)
    plot = Plotim(win, graph)
    plot.center_pts = center_pts
    plot.center = center
    plot.sample = test
    plot.showpixel = False
    return plot

def std_deviation(arr):
    """
    calculate the standard deviation of an array.

    :param arr: input array
    :return: standard deviation
    """
    arr = arr.flatten()
    mean = np.mean(arr)
    deviation = np.abs(arr - mean)
    variance = old_div(anorm2(deviation),np.float(len(arr)))
    standard_deviation= np.sqrt(variance)
    return standard_deviation

def plainness(ROI):
    """
    From ROI calculate plainness (measure of change of intensities over an area)

    :param ROI: region of interest
    :return: plainness value
    """
    # find normalized_histogram, and its cumulative distribution function
    hist, bins = np.histogram(ROI.flatten(),256,[0,256])
    #s_values, bin_idx, s_counts = np.unique(ROI.flatten(), return_inverse=True, return_counts=True)
    hist_norm = old_div(hist.astype("float").ravel(),hist.max())
    return std_deviation(hist_norm)