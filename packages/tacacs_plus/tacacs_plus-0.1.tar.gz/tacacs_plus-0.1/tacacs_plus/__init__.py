# Copyright (c) 2017 Ansible by Red Hat
# All Rights Reserved.

import argparse
import getpass
import logging
import random
import select
import socket
import struct
import sys
from hashlib import md5

import six

logger = logging.getLogger(__file__)

# versioning
TAC_PLUS_MAJOR_VER = 0xc
TAC_PLUS_MINOR_VER = 0x0
TAC_PLUS_MINOR_VER_ONE = 0x1

# types + actions
TAC_PLUS_AUTHEN = 0x01
TAC_PLUS_AUTHEN_LOGIN = 0x01

# services
TAC_PLUS_AUTHEN_SVC_LOGIN = 0x01

# authentication types
TAC_PLUS_AUTHEN_TYPE_ASCII = 0x01
TAC_PLUS_AUTHEN_TYPE_PAP = 0x02
TAC_PLUS_AUTHEN_TYPE_CHAP = 0x03
TAC_PLUS_AUTHEN_TYPES = {
    'ascii': TAC_PLUS_AUTHEN_TYPE_ASCII,
    'pap': TAC_PLUS_AUTHEN_TYPE_PAP,
    'chap': TAC_PLUS_AUTHEN_TYPE_CHAP,
}

# authentication statuses
TAC_PLUS_AUTHEN_STATUS_PASS = 0x01
TAC_PLUS_AUTHEN_STATUS_FAIL = 0x02
TAC_PLUS_AUTHEN_STATUS_GETPASS = 0x05
TAC_PLUS_AUTHEN_STATUS_ERROR = 0x07

# priveleges
TAC_PLUS_PRIV_LVL_MIN = 0x00


def crypt(header, body_bytes, secret):
    """
    TACACS+ uses a shared secret key (known to both the client and server)
    to obfuscate the body of sent packets.  Only the packet body (not
    the header) is obfuscated.

    https://datatracker.ietf.org/doc/draft-ietf-opsawg-tacacs/?include_text=1#section-3.7

    ENCRYPTED {data} == data ^ pseudo_pad

    The pad is generated by concatenating a series of MD5 hashes (each 16
    bytes long) and truncating it to the length of the input data.

    pseudo_pad = {MD5_1 [,MD5_2 [ ... ,MD5_n]]} truncated to len(data)

    The first MD5 hash is generated by concatenating the session_id, the
    secret key, the version number and the sequence number and then
    running MD5 over that stream.  All of those input values are
    available in the packet header, except for the secret key which is a
    shared secret between the TACACS+ client and server.

    Subsequent hashes are generated by using the same input stream, but
    concatenating the previous hash value at the end of the input stream.

    MD5_1 = MD5{session_id, key, version, seq_no} MD5_2 = MD5{session_id,
    key, version, seq_no, MD5_1} ....  MD5_n = MD5{session_id, key,
    version, seq_no, MD5_n-1}

    :param header:     a TACACSHeader object
    :param body_bytes: packed bytes, i.e., `struct.pack(...)
    :param secret:     a key used to encrypt/obfuscate packets according
                       to the TACACS+ spec

    :return:           packed bytes, i.e., `struct.pack(...) representing the
                       obfuscated packet body
    """  # noqa

    # B = unsigned char
    # !I = network-order (big-endian) unsigned int
    body_length = len(body_bytes)
    unhashed = (
        struct.pack('!I', header.session_id) +
        six.b(secret) +
        struct.pack('B', header.version) +
        struct.pack('B', header.seq_no)
    )
    pad = hashed = md5(unhashed).digest()

    if (len(pad) < body_length):
        # remake hash, appending it to pad until pad >= header.length
        while True:
            hashed = md5(unhashed + hashed).digest()
            pad += hashed
            if len(pad) >= body_length:
                break

    pad = pad[0:(body_length)]
    pad = list(struct.unpack('B' * len(pad), pad))

    packet_body = []
    for x in struct.unpack('B' * body_length, body_bytes):
        packet_body.append(x ^ pad.pop(0))

    return struct.pack('B' * len(packet_body), *packet_body)


class TACACSPacket(object):

    def __init__(self, header, body_bytes, secret):
        """
        :param header:     a TACACSHeader object
        :param body_bytes: packed bytes, i.e., `struct.pack(...)
        :param secret:     a key used to encrypt/obfuscate packets according
                           to the TACACS+ spec
        """
        self.header = header
        self.body_bytes = body_bytes
        self.secret = secret

    @property
    def encrypted(self):
        return self.secret is not None

    @property
    def seq_no(self):
        return self.header.seq_no

    @property
    def body(self):
        if self.encrypted:
            return self.crypt
        return self.body_bytes

    def __str__(self):
        return self.header.packed + self.body

    def __bytes__(self):
        return self.header.packed + self.body

    @property
    def crypt(self):
        return crypt(self.header, self.body_bytes, self.secret)


class TACACSHeader(object):

    def __init__(self, version, type, session_id, length, seq_no=1, flags=0):
        self.version = version
        self.type = type
        self.session_id = session_id
        self.length = length
        self.seq_no = seq_no
        self.flags = flags

    @property
    def version_max(self):
        return self.version // 0x10

    @property
    def version_min(self):
        return self.version % 0x10

    @property
    def packed(self):
        # All TACACS+ packets always begin with the following 12 byte header.
        # The header is always cleartext and describes the remainder of the
        # packet:
        # 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        #
        # +----------------+----------------+----------------+----------------+
        # |major  | minor  |                |                |                |
        # |version| version|      type      |     seq_no     |   flags        |
        # +----------------+----------------+----------------+----------------+
        # |                            session_id                             |
        # +----------------+----------------+----------------+----------------+
        # |                              length                               |
        # +----------------+----------------+----------------+----------------+

        # B = unsigned char
        # !I = network-order (big-endian) unsigned int
        return struct.pack(
            'BBBB',
            self.version,
            self.type,
            self.seq_no,
            self.flags
        ) + struct.pack('!I', self.session_id) + struct.pack('!I', self.length)

    @classmethod
    def unpacked(cls, raw):
        # B = unsigned char
        # !I = network-order (big-endian) unsigned int
        raw = six.BytesIO(raw)
        version, type, seq_no, flags = struct.unpack(
            'BBBB',
            raw.read(4)
        )
        session_id, length = struct.unpack('!II', raw.read(8))
        return cls(version, type, session_id, length, seq_no, flags)

    def __str__(self):
        return ', '.join([
            'version: %s' % self.version,
            'type: %s' % self.type,
            'session_id: %s' % self.session_id,
            'length: %s' % self.length,
            'seq_no: %s' % self.seq_no,
            'flags: %s' % self.flags,
        ])


class TACACSAuthenticationStart(object):

    def __init__(self, username, authen_type, data=six.b('')):
        self.username = username
        self.action = TAC_PLUS_AUTHEN_LOGIN
        self.priv_lvl = TAC_PLUS_PRIV_LVL_MIN
        self.authen_type = authen_type
        self.service = TAC_PLUS_AUTHEN_SVC_LOGIN
        self.data = data

    @property
    def packed(self):
        # 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        #
        # +----------------+----------------+----------------+----------------+
        # |    action      |    priv_lvl    |  authen_type   |     service    |
        # +----------------+----------------+----------------+----------------+
        # |    user len    |    port len    |  rem_addr len  |    data len    |
        # +----------------+----------------+----------------+----------------+
        # |    user ...
        # +----------------+----------------+----------------+----------------+
        # |    port ...
        # +----------------+----------------+----------------+----------------+
        # |    rem_addr ...
        # +----------------+----------------+----------------+----------------+
        # |    data...
        # +----------------+----------------+----------------+----------------+

        # B = unsigned char
        # s = char[]
        username = six.b(self.username)
        data = self.data
        port = rem_addr = six.b('')
        body = struct.pack(
            'B' * 8,
            self.action,
            self.priv_lvl,
            self.authen_type,
            self.service,
            len(username),
            len(port),
            len(rem_addr),
            len(data),
        )
        for value in (username, port, rem_addr, data):
            body += struct.pack('%ds' % len(value), value)
        return body

    def __str__(self):
        return ', '.join([
            'action: %s' % self.action,
            'priv_lvl: %s' % self.priv_lvl,
            'authen_type: %s' % self.authen_type,
            'service: %s' % self.service,
            'user_len: %d' % len(self.username),
            'port_len: 0',
            'rem_addr_len: 0',
            'data_len: %s' % len(self.data),
            'user: %s' % self.username,
            'data: %s' % self.data
        ])


class TACACSAuthenticationContinue(object):
    def __init__(self, password):
        self.password = password

    @property
    def packed(self):
        # 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        #
        # +----------------+----------------+----------------+----------------+
        # |          user_msg len           |            data len             |
        # +----------------+----------------+----------------+----------------+
        # |     flags      |  user_msg ...
        # +----------------+----------------+----------------+----------------+
        # |    data ...
        # +----------------+

        # B = unsigned char
        # !H = network-order (big-endian) unsigned short
        # s = char[]
        password = six.b(self.password)
        return (
            struct.pack('!H', len(password)) +
            struct.pack('!H', 0) +
            struct.pack('B', 0) +
            struct.pack('%ds' % len(password), password)
        )

    def __str__(self):
        return ', '.join([
            'user_msg_len: %s' % len(self.password),
            'data_len: 0',
            'flags: 0',
            'user_msg: %s' % self.password
        ])


class TACACSAuthenticationReply(object):

    def __init__(self, status, flags, server_msg, data):
        self.status = status
        self.flags = flags
        self.server_msg = server_msg
        self.data = data

    @classmethod
    def unpacked(cls, raw):
        # 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        #
        # +----------------+----------------+----------------+----------------+
        # |     status     |      flags     |        server_msg len           |
        # +----------------+----------------+----------------+----------------+
        # |           data len              |        server_msg ...
        # +----------------+----------------+----------------+----------------+
        # |           data ...
        # +----------------+----------------+

        # B = unsigned char
        # !H = network-order (big-endian) unsigned short
        raw = six.BytesIO(raw)
        status, flags = struct.unpack('BB', raw.read(2))
        server_msg_len, data_len = struct.unpack('!HH', raw.read(4))
        server_msg = raw.read(server_msg_len)
        data = raw.read(data_len)
        return cls(status, flags, server_msg, data)

    @property
    def valid(self):
        return self.status == TAC_PLUS_AUTHEN_STATUS_PASS

    @property
    def invalid(self):
        return self.status == TAC_PLUS_AUTHEN_STATUS_FAIL

    @property
    def error(self):
        return self.status == TAC_PLUS_AUTHEN_STATUS_ERROR

    @property
    def getpass(self):
        return self.status == TAC_PLUS_AUTHEN_STATUS_GETPASS

    @property
    def human_status(self):
        return {
            TAC_PLUS_AUTHEN_STATUS_PASS: 'PASS',
            TAC_PLUS_AUTHEN_STATUS_FAIL: 'FAIL',
            TAC_PLUS_AUTHEN_STATUS_GETPASS: 'GETPASS',
            TAC_PLUS_AUTHEN_STATUS_ERROR: 'ERROR'
        }.get(self.status, 'UNKNOWN: %s' % self.status)

    def __str__(self):
        return ', '.join([
            'status: %s' % self.human_status,
            'flags: %s' % self.flags,
            'server_msg: %s' % self.server_msg,
            'data: %s' % self.data
        ])


class TACACSClient(object):
    """
    A TACACS+ authentication client.
    https://datatracker.ietf.org/doc/draft-ietf-opsawg-tacacs

    An open source TACACS+ server daemon is available at
    http://www.shrubbery.net/tac_plus/
    """

    _sock = None

    def __init__(self, host, port, secret, timeout=10, session_id=None,
                 version_max=TAC_PLUS_MAJOR_VER,
                 version_min=TAC_PLUS_MINOR_VER):
        """
        :param host:        hostname of the TACACS+ server
        :param port:        port of the TACACS+ server, generally 49
        :param secret:      the secret key used to obfuscate packet bodies; can
                            be `None` to disable packet body obfuscation
        :param session_id:  a unique 32-bit int representing the session; if
                            left empty, one will be auto-generated
        :param version_max: TACACS+ major version number, 12
        :param version_min: TACACS+ minor version number, 0 or 1
        """
        self.host = host
        self.port = port
        self.secret = secret
        self.timeout = timeout
        self.version_max = version_max
        self.version_min = version_min

        # session_id is an unsigned 32-bit int; unless it's provided, randomize
        self.session_id = session_id or random.randint(1, 2 ** 32 - 1)

    @property
    def version(self):
        return (self.version_max * 0x10) + self.version_min

    @property
    def sock(self):
        if not self._sock:
            conn = (self.host, self.port)
            self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self._sock.setblocking(1)
            self._sock.settimeout(self.timeout)
            self._sock.connect(conn)
        return self._sock

    def send(self, body, seq_no=1):
        """
        Send a TACACS+ message body

        :param body:    packed bytes, i.e., `struct.pack(...)
        :param seq_no:  The sequence number of the current packet.  The
                        first packet in a session MUST have the sequence
                        number 1 and each subsequent packet will increment
                        the sequence number by one.  Thus clients only send
                        packets containing odd sequence numbers, and TACACS+
                        servers only send packets containing even sequence
                        numbers.
        :return:        TACACSPacket
        :raises:        socket.timeout, socket.error
        """
        # construct a packet
        header = TACACSHeader(
            self.version,
            TAC_PLUS_AUTHEN,
            self.session_id,
            len(body.packed),
            seq_no=seq_no
        )
        packet = TACACSPacket(header, body.packed, self.secret)

        logger.debug('\n'.join([
            body.__class__.__name__,
            'sent header <%s>' % header,
            'sent body <%s>' % body,
        ]))
        self.sock.send(bytes(packet))

        readable, _, _ = select.select([self.sock], [], [], self.timeout)
        if readable:
            # TACACS+ header packets are always 12 bytes
            header_bytes = self.sock.recv(12)
            resp_header = TACACSHeader.unpacked(header_bytes)
            # If the reply header doesn't match, it's likely a non-TACACS+ TCP
            # service answering with data we don't antipicate.  Bail out.
            if any([
                resp_header.version != header.version,
                resp_header.type != header.type,
                resp_header.session_id != header.session_id
            ]):
                logger.debug('\n'.join([
                    resp_header.__class__.__name__,
                    'recv header <%s>' % resp_header,
                    resp_header.packed
                ]))
                raise socket.error

            # read the number of bytes specified in the response header
            body_bytes = six.b('')
            remaining = resp_header.length
            while remaining > 0:
                body_bytes += self.sock.recv(remaining)
                remaining = resp_header.length - len(body_bytes)
            return TACACSPacket(
                resp_header,
                body_bytes,
                self.secret
            )
        raise socket.timeout

    def authenticate(self, username, password,
                     authen_type=TAC_PLUS_AUTHEN_TYPE_ASCII,
                     chap_ppp_id=None, chap_challenge=None):
        """
        Authenticate to a TACACS+ server with a username and password.

        :param username:
        :param password:
        :param authen_type:    TAC_PLUS_AUTHEN_TYPE_ASCII,
                               TAC_PLUS_AUTHEN_TYPE_PAP,
                               TAC_PLUS_AUTHEN_TYPE_CHAP
        :param chap_ppp_id:    PPP ID when authen_type == 'chap'
        :param chap_challenge: challenge value when authen_type == 'chap'
        :return:               TACACSAuthenticationReply
        :raises:               socket.timeout, socket.error
        """
        start_data = six.b('')
        if authen_type in (TAC_PLUS_AUTHEN_TYPE_PAP,
                           TAC_PLUS_AUTHEN_TYPE_CHAP):
            self.version_min = TAC_PLUS_MINOR_VER_ONE

            if authen_type == TAC_PLUS_AUTHEN_TYPE_PAP:
                start_data = six.b(password)

            if authen_type == TAC_PLUS_AUTHEN_TYPE_CHAP:
                if not isinstance(chap_ppp_id, six.string_types):
                    raise ValueError('chap_ppp_id must be a string')
                if not isinstance(chap_challenge, six.string_types):
                    raise ValueError('chap_challenge must be a string')
                start_data = (
                    six.b(chap_ppp_id) +
                    six.b(chap_challenge) +
                    md5(six.b(
                        chap_ppp_id + password + chap_challenge
                    )).digest()
                )
        packet = self.send(
            TACACSAuthenticationStart(username, authen_type, start_data)
        )
        reply = TACACSAuthenticationReply.unpacked(packet.body)
        logger.debug('\n'.join([
            reply.__class__.__name__,
            'recv header <%s>' % packet.header,
            'recv body <%s>' % reply
        ]))
        if authen_type == TAC_PLUS_AUTHEN_TYPE_ASCII and reply.getpass:
            packet = self.send(TACACSAuthenticationContinue(password),
                               packet.seq_no + 1)
            reply = TACACSAuthenticationReply.unpacked(packet.body)
            logger.debug('\n'.join([
                reply.__class__.__name__,
                'recv header <%s>' % packet.header,
                'recv body <%s>' % reply
            ]))
        return reply


def handle_command_line():
    parser = argparse.ArgumentParser(description='simple tacacs+ auth client')
    parser.add_argument('command', choices=['authenticate'])
    parser.add_argument('username')
    parser.add_argument('host')
    parser.add_argument('--port', '-p', type=int, default=49)
    parser.add_argument('--authen_type', choices=TAC_PLUS_AUTHEN_TYPES,
                        default='ascii')
    parser.add_argument('--timeout', type=int, default=10)
    parser.add_argument('--debug', action='store_true')

    args = parser.parse_args()
    if args.debug:
        logging.basicConfig(level=logging.DEBUG)
        logger.warn("\033[93mTACACS+ --debug will log raw packet data INCLUDING PASSWORDS; proceed at your own risk!\033[00m")  # noqa

    secret = getpass.getpass('tacacs+ secret: ')
    password = getpass.getpass('password for %s: ' % args.username)

    chap_ppp_id = six.moves.input('chap PPP ID: ') if args.authen_type == 'chap' else None  # noqa
    chap_challenge = six.moves.input('chap challenge: ') if args.authen_type == 'chap' else None  # noqa

    auth = TACACSClient(
        args.host,
        args.port,
        secret,
        timeout=args.timeout
    ).authenticate(args.username, password,
                   TAC_PLUS_AUTHEN_TYPES[args.authen_type],
                   chap_ppp_id=chap_ppp_id,
                   chap_challenge=chap_challenge)
    if auth.valid:
        sys.exit(0)
    sys.exit(1)
