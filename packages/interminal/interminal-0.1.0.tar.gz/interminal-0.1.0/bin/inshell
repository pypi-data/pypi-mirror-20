#!/usr/bin/env python3

import sys
import os
import pty
import tty
import pipes

STDIN = 0
STDOUT = 1
SHELL = os.getenv('SHELL')


# launch a shell and inject the user's command into it. This is done with a
# pseudo-tty, so that the shell does everything it would if the user typed the
# command themselves

# Fork and launch a shell attached to a pseudo-tty:
pid, master_fd = pty.fork()
if pid == 0:
    # Child process becomes the shell:
    os.execlp(SHELL, SHELL)

# Change stdin to raw mode, storing the current mode so we can restore it
# later:
mode = tty.tcgetattr(STDIN)
tty.setraw(STDIN)

# Give the shell a chance to display its prompt before writing the
# command:
data = os.read(master_fd, 1024)
os.write(STDOUT, data)

# Escape the command, making it appropriate for entering into the shell:
command = ' '.join(pipes.quote(s) for s in sys.argv[1:]).encode('utf8') + b'\n'

# Write the command to the shell's terminal:
pty._writen(master_fd, command)

# Copy streams to each other thereafter:
try:
    pty._copy(master_fd)
except OSError:
    # Restore mode of stdin:
    tty.tcsetattr(0, tty.TCSAFLUSH, mode)
