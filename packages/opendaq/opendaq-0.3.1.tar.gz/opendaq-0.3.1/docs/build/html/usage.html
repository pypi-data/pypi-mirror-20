<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>openDAQ usage in Python &#8212; openDAQ 0.2.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API documentation" href="opendaq.html" />
    <link rel="prev" title="openDAQ" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="opendaq.html" title="API documentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="openDAQ"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">openDAQ 0.2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="opendaq-usage-in-python">
<h1>openDAQ usage in Python<a class="headerlink" href="#opendaq-usage-in-python" title="Permalink to this headline">¶</a></h1>
<div class="section" id="device-connection-and-port-handling">
<h2>Device connection and port handling<a class="headerlink" href="#device-connection-and-port-handling" title="Permalink to this headline">¶</a></h2>
<p>To establish a connection with the openDAQ through the command line type the following:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span>

<span class="kn">from</span> <span class="nn">opendaq</span> <span class="k">import</span> <span class="n">DAQ</span>

<span class="n">daq</span> <span class="o">=</span> <span class="n">DAQ</span><span class="p">(</span><span class="s2">&quot;/dev/ttyUSB0&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>When creating an object of type DAQ, you have to specify the actual port at wich the openDAQ is connected. This can be done, in UNIX operating systems, typing in the terminal:</p>
<blockquote>
<div><div class="code highlight-default"><div class="highlight"><pre><span></span>$ dmesg
</pre></div>
</div>
</div></blockquote>
<p>You should see something like this:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="o">...</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">cp210x</span>
<span class="p">[</span><span class="mf">17755.465949</span><span class="p">]</span> <span class="n">cp210x</span> <span class="mi">1</span><span class="o">-</span><span class="mf">4.4</span><span class="p">:</span><span class="mf">1.0</span><span class="p">:</span> <span class="n">cp210x</span> <span class="n">converter</span> <span class="n">detected</span>
<span class="p">[</span><span class="mf">17755.536101</span><span class="p">]</span> <span class="n">usb</span> <span class="mi">1</span><span class="o">-</span><span class="mf">4.4</span><span class="p">:</span> <span class="n">reset</span> <span class="n">full</span><span class="o">-</span><span class="n">speed</span> <span class="n">USB</span> <span class="n">device</span> <span class="n">number</span> <span class="mi">5</span> <span class="n">using</span> <span class="n">ehci</span><span class="o">-</span><span class="n">pci</span>
<span class="p">[</span><span class="mf">17755.629330</span><span class="p">]</span> <span class="n">usb</span> <span class="mi">1</span><span class="o">-</span><span class="mf">4.4</span><span class="p">:</span> <span class="n">cp210x</span> <span class="n">converter</span> <span class="n">now</span> <span class="n">attached</span> <span class="n">to</span> <span class="n">ttyUSB0</span>
</pre></div>
</div>
</div></blockquote>
<p>In this example, openDAQ is attached to the USB port named ttyUSB0.</p>
<p>If you are working in Windows, the name of the port will be something like <cite>COMxx</cite>
instead of <cite>/dev/ttyUSBxx</cite>. You can check the port in <em>Control
Panel-&gt;System-&gt;Device Manager</em>.</p>
<p>Now, with the object <em>daq</em> created, we can start working with it. If you want to
close the port, simply type the following:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="adc-reading-command-response-mode">
<h2>ADC reading (Command-Response mode)<a class="headerlink" href="#adc-reading-command-response-mode" title="Permalink to this headline">¶</a></h2>
<p>First of all, we must configure the ADC,specifying the positive analog input, and the negative analog input if we want to do differential measures.</p>
<p>This can be done using the <em>conf_adc</em> function:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">conf_adc</span><span class="p">(</span><span class="n">pinput</span><span class="p">,</span><span class="n">ninput</span><span class="p">,</span><span class="n">gain</span><span class="p">,</span><span class="n">nsamples</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The values of these parameters are listed in the following table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="30%" />
<col width="19%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
<th class="head">Value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>pinput</td>
<td>Positive input</td>
<td>1:8</td>
<td>AN1-AN8</td>
</tr>
<tr class="row-odd"><td>ninput</td>
<td>Negative input</td>
<td><p class="first">M:0,5,6,7,8,25</p>
<p>S: 0, 1:8</p>
<p class="last">N: 0, 1:8</p>
</td>
<td><p class="first">0: ref ground</p>
<p>25: ref 2,5 V</p>
<p class="last">rest: input pins</p>
</td>
</tr>
<tr class="row-even"><td>gain</td>
<td>Analog gain</td>
<td><p class="first">M: 0:4</p>
<p>S: 0:7</p>
<p class="last">N: 0:7</p>
</td>
<td><p class="first">x1/3,x1,x2,x10,x100</p>
<p>x1,x2,x4,x5,x8,x10,x16, x20</p>
<p class="last">x1,x2,x4,x5,x8,x10,x16, x32</p>
</td>
</tr>
<tr class="row-odd"><td>nsamples</td>
<td>Number of samples per
data point</td>
<td>[0-254]</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>There are three options to read the ADC.</p>
<p>If we want the raw data from the ADC, we can use</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">daq</span><span class="o">.</span><span class="n">read_adc</span><span class="p">()</span>

<span class="nb">print</span> <span class="n">data</span>
</pre></div>
</div>
</div></blockquote>
<p>Much better, if we want the data directly in Volts, just use:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">data_Volts</span> <span class="o">=</span> <span class="n">daq</span><span class="o">.</span><span class="n">read_analog</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>Finally, we can also read all the analog inputs simultaneously using the function <em>read_all</em>:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">data_Volts</span> <span class="o">=</span> <span class="n">daq</span><span class="o">.</span><span class="n">read_all</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>This function return a list with the readings (in Volts) of all analog inputs.</p>
</div>
<div class="section" id="dac-setting-cr-mode">
<h2>DAC setting (CR mode)<a class="headerlink" href="#dac-setting-cr-mode" title="Permalink to this headline">¶</a></h2>
<p>As in the case of reading the ADC, there are two functions to set the output of
the DAC: <em>set_analog(&#8216;V&#8217;)</em> and <em>set_dac(&#8216;raw&#8217;)</em>. The first set DAC output
voltage in V betwen the voltage hardware limits :</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">set_analog</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The function <em>set_dac</em> set the DAC with the raw binary data value:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">set_dac</span><span class="p">(</span><span class="mi">3200</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Model</th>
<th class="head">Output Voltage Range</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>openDAQ[M]</td>
<td>[-4.096V  4.096V]</td>
</tr>
<tr class="row-odd"><td>openDAQ[S]</td>
<td>[0V 4.096V]</td>
</tr>
<tr class="row-even"><td>openDAQ[N]</td>
<td>[-4.096V  4.096V]</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="stream-experiments-creation-stream-mode">
<h2>Stream Experiments Creation (Stream Mode)<a class="headerlink" href="#stream-experiments-creation-stream-mode" title="Permalink to this headline">¶</a></h2>
<p>OpenDAQ has two main modes of operation: Command-Response Mode and Stream (hardware-timed) Mode.</p>
<p>In command-response mode all communications are initiated by a command from the host PC, wich is followed by a response from openDAQ.</p>
<p>On the other hand, the Stream mode is a continous hardware-timed input mode where a list of channels that are scanned at a specified rate.</p>
<p>Stream Mode can be used in three kind of experiment modes, wich differ in the maximum scan rate allowed and the source of the timing clock (internal or external). We define an experiment as a certain data source with specific configuration, sampling rate and start and stop conditions:</p>
<ul class="simple">
<li>Stream experiments</li>
<li>External experiments</li>
<li>Burst experiments</li>
</ul>
<p>Once the experiment is configured we can start it:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>or stop it:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>We can read the data using the method <em>read</em>:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">stream_exp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<div class="section" id="stream-experiments">
<h3>Stream experiments<a class="headerlink" href="#stream-experiments" title="Permalink to this headline">¶</a></h3>
<p>For Stream Experiments, a specific data source is sampled in regular intervals, using internal timer to keep time count (Timer2). Fastest scan rate in this mode is 1kSPS (1ms of period).</p>
<p>User can configure up to 4 Stream experiments to be running simultaneously. They will have each an
internal buffer of about 400 samples, which will be normally enough not to lose any point in the
communications.</p>
<p>First of all we have to import the library and the constant definitions:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">opendaq</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">opendaq.daq</span> <span class="k">import</span> <span class="o">*</span>
</pre></div>
</div>
</div></blockquote>
<p>To create an Stream Experiment use the following function:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">stream_exp</span> <span class="o">=</span> <span class="n">daq</span><span class="o">.</span><span class="n">create_stream</span><span class="p">(</span><span class="n">ExpMode</span><span class="o">.</span><span class="n">ANALOG_IN</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">continuous</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>with parameters:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="23%" />
<col width="15%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
<th class="head">Value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ExpMode</td>
<td>Define data source
or destination</td>
<td>0:5</td>
<td><p class="first">0:ANALOG_IN</p>
<p>1:ANALOG_OUT</p>
<p>2:DIGITAL_IN</p>
<p>3:DIGITAL_OUT</p>
<p>4:COUNTER_IN</p>
<p class="last">5:CAPTURE_IN</p>
</td>
</tr>
<tr class="row-odd"><td>period</td>
<td>Period of the stream
experiment</td>
<td>1:65536</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>npoints</td>
<td>Total number of
points for the
experiment</td>
<td>0:65536</td>
<td>0 indicates continous adquisition (By default 10)</td>
</tr>
<tr class="row-odd"><td>continuous</td>
<td>Indicates if
experiment is
continuous</td>
<td>True or False</td>
<td>False:run once (By default False)</td>
</tr>
</tbody>
</table>
<p>Once created the experiment we can configure the input to read. For example, if we want to read the analog input 6 (AN6), without gain, we should use:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">stream_exp</span> <span class="o">=</span> <span class="n">daq</span><span class="o">.</span><span class="n">create_stream</span><span class="p">(</span><span class="n">ExpMode</span><span class="o">.</span><span class="n">ANALOG_IN</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="n">continuous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Now, we have to configure the channel. To do this we use the method <em>analog_setup</em> of the class <em>DAQStream</em>:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">stream_exp</span><span class="o">.</span><span class="n">analog_setup</span><span class="p">(</span><span class="n">pinput</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ninput</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">Gains</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">x1</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>with parameters:</p>
<p>For the example above:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">stream_exp</span><span class="o">.</span><span class="n">analog_setup</span><span class="p">(</span><span class="n">pinput</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">gain</span><span class="o">=</span><span class="n">GAIN_S_X2</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="external-experiments">
<h3>External experiments<a class="headerlink" href="#external-experiments" title="Permalink to this headline">¶</a></h3>
<p>External experiments use an external digital trigger source to perform readings. Fastest scan rates are in similar ranges as for the Stream experiments. The rest of properties and parameters are similar to Stream experiments.</p>
<p>User can define up to 4 external experiments at the same time, each of one connected to digital inputs D1 to D4 (the number of the internal DataChannel is connected to the digital input number) to act as trigger inputs.</p>
<p>Maximum number of experiments will be 4 in total, including all External and Stream experiments.</p>
<p>To create an External Experiment use the following function:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">create_external</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">clock_input</span><span class="p">,</span><span class="n">edge</span><span class="p">,</span><span class="n">npoints</span><span class="p">,</span><span class="n">continuous</span><span class="p">,</span><span class="n">buffersize</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The new parameters here are <em>clock_input</em> and <em>edge</em>, which are explained in the following table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="33%" />
<col width="21%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
<th class="head">Value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>clock_input</td>
<td>Assign a DataChannel
number and a digital
input for this
experiment</td>
<td>1:4</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>edge</td>
<td>New data on rising (1)
or falling (0) edges</td>
<td>0:1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>For example, we are going to create an external experiment with an analog readin in AN8 (SE):</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">extern_exp</span> <span class="o">=</span> <span class="n">daq</span><span class="o">.</span><span class="n">create_external</span><span class="p">(</span><span class="n">ExpMode</span><span class="o">.</span><span class="n">ANALOG_IN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">continuous</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>As with the stream experiment, now we have to setup the analog input:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">stream_exp</span><span class="o">.</span><span class="n">analog_setup</span><span class="p">(</span><span class="n">pinput</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ninput</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">Gains</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">x1</span><span class="p">)</span>

<span class="n">daq</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>We can use a while loop in this way:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">daq</span><span class="o">.</span><span class="n">is_measuring</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">extern_exp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="burst-experiments">
<h3>Burst experiments<a class="headerlink" href="#burst-experiments" title="Permalink to this headline">¶</a></h3>
<p>Burst experiments are also internally timed, like Stream experiments, but they are intended to use a faster sampling rate, up to 10kSPS.
The high acquisition rate limits the amount of things that the processor is capable of doing at the same time.
Thus, when a Burst experiment is carried out, no more experiments can run at the same time.</p>
<p>Burst experiment use a bigger internal buffer of about 1600 points to temporary store results. However, if the experiment goes on for a long time, the buffer will eventually get full and the firmware will enter “Auto-recovery” mode. This means that it will get no more points until buffer gets empty again, having
an time where no sample will be taken.</p>
<p>To create a burst experiment use the following function:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">burst_exp</span> <span class="o">=</span> <span class="n">daq</span><span class="o">.</span><span class="n">create_burst</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">continuous</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Here is an example of a how a burst experiment is configured to do a analog output streaming:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">preload_buffer</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">burst_source</span> <span class="o">=</span> <span class="n">daq</span><span class="o">.</span><span class="n">create_burst</span><span class="p">(</span><span class="n">ExpMode</span><span class="o">.</span><span class="n">ANALOG_IN</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">preload_buffer</span><span class="p">),</span> <span class="n">continous</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">burst_source</span><span class="o">.</span><span class="n">analog_setup</span><span class="p">()</span>
<span class="n">burst_source</span><span class="o">.</span><span class="n">load_signal</span><span class="p">(</span><span class="n">preload_buffer</span><span class="p">)</span>

<span class="n">daq</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="analog-output-streaming">
<h3>Analog output streaming<a class="headerlink" href="#analog-output-streaming" title="Permalink to this headline">¶</a></h3>
<p>With Stream and Burst experiments we can load  a generic waveform (of any type) and the device will reproduce it through the DAC. This can be achieved by this way:</p>
<ul class="simple">
<li>First create the waveform:</li>
</ul>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">preload_buffer</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># The waveform</span>
</pre></div>
</div>
<ul class="simple">
<li>Next, create the experiment (Stream or Burst, see next subsections)</li>
<li>Finally load the signal to the experiment:</li>
</ul>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">exp_name</span><span class="o">.</span><span class="n">load_signal</span><span class="p">(</span><span class="n">preload_buffer</span><span class="p">)</span>
</pre></div>
</div>
<p>IMPORTANT NOTE: Analog output streams always use internal DataChannel #4, thus digital input D4 will not be available for an External experiment.</p>
</div>
<div class="section" id="triggering-experiments">
<h3>Triggering experiments<a class="headerlink" href="#triggering-experiments" title="Permalink to this headline">¶</a></h3>
<p>From version 0.2.1 of the library, openDAQ allows setting trigger modes to start executing experiments.
Trigger sources may be software triggered (default), digital input trigger (rising or falling edge) or analog value (input value above or below a specific limit).</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">stream1</span><span class="o">.</span><span class="n">trigger_setup</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="27%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">type</th>
<th class="head">Value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SW_TRG</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>software trigger (default)</td>
</tr>
<tr class="row-odd"><td>DIN1_TRG</td>
<td>0/1</td>
<td>digital trigger</td>
</tr>
<tr class="row-even"><td>DIN2_TRG</td>
<td>0/1</td>
<td>digital trigger</td>
</tr>
<tr class="row-odd"><td>DIN3_TRG</td>
<td>0/1</td>
<td>digital trigger</td>
</tr>
<tr class="row-even"><td>DIN4_TRG</td>
<td>0/1</td>
<td>digital trigger</td>
</tr>
<tr class="row-odd"><td>DIN5_TRG</td>
<td>0/1</td>
<td>digital trigger</td>
</tr>
<tr class="row-even"><td>DIN6_TRG</td>
<td>0/1</td>
<td>digital trigger</td>
</tr>
<tr class="row-odd"><td>ABIG_TRG</td>
<td>any</td>
<td>analog trigger</td>
</tr>
<tr class="row-even"><td>ASML_TRG</td>
<td>any</td>
<td>analog trigger</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="capture-input">
<h2>Capture Input<a class="headerlink" href="#capture-input" title="Permalink to this headline">¶</a></h2>
<p>The capture input permits measuring the time length of incoming digital signals.
It makes use of device internal timer to calculate the time elapsed between changes in state (high to low or low to high) of
an external signal. OpenDAQ has a main clock running at 16MHz, which limits the minimum periods that the device is able to
measure to several microseconds.</p>
<p>The input in this mode is D5 (DIO 5 pin)</p>
<p>There are three methods associated with this mode: <em>init_capture</em>, <em>stop_capture</em> and  <em>get_capture</em>. To start measuring use</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">init_capture</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
</pre></div>
</div>
<p>where period is the estimated period of the wave (in microseconds), and its range is <em>32 bits</em>. Now , we can get the Capture reading:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">get_capture</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>mode</td>
<td>0:3</td>
<td><p class="first">0: Low cycle</p>
<p>1: High cycle</p>
<p class="last">2: Full period</p>
</td>
</tr>
</tbody>
</table>
<p>Finally, stop the capture when the experiment has finished:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">stop_capture</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="counter-input">
<h2>Counter Input<a class="headerlink" href="#counter-input" title="Permalink to this headline">¶</a></h2>
<p>The counter input is also based on Timer 1, and its functionality consists on counting number of edges coming through the port (D6).
This can be useful to measure the frequency of very fast signal or to read some kind of sensors.</p>
<p>User can select which kind of digital edges will the peripheral detect (high or low), and he can also read and reset the counter back to 0 whenever it is necessary.</p>
<p>The edges are counted in a <em>32-bit counter</em>.</p>
<p>To start counting type the following:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">init_counter</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>This method configure which edge increments the count: Low-to-High (1) or High-to-Low (0). To get the counter value:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">get_counter</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>If <em>reset&gt;0</em> , the counter is reset after perform the reading.</p>
</div>
<div class="section" id="encoder-input">
<h2>Encoder Input<a class="headerlink" href="#encoder-input" title="Permalink to this headline">¶</a></h2>
<p>The encoder input is based on external interrupts on pin D6. Its functionality consists on counting number of edges coming through
the digital input D6 while keeping track of the direction of the movement, by reading D5 on each interrupt.</p>
<p>User can select the maximum resolution of the encoder.</p>
<p>To work in this mode there are three methods. The first start the encoder function:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">init_encoder</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Resolution is the maximum number of ticks per round (32-bit counter).This command configures external interrupts on D6 and resets the pulse
counter to 0. Next, to get the current encoder relative position use:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">get_encoder</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>This method returns the actual encoder value. Finally, stop the encoder:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">stop_encoder</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="pwm-output">
<h2>PWM Output<a class="headerlink" href="#pwm-output" title="Permalink to this headline">¶</a></h2>
<p>Pulse Width Modulator generates a continuous digital signal at a given frequency. Duty refers to the portion of time that the signal spends in High state.</p>
<p>PWM output is connected to port D6 of openDAQ.</p>
<p>To start the PWM Output mode use the following method:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">init_pwm</span><span class="p">(</span><span class="n">duty</span><span class="p">,</span><span class="n">period</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Duty is the high time of the signal ([0:1023]). If 0, the signal is always low. Period is the period of the signal in microseconds. To stop the PWM:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">stop_pwm</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="pio-configuration-and-control-cr-mode">
<h2>PIO Configuration and control (CR mode)<a class="headerlink" href="#pio-configuration-and-control-cr-mode" title="Permalink to this headline">¶</a></h2>
<p>The openDAQ has 6 DIO (digital Inputs/Outputs). We have 4 DIO lines on the right side screw terminal block (D1-D4), and the two others on the left terminal block (D5-D6).</p>
<p>D5 is a multipurpose terminal that is also connected with internal microprocessor’s Timer/Counter 2. Apart from being used as a DIO, this terminal can be configured as
PWM output, Counter input or Capture input.</p>
<p>All the digital I/O lines include an internal series resistor and a protective diode that provides overvoltage/short-circuit protection. The series resistors (about 100Ω)
also limit the ability of these lines to sink or source current.</p>
<p>The DIOs have 3 possible states: input, output-high, or output-low. Each line of I/O can be configured individually. When configured as an input, the line has a 50kΩ pull-up
resistor to 5.0 volts. When configured as output-high, the line is connected to the internal 5.0 volt supply (through a series resistor).</p>
<p>When configured as output-low, a bit is connected to GND (through a series resistor). All digital I/O are configured to be inputs at power up.</p>
<p>We have two couples of commands to control the digital I/O lines. The first two ones control each line individually, one to set or read the line direction (input or output),
and the other to read or set the line value (high or low). The other two commands control the six lines at a time, one function to read or set the lines direction, and the
other command to read or set the lines values.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="34%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Arguments</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>set_pio_dir</em></td>
<td><p class="first">number: 1:6</p>
<p class="last">output: 0:1</p>
</td>
<td><p class="first">PIO number</p>
<p class="last">0: input; 1: output</p>
</td>
</tr>
<tr class="row-odd"><td><em>set_pio</em></td>
<td><p class="first">number: 1:6</p>
<p class="last">value: 0:1</p>
</td>
<td><p class="first">PIO number</p>
<p class="last">Digital value: 0 Low, 1 High</p>
</td>
</tr>
<tr class="row-even"><td><em>read_pio</em></td>
<td>number: 1:6</td>
<td>PIO number</td>
</tr>
<tr class="row-odd"><td><em>set_port_dir</em></td>
<td>output: 0:1</td>
<td>0: input; 1: output</td>
</tr>
<tr class="row-even"><td><em>set_port</em></td>
<td>value: 0:1</td>
<td>Digital value: 0 Low, 1 High</td>
</tr>
<tr class="row-odd"><td><em>read_port</em></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="bit-bang-spi-output">
<h2>Bit-bang SPI Output<a class="headerlink" href="#bit-bang-spi-output" title="Permalink to this headline">¶</a></h2>
<p>The Serial Peripheral Interface (SPI) is a very popular communications bus, used widely in electronics to control slave devices. This utility allows openDAQ to communicate with other low level devices, like external port expanders, PGAs, switches or other peripherals.</p>
<p>SPI is a synchronous serial data link that operates in full duplex mode, using a master/slave scheme, where the master device always initiates the data frame. Multiple slave devices are allowed with separated select lines.</p>
<p>The SPI bus specifies four logic signals:</p>
<ul class="simple">
<li>SCLK: serial clock (output from master)</li>
<li>MOSI: master output, slave input (output from master)</li>
<li>MISO: master input, slave output (output from slave)</li>
<li>SS: slave select (active low, output from master)</li>
</ul>
<p>To begin a communication, the bus master first configures the clock, and then transmits the logic 0 for the desired chip over the chip select line (SS). During each SPI clock cycle, a full duplex data transmission
occurs:</p>
<ul class="simple">
<li>The master sends a bit on the MOSI line, and the slave reads it from that same line</li>
<li>The slave sends a bit on the MISO line, and the master reads it from that same line</li>
</ul>
<p>Transmissions may involve any number of clock cycles.</p>
<p>A relevant issue concerning SPI transmissions, is how the SCLK behaves, and when the MISO and MOSI lines should be read. By convention, these options are named CPOL (clock polarity) and CPHA (clock phase). At CPOL=0 the base value of the clock, when inactive, is zero. CPHA=0 means sample on the leading (first) clock edge, while CPHA=1 means sample on the trailing (second) clock edge, regardless of whether that clock edge is rising or falling. Taking this into consideration, we can define up to four SPI modes, by combining the two possible values of each option.</p>
<p>OpenDAQ uses a so called bit-bang SPI mode, as the bus signals are generated entirely by software (no specific hardware is used).</p>
<p>Specific commands are available to configure the functions of the pins (which DIO number will be used for each SPI line) and the SPI mode (CPOL and CPHA). The SS lines must be controlled separately, using any of the DIO terminals not configured as SPI line (PIO command must be used).</p>
<p>To configure Bit-bang SPI use this method:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">spi_config</span><span class="p">(</span><span class="n">cpol</span><span class="p">,</span><span class="n">cpha</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Here, <em>cpol</em> is the clock polarity (clock pin state when inactive) and <em>chpa</em> is the clock phase (leading 0, or trailing 1 edges read).</p>
<p>To select the PIO numbers to use, we have  the following method:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">spi_setup</span><span class="p">(</span><span class="n">nbytes</span><span class="p">,</span><span class="n">sck</span><span class="p">,</span><span class="n">mosi</span><span class="p">,</span><span class="n">miso</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>where</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="29%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>nbytes</td>
<td>&nbsp;</td>
<td>Number of bytes</td>
</tr>
<tr class="row-odd"><td>sck</td>
<td>1 by default</td>
<td>Clock pin</td>
</tr>
<tr class="row-even"><td>mosi</td>
<td>2 by default</td>
<td>MOSI pin</td>
</tr>
<tr class="row-odd"><td>miso</td>
<td>3 by default</td>
<td>MISO pin</td>
</tr>
</tbody>
</table>
<p>Finally, to transfer (send and receive) a byte or a word use:</p>
<blockquote>
<div><div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">spi_write</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">word</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>If <em>word = True</em> , then we are sending a 2-byte word instead of a byte.</p>
</div>
<div class="section" id="other-functions">
<h2>Other functions<a class="headerlink" href="#other-functions" title="Permalink to this headline">¶</a></h2>
<p>There are other methods that can be used with the openDAQ. They are listed below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="23%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Arguments</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>enable_crc</em></td>
<td>on</td>
<td>Enable/Disable the cyclic redundancy check</td>
</tr>
<tr class="row-odd"><td><em>set_led</em></td>
<td>color</td>
<td>0:off ; 1: green ; 2: red ; 3: orange</td>
</tr>
<tr class="row-even"><td><em>set_id</em></td>
<td>id:  [000:999]</td>
<td>Identify openDAQ device</td>
</tr>
<tr class="row-odd"><td><em>device_info</em></td>
<td>None</td>
<td><p class="first">Read device configuration:</p>
<blockquote class="last">
<div><p>Hardware version</p>
<p>Firmware version</p>
<p>Device ID number</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="calibration">
<h2>Calibration<a class="headerlink" href="#calibration" title="Permalink to this headline">¶</a></h2>
<p><strong>IMPORTANT NOTE</strong>: The functions used for openDAQ calibration have been redesigned completely from firmware version 1.4.0 and python library version 0.3</p>
<p>Use the tool <strong>opendaq-utils</strong>, which is installed with the rest of the scripts, for device calibrating and updating.</p>
<blockquote>
<div></div></blockquote>
<div class="section" id="theory-of-operation">
<h3>Theory of operation<a class="headerlink" href="#theory-of-operation" title="Permalink to this headline">¶</a></h3>
<p>AIN and DAC commands are transmitted between the host PC and the device in raw binary using the full 16-bit range of the binary transmissions. For example, raw code -32768
correspond in the ADC readings of the openDAQ [M] to -4.096V, while it is equivalent to -12.0V for the openDAQ [S]. Maximum ADC raw values range up to 32767, which is equivalent
to 4.095V in openDAQ [M] and to 12.0V in openDAQ[S].</p>
<p>The same happens for the DAC values: in all openDAQ models maximum raw value (32767) is equivalent to a +4.096V output, and in case of openDAQ [M] minimum value is -32768 or -4.095V.
Minimum DAC value for openDAQ [S] is 0V which is equivalent to 0 raw code.</p>
<p>In the case of the ADC inputs the situation is more complex, as there are different gain settings that do affect the conversion between raw codes and real voltage values.</p>
<p>The devices always use the raw values for the internal calculations and data transmission, and it is the <em>daq.py</em> library who has the duty to translate those binary codes into actual
voltage values.</p>
<p>The relationships between the voltage values and raw codes are always linear, and a good approximation to transform the raw codes into voltages would be just to use the theorical
formulas that could be deduced from previous paragraphs. Anyhow, the voltage values calculated from the theorical formulas would have some error, because the components inside the
circuits of the openDAQ devices do not have a perfect ideal behaviour. Thus, a specific calibration is used for each openDAQ device, so that the values read by the ADCs and set in the
DAC are far more similar to the ideal values.</p>
<p>These values are stored in the permanent EEPROM memory of the openDAQs and used by the <em>opendaq-python</em> library to calculate the formulas between the raw codes and voltage values.
Those calculations are carried in a slighly different manner depending on the openDAQ model. The code of the conversions is in the <em>model.py</em> file.</p>
</div>
<div class="section" id="dac-calibration">
<h3>DAC calibration<a class="headerlink" href="#dac-calibration" title="Permalink to this headline">¶</a></h3>
<p>The functions that manage the DAC calibration are:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">set_dac_calib</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span> <span class="n">of</span> <span class="n">CalibReg</span> <span class="n">registers</span><span class="o">*</span><span class="p">)</span>
<span class="n">daq</span><span class="o">.</span><span class="n">get_dac_calib</span><span class="p">()</span>
</pre></div>
</div>
<p>These methods set and read the device DAC calibration, where <em>CalibReg</em> are pairs of slope and offset coefficients (<em>[dac_corr, dac_offset]</em>).
The values are the coefficients of the line that corrects the deviation between the ideal values and the actual values that the device outputs when it applies no calibration.</p>
<p>In the case of the of the DAC output the mathematical function between the theorical value and the raw binary code is exactly the same:</p>
<div class="math">
<p><span class="math">raw_dac_code = volts / dac_base_gain</span></p>
</div><p>And applying the calibration:</p>
<div class="math">
<p><span class="math">raw_dac_code = (volts - dac_offset) / (dac_base_gain * dac_corr)</span></p>
</div></div>
<div class="section" id="adc-calibration">
<h3>ADC calibration<a class="headerlink" href="#adc-calibration" title="Permalink to this headline">¶</a></h3>
<p>The functions that manage the DAC calibration are:</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="n">daq</span><span class="o">.</span><span class="n">get_adc_calib</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span> <span class="n">of</span> <span class="n">CalibReg</span> <span class="n">registers</span><span class="o">*</span><span class="p">)</span>
<span class="n">daq</span><span class="o">.</span><span class="n">get_adc_calib</span><span class="p">()</span>
</pre></div>
</div>
<p>Where as in the case of the DAC calibration, <em>CalibReg</em> are pairs of slope and offset coefficients (<em>[adc_corr, adc_offset]</em>).</p>
<ul class="simple">
<li><em>adc_corr</em> is the slope of the calibration lines, the read value divided by the real voltage value at the input.</li>
<li><em>adc_offset</em> is the zero crossing of the line, in this case the raw ADC value for a 0V input (in this case, it is not a voltage but a raw binary code).</li>
</ul>
<p>In the case of the ADC, several facts have to be taken into consideration:</p>
<ul class="simple">
<li>Each analog input will have a different calibration line</li>
<li>In the case of openDAQ [M] each gain setting must be calibrated separately, as the gains are set by resistor values with a relatively high tolerance. This is not the case of the</li>
</ul>
<p>openDAQ [S] and [N], which use a PGA with factory calibration for all ranges.
- The inputs of the openDAQ [S] have a different calibration if they are used as single ended (SE) or differential (DE). In the case of openDAQ [M] the calibration can be the same for
both modes, because the inputs are just multiplexed.</p>
<p>All of this translates into the following:</p>
<ul class="simple">
<li>openDAQ [M] has a total of 13 ADC calibration slots, 8 for each analog input, and 5 for each gain setting.</li>
<li>openDAQ [S] has 16 ADC calibration slots, 8 for each analog input in SE mode, and 8 for each input in DE mode.</li>
<li>openDAQ [N] has 16 ADC calibration slots, 8 for each analog input in SE mode, and 8 for each input in DE mode.</li>
</ul>
<p>The mathematical function between the raw code given by the device and the real analog value is given by an equation depending on the device model (check file <em>model.py</em>):</p>
<div class="math">
<p><span class="math">volts = raw / (adc_base_gain * gain_ampli)</span></p>
</div><p>Where <em>adc_base_gain</em> is the relationship between binary codes and volts at <em>gain 1x</em>, and <em>gain_ampli</em> the actual gain amplification being used.</p>
<p>Applying calibration to the equation above:</p>
<div class="math">
<p><span class="math">volts = (raw - adc_offset1 - (adc_offset2*gain_ampli) ) / (adc_corr1 * adc_corr2 * adc_base_gain * gain_ampli)</span></p>
</div></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">openDAQ usage in Python</a><ul>
<li><a class="reference internal" href="#device-connection-and-port-handling">Device connection and port handling</a></li>
<li><a class="reference internal" href="#adc-reading-command-response-mode">ADC reading (Command-Response mode)</a></li>
<li><a class="reference internal" href="#dac-setting-cr-mode">DAC setting (CR mode)</a></li>
<li><a class="reference internal" href="#stream-experiments-creation-stream-mode">Stream Experiments Creation (Stream Mode)</a><ul>
<li><a class="reference internal" href="#stream-experiments">Stream experiments</a></li>
<li><a class="reference internal" href="#external-experiments">External experiments</a></li>
<li><a class="reference internal" href="#burst-experiments">Burst experiments</a></li>
<li><a class="reference internal" href="#analog-output-streaming">Analog output streaming</a></li>
<li><a class="reference internal" href="#triggering-experiments">Triggering experiments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#capture-input">Capture Input</a></li>
<li><a class="reference internal" href="#counter-input">Counter Input</a></li>
<li><a class="reference internal" href="#encoder-input">Encoder Input</a></li>
<li><a class="reference internal" href="#pwm-output">PWM Output</a></li>
<li><a class="reference internal" href="#pio-configuration-and-control-cr-mode">PIO Configuration and control (CR mode)</a></li>
<li><a class="reference internal" href="#bit-bang-spi-output">Bit-bang SPI Output</a></li>
<li><a class="reference internal" href="#other-functions">Other functions</a></li>
<li><a class="reference internal" href="#calibration">Calibration</a><ul>
<li><a class="reference internal" href="#theory-of-operation">Theory of operation</a></li>
<li><a class="reference internal" href="#dac-calibration">DAC calibration</a></li>
<li><a class="reference internal" href="#adc-calibration">ADC calibration</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">openDAQ</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="opendaq.html"
                        title="next chapter">API documentation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/usage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="opendaq.html" title="API documentation"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="openDAQ"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">openDAQ 0.2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Ingen10 Ingenieria SL.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>